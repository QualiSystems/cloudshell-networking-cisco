# PySNMP SMI module. Autogenerated from smidump -f python CISCO-STACK-MIB
# by libsmi2pysnmp-0.1.3 at Mon Nov 23 14:47:20 2015,
# Python version sys.version_info(major=2, minor=7, micro=6, releaselevel='final', serial=0)

# Imports

( workgroup, ) = mibBuilder.importSymbols("CISCO-SMI", "workgroup")
( Integer, ObjectIdentifier, OctetString, ) = mibBuilder.importSymbols("ASN1", "Integer", "ObjectIdentifier", "OctetString")
( NamedValues, ) = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
( ConstraintsIntersection, ConstraintsUnion, SingleValueConstraint, ValueRangeConstraint, ValueSizeConstraint, ) = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsIntersection", "ConstraintsUnion", "SingleValueConstraint", "ValueRangeConstraint", "ValueSizeConstraint")
( VlanIndex, ) = mibBuilder.importSymbols("CISCO-VTP-MIB", "VlanIndex")
( PhysicalIndex, ) = mibBuilder.importSymbols("ENTITY-MIB", "PhysicalIndex")
( fddimibPORTIndex, fddimibPORTSMTIndex, ) = mibBuilder.importSymbols("FDDI-SMT73-MIB", "fddimibPORTIndex", "fddimibPORTSMTIndex")
( OwnerString, ifIndex, ifName, ) = mibBuilder.importSymbols("IF-MIB", "OwnerString", "ifIndex", "ifName")
( ModuleCompliance, NotificationGroup, ObjectGroup, ) = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup", "ObjectGroup")
( Bits, Counter32, Counter64, Integer32, IpAddress, ModuleIdentity, MibIdentifier, NotificationType, MibScalar, MibTable, MibTableRow, MibTableColumn, TimeTicks, TimeTicks, Unsigned32, ) = mibBuilder.importSymbols("SNMPv2-SMI", "Bits", "Counter32", "Counter64", "Integer32", "IpAddress", "ModuleIdentity", "MibIdentifier", "NotificationType", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "TimeTicks", "TimeTicks", "Unsigned32")
( DisplayString, MacAddress, RowStatus, TextualConvention, TruthValue, ) = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "MacAddress", "RowStatus", "TextualConvention", "TruthValue")
( ringStationMacAddress, ) = mibBuilder.importSymbols("TOKEN-RING-RMON-MIB", "ringStationMacAddress")

# Types

class VendorIdType(OctetString):
    subtypeSpec = OctetString.subtypeSpec+ValueSizeConstraint(3,3)
    fixedLength = 3


# Objects

ciscoStackNotificationsPrefix = MibIdentifier((0, 0))
ciscoStackMIB = ModuleIdentity((0, 1)).setRevisions(("2010-02-01 00:00","2007-12-12 00:00","2007-05-29 00:00","2007-05-25 00:00","2007-03-30 00:00","2005-10-28 00:00","2005-04-27 00:00","2004-05-14 00:00","2004-01-15 00:00","2003-05-29 00:00","2003-05-05 00:00","2002-09-24 00:00","2001-06-11 00:00","2001-04-11 00:00","2000-10-10 00:00","2000-05-16 00:00","2000-02-02 00:00","1999-09-30 00:00","1999-03-26 00:00","1999-02-12 00:00",))
if mibBuilder.loadTexts: ciscoStackMIB.setOrganization("Cisco Systems, Inc.")
if mibBuilder.loadTexts: ciscoStackMIB.setContactInfo("       Cisco Systems\nCustomer Service\n\nPostal: 170 W Tasman Drive\nSan Jose, CA  95134\nUSA\n\nTel: +1 800 553-NETS\n\nE-mail: cs-wbu@cisco.com,\ncs-lan-switch-snmp@cisco.com")
if mibBuilder.loadTexts: ciscoStackMIB.setDescription("This MIB provides configuration and runtime status for\nchassis, modules, ports, etc. on the Catalyst systems.")
systemGrp = MibIdentifier((0, 1, 1))
sysMgmtType = MibScalar((0, 1, 1, 1), Integer().subtype(subtypeSpec=SingleValueConstraint(4,3,6,2,1,5,)).subtype(namedValues=NamedValues(("other", 1), ("snmpV1", 2), ("smux", 3), ("snmpV2V1", 4), ("snmpV2cV1", 5), ("snmpV3V2cV1", 6), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysMgmtType.setDescription("Type of network management running on this                       entity.")
sysIpAddr = MibScalar((0, 1, 1, 2), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysIpAddr.setDescription("This entity's IP address.\nThis object is deprecated and replaced by\nciiIPAddressType and ciiIPAddress in\nCISCO-IP-IF-MIB.")
sysNetMask = MibScalar((0, 1, 1, 3), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysNetMask.setDescription("This entity's subnet mask.\nThis object is deprecated and replaced by\nciiIPAddressPrefixLength in CISCO-IP-IF-MIB.")
sysBroadcast = MibScalar((0, 1, 1, 4), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysBroadcast.setDescription("This entity's broadcast address.\nThis object is deprecated and replaced by\nciiIPAddressBroadcast in CISCO-IP-IF-MIB.")
sysTrapReceiverTable = MibTable((0, 1, 1, 5))
if mibBuilder.loadTexts: sysTrapReceiverTable.setDescription("The trap receiver table (0 to 20 entries). This                      table lists the addresses of Network Management\nStations that should receive trap messages from\nthis entity when an exception condition occurs.\n\nThis table is deprecated and replaced by\ntrapDestTable and other tables in SNMP-TARGET-\nMIB and SNMP-NOTIFICATION-MIB.")
sysTrapReceiverEntry = MibTableRow((0, 1, 1, 5, 1)).setIndexNames((0, "CISCO-STACK-MIB", "sysTrapReceiverAddr"))
if mibBuilder.loadTexts: sysTrapReceiverEntry.setDescription("A trap receiver table entry.")
sysTrapReceiverType = MibTableColumn((0, 1, 1, 5, 1, 1), Integer().subtype(subtypeSpec=SingleValueConstraint(1,2,)).subtype(namedValues=NamedValues(("valid", 1), ("invalid", 2), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysTrapReceiverType.setDescription("Setting this object to invalid(2) removes the                      corresponding entry from the sysTrapReceiverTable.\nTo add a new entry to the sysTrapReceiverTable,\nset this object to valid(1) for an IpAddress which\nis not already in the table.")
sysTrapReceiverAddr = MibTableColumn((0, 1, 1, 5, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysTrapReceiverAddr.setDescription("IP address for trap receiver.")
sysTrapReceiverComm = MibTableColumn((0, 1, 1, 5, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 20))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysTrapReceiverComm.setDescription("Community string used for trap messages to this                      trap receiver.")
sysCommunityTable = MibTable((0, 1, 1, 6))
if mibBuilder.loadTexts: sysCommunityTable.setDescription("The community table (4 entries). This table lists                      community strings and their access levels. When an\nSNMP message is received by this entity, the\ncommunity string in the message is compared with\nthis table to determine access rights of the\nsender.\n\nNote that this item is only accessible when using\nthe community string defined in sysCommunityRwa.")
sysCommunityEntry = MibTableRow((0, 1, 1, 6, 1)).setIndexNames((0, "CISCO-STACK-MIB", "sysCommunityAccess"))
if mibBuilder.loadTexts: sysCommunityEntry.setDescription("A community table entry.")
sysCommunityAccess = MibTableColumn((0, 1, 1, 6, 1, 1), Integer().subtype(subtypeSpec=SingleValueConstraint(3,2,1,4,)).subtype(namedValues=NamedValues(("other", 1), ("readOnly", 2), ("readWrite", 3), ("readWriteAll", 4), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysCommunityAccess.setDescription("A value of readWriteAll(4) allows the community                      to read and write all objects in the MIB. A\nvalue of readWrite(3) allows the community to\nread and write all objects except restricted\nitems such as community strings, which cannot\nbe accessed at all. A value of readOnly(2) allows\nthe community to read all objects except\nrestricted items. A value of other(1) allows no\naccess.")
sysCommunityString = MibTableColumn((0, 1, 1, 6, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 20))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysCommunityString.setDescription("Configurable community string with access rights                      defined by the value of sysCommunityAccess.")
sysAttachType = MibScalar((0, 1, 1, 7), Integer().subtype(subtypeSpec=SingleValueConstraint(3,1,5,4,2,)).subtype(namedValues=NamedValues(("other", 1), ("dualAttach", 2), ("singleAttach", 3), ("nullAttach", 4), ("dualPrio", 5), )).clone(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysAttachType.setDescription("The requested concentrator attachment type. For a                      dual attachment concentrator which can be\nconnected to the trunk ring, the first FDDI port\nis configured as A and the second FDDI port is\nconfigured as B.\nFor a single attachment concentrator which can be\nconnected beneath another concentrator, the first\nFDDI port is configured as M and the second FDDI\nport is configured as S. For a null attachment\nconcentrator which can be located at the root of\nthe tree, the first two FDDI ports are configured\nas M.\nThis object does not take effect until the\nconcentrator is reset. The current attachment\ntype can be determined from snmpFddiPORTPCType\nfor ports 1 and 2.")
sysTraffic = MibScalar((0, 1, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysTraffic.setDescription("Traffic meter value, i.e. the percentage of                      bandwidth utilization for the previous polling\ninterval.")
sysReset = MibScalar((0, 1, 1, 9), Integer().subtype(subtypeSpec=SingleValueConstraint(2,3,1,)).subtype(namedValues=NamedValues(("other", 1), ("reset", 2), ("resetMinDown", 3), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysReset.setDescription("Writing reset(2) to this object resets the                      control logic of all modules in the system.\nWriting resetMinDown(3) to this object resets the\nsystem with the minimal system down time. The\nresetMinDown(3) is only supported in systems with\nredundant supervisors.\n\nThis object is deprecated and replaced by\ncsyScheduledReset in CISCO-SYSTEM-MIB.")
sysBaudRate = MibScalar((0, 1, 1, 10), Integer().subtype(subtypeSpec=SingleValueConstraint(19200,600,9600,1200,4800,2400,38400,)).subtype(namedValues=NamedValues(("b1200", 1200), ("b19200", 19200), ("b2400", 2400), ("b38400", 38400), ("b4800", 4800), ("b600", 600), ("b9600", 9600), )).clone(9600)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysBaudRate.setDescription("The baud rate in bits per second of the RS-232                      port.")
sysInsertMode = MibScalar((0, 1, 1, 11), Integer().subtype(subtypeSpec=SingleValueConstraint(3,4,1,2,)).subtype(namedValues=NamedValues(("other", 1), ("standard", 2), ("scheduled", 3), ("graceful", 4), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysInsertMode.setDescription("The mode for inserting M-ports into the                       concentrator ring.")
sysClearMacTime = MibScalar((0, 1, 1, 12), TimeTicks()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysClearMacTime.setDescription("The time (in hundredths of a second) since mac                      counters were last cleared. Writing a 0 to this\nobject causes the mac counters to be cleared.")
sysClearPortTime = MibScalar((0, 1, 1, 13), TimeTicks()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysClearPortTime.setDescription("The time (in hundredths of a second) since port                      counters were last cleared. Writing a 0 to this\nobject causes the port counters to be cleared.")
sysFddiRingTable = MibTable((0, 1, 1, 14))
if mibBuilder.loadTexts: sysFddiRingTable.setDescription("The fddi ring map table. This table lists the                      nodes in the FDDI ring(s) to which the system\nbelongs.")
sysFddiRingEntry = MibTableRow((0, 1, 1, 14, 1)).setIndexNames((0, "CISCO-STACK-MIB", "sysFddiRingSMTIndex"), (0, "CISCO-STACK-MIB", "sysFddiRingAddress"))
if mibBuilder.loadTexts: sysFddiRingEntry.setDescription("A FDDI Ring table entry.")
sysFddiRingSMTIndex = MibTableColumn((0, 1, 1, 14, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysFddiRingSMTIndex.setDescription("The value of the SMT index associated with this                      ring.")
sysFddiRingAddress = MibTableColumn((0, 1, 1, 14, 1, 2), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysFddiRingAddress.setDescription("The MAC address of this node in the FDDI ring.")
sysFddiRingNext = MibTableColumn((0, 1, 1, 14, 1, 3), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysFddiRingNext.setDescription("The MAC address of the next node in the FDDI                       ring.")
sysEnableModem = MibScalar((0, 1, 1, 15), Integer().subtype(subtypeSpec=SingleValueConstraint(2,1,)).subtype(namedValues=NamedValues(("enabled", 1), ("disabled", 2), )).clone(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysEnableModem.setDescription("Indicates whether the RS-232 port modem control                      lines are enabled.")
sysEnableRedirects = MibScalar((0, 1, 1, 16), Integer().subtype(subtypeSpec=SingleValueConstraint(2,1,)).subtype(namedValues=NamedValues(("enabled", 1), ("disabled", 2), )).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysEnableRedirects.setDescription("Indicates whether ICMP redirect messages are sent                      or received by the system.")
sysEnableRmon = MibScalar((0, 1, 1, 17), Integer().subtype(subtypeSpec=SingleValueConstraint(2,1,)).subtype(namedValues=NamedValues(("enabled", 1), ("disabled", 2), )).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysEnableRmon.setDescription("Indicates whether the SNMP agent supports the                      RMON MIB.")
sysArpAgingTime = MibScalar((0, 1, 1, 18), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1000000)).clone(1200)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysArpAgingTime.setDescription("The aging time for the ARP table.")
sysTrafficPeak = MibScalar((0, 1, 1, 19), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysTrafficPeak.setDescription("Peak traffic meter value since the last time port                      counters were cleared or the system started (see\nsysClearPortTime).")
sysTrafficPeakTime = MibScalar((0, 1, 1, 20), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysTrafficPeakTime.setDescription("The time (in hundredths of a second) since the                      peak traffic meter value occurred.")
sysCommunityRwa = MibScalar((0, 1, 1, 21), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 20))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysCommunityRwa.setDescription("When an SNMP message is received by this entity,                      the community string in the message is compared\nwith this string first. If it matches, read-write\naccess is granted to all items in the MIB. If it\ndoesn't match, the sysCommunityRw string is\ncompared next.\n\nNote that this item is only accessible when using\nthe community string defined in sysCommunityRwa.")
sysCommunityRw = MibScalar((0, 1, 1, 22), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 20))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysCommunityRw.setDescription("When an SNMP message is received by this entity,                      the community string in the message is compared\nwith this string second. If it matches, read-write\naccess is granted to all items in the MIB except\nrestricted items such as community strings.\n(Restricted items appear empty when read and\nreturn a no such name error when an attempt is\nmade to write them.)  If it doesn't match, the\nsysCommunityRo string is compared next.\n\nNote that this item is only accessible when using\nthe community string defined in sysCommunityRwa.")
sysCommunityRo = MibScalar((0, 1, 1, 23), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 20))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysCommunityRo.setDescription("When an SNMP message is received by this entity,                      the community string in the message is compared\nwith this string third. If it matches, read-only\naccess is granted to all items in the MIB except\nrestricted items such as community strings.\n(Restricted items appear empty when read.) If it\ndoesn't match, no access is granted, no response\nis sent back to the SNMP requester, and an SNMP\nis sent to the SNMP trap receivers if configured.\n\nNote that this item is only accessible when using\nthe community string defined in sysCommunityRwa.")
sysEnableChassisTraps = MibScalar((0, 1, 1, 24), Integer().subtype(subtypeSpec=SingleValueConstraint(2,1,)).subtype(namedValues=NamedValues(("enabled", 1), ("disabled", 2), )).clone(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysEnableChassisTraps.setDescription("Indicates whether chassisAlarmOn and                      chassisAlarmOff traps in this MIB should be\ngenerated.")
sysEnableModuleTraps = MibScalar((0, 1, 1, 25), Integer().subtype(subtypeSpec=SingleValueConstraint(2,1,)).subtype(namedValues=NamedValues(("enabled", 1), ("disabled", 2), )).clone(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysEnableModuleTraps.setDescription("Indicates whether moduleUp and moduleDown traps                      in this MIB should be generated.")
sysEnableBridgeTraps = MibScalar((0, 1, 1, 26), Integer().subtype(subtypeSpec=SingleValueConstraint(2,1,3,4,)).subtype(namedValues=NamedValues(("enabled", 1), ("disabled", 2), ("enabledForNewRootOnly", 3), ("enabledForTopoChangeOnly", 4), )).clone(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysEnableBridgeTraps.setDescription("Indicates whether newRoot and topologyChange                      traps in the BRIDGE-MIB (RFC 1493) should be\ngenerated.\n\nenabled -- both newRoot and topologyChange\n           traps are enabled.\n\ndisabled -- both of the newRoot and\n           topologyChange traps are disabled.\n\nenabledForNewRootOnly -- only the newRoot trap is\n           enabled. This value is read-only.\n\nenabledForTopoChangeOnly -- only the\n           topologyChange trap is enabled. This\n           value is read-only.\n\nThis object is deprecated and replaced by\nstpxNotificationEnable in\nCISCO-STP-EXTENSIONS-MIB.")
sysIpVlan = MibScalar((0, 1, 1, 27), VlanIndex().clone('1')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysIpVlan.setDescription("This entity's IP address Virtual LAN                      association.")
sysConfigChangeTime = MibScalar((0, 1, 1, 28), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysConfigChangeTime.setDescription("The time (in hundredths of a second) since the                      configuration of the system was last changed.")
sysEnableRepeaterTraps = MibScalar((0, 1, 1, 29), Integer().subtype(subtypeSpec=SingleValueConstraint(2,1,)).subtype(namedValues=NamedValues(("enabled", 1), ("disabled", 2), )).clone(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysEnableRepeaterTraps.setDescription("Indicates whether the traps in the REPEATER-MIB                      (RFC1516) should be generated.")
sysBannerMotd = MibScalar((0, 1, 1, 30), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysBannerMotd.setDescription("Message of the day banner which is displayed on                      the Command Line Interface before log in.")
sysEnableIpPermitTraps = MibScalar((0, 1, 1, 31), Integer().subtype(subtypeSpec=SingleValueConstraint(2,1,)).subtype(namedValues=NamedValues(("enabled", 1), ("disabled", 2), )).clone(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysEnableIpPermitTraps.setDescription("Indicates whether the IP permit traps in this MIB                       should be generated.")
sysTrafficMeterTable = MibTable((0, 1, 1, 32))
if mibBuilder.loadTexts: sysTrafficMeterTable.setDescription("The system traffic meter table. This table                      lists the traffic meters available in the\nsystem.")
sysTrafficMeterEntry = MibTableRow((0, 1, 1, 32, 1)).setIndexNames((0, "CISCO-STACK-MIB", "sysTrafficMeterType"))
if mibBuilder.loadTexts: sysTrafficMeterEntry.setDescription("A traffic meter table entry.")
sysTrafficMeterType = MibTableColumn((0, 1, 1, 32, 1, 1), Integer().subtype(subtypeSpec=SingleValueConstraint(1,4,3,2,)).subtype(namedValues=NamedValues(("systemSwitchingBus", 1), ("switchingBusA", 2), ("switchingBusB", 3), ("switchingBusC", 4), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysTrafficMeterType.setDescription("The type of traffic meter.")
sysTrafficMeter = MibTableColumn((0, 1, 1, 32, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysTrafficMeter.setDescription("Traffic meter value, i.e. the percentage of                      bandwidth utilization for the previous polling\ninterval.")
sysTrafficMeterPeak = MibTableColumn((0, 1, 1, 32, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysTrafficMeterPeak.setDescription("Peak traffic meter value since the system                      started.")
sysTrafficMeterPeakTime = MibTableColumn((0, 1, 1, 32, 1, 4), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysTrafficMeterPeakTime.setDescription("The time (in hundredths of a second) since the                      peak traffic meter value occurred.")
sysEnableVmpsTraps = MibScalar((0, 1, 1, 33), Integer().subtype(subtypeSpec=SingleValueConstraint(2,1,)).subtype(namedValues=NamedValues(("enabled", 1), ("disabled", 2), )).clone(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysEnableVmpsTraps.setDescription("Indicates whether the vmVmpsChange trap defined                      in CISCO-VLAN-MEMBERSHIP-MIB should be generated.")
sysConfigChangeInfo = MibScalar((0, 1, 1, 34), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysConfigChangeInfo.setDescription("Indicates which NVRAM block is changed by whom.")
sysEnableConfigTraps = MibScalar((0, 1, 1, 35), Integer().subtype(subtypeSpec=SingleValueConstraint(2,1,)).subtype(namedValues=NamedValues(("enabled", 1), ("disabled", 2), )).clone(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysEnableConfigTraps.setDescription("Indicates whether sysConfigChange trap in this                      MIB should be generated.")
sysConfigRegister = MibScalar((0, 1, 1, 36), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2).clone(hexValue='010f')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysConfigRegister.setDescription("The value of configuration register that will be                      used by the supervisor module when the system is\nrestarted.\nThis MIB object is only supported in systems with\nsupervisor modules having ROMMON support.\n\nThe lowest four bits of the configuration register\n(bits 3,2,1, and 0) form the boot field and the\nboot field determines whether the system boots\nfrom as the following:\n0000  -- stay in ROM monitor\n0001  -- boot from the first bootable system\n         images on the bootflash\n0010 to 1111\n      -- boot from the first bootable system\n         images specified in the sysBootVariable\n\nThe bit 5(0x0020) indicates whether the\nconfiguration file specified in\nsysStartupConfigSourceFile will beused recurringly\nor not whenever the system resets. If this bit is\nnot set, the configuration file(s) specified in\nsysStartupConfigSourceFile will only be used once\nand the value of sysStartupConfigSourceFile will\nbe reset to empty string automatically during the\nnext system reset.\n\nIf the bit 6(0x0040) is set, the system will start\nwith default configuration.\n\nThe bits 11,12 (0x0800, 0x1000) are used to\nspecify the console line speed in ROM monitor mode\nas the following:\n00   -- 9600\n01   -- 1200\n10   -- 4800\n11   -- 2400\n\nThe unspecified bits are not used.")
sysBootVariable = MibScalar((0, 1, 1, 37), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysBootVariable.setDescription("A list of the system boot images in the BOOT                      environment variable on supervisor modules with\nROMMON. The format of sysBootVariable should be:\n<device>:[<fileName>],1;{<device>:[<fileName>],1;...}\nIf the [fileName] is not specified, the first file\non the <device> will be used.\n\nThis MIB object is only supported in systems\nhaving supervisor modules with ROMMON.")
sysBootedImage = MibScalar((0, 1, 1, 38), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysBootedImage.setDescription("The name of the system boot image which the                      system booted from.\nThis MIB object is only supported in the system\nwith Supervisor module 3 present.")
sysEnableEntityTrap = MibScalar((0, 1, 1, 39), Integer().subtype(subtypeSpec=SingleValueConstraint(2,1,)).subtype(namedValues=NamedValues(("enabled", 1), ("disabled", 2), )).clone(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysEnableEntityTrap.setDescription("Indicates whether entConfigChange trap in the                      ENTITY-MIB should be generated.")
sysEnableStpxTrap = MibScalar((0, 1, 1, 40), Integer().subtype(subtypeSpec=SingleValueConstraint(2,8,6,5,4,7,3,1,)).subtype(namedValues=NamedValues(("enabled", 1), ("disabled", 2), ("enabledForInconOnly", 3), ("enabledForRootOnly", 4), ("enabledForLoopOnly", 5), ("enabledForInconRootOnly", 6), ("enabledForInconLoopOnly", 7), ("enabledForRootLoopOnly", 8), )).clone(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysEnableStpxTrap.setDescription("Indicates whether stpxInconsistencyUpdate,                      stpxRootInconsistencyUpdate and\nstpxLoopInconsistencyUpdate notifications in\nCISCO-STP-EXTENSIONS-MIB should be generated.\n\nenabled -- the stpxInconsistencyUpdate,\n           stpxRootInconsistencyUpdate and\n           stpxLoopInconsistencyUpdate traps are\n           all enabled.\n\ndisabled -- the stpxInconsistencyUpdate,\n           stpxRootInconsistencyUpdate and\n           stpxLoopInconsistencyUpdate traps\n           are all disabled.\n\nenabledForInconOnly -- only the\n           stpxInconsistencyUpdate trap is\n           enabled. This value is read-only.\n\nenabledForRootOnly -- only the\n           stpxRootInconsistencyUpdate trap is\n           enabled. This value is read-only.\n\nenabledForLoopOnly -- only the\n           stpxLoopInconsistencyUpdate trap is\n           enabled. This value is read-only.\n\nenabledForInconRootOnly -- only the\n           stpxInconsistencyUpdate and\n           stpxRootInconsistencyUpdate traps are\n           enabled. This value is read-only.\n\nenabledForInconLoopOnly -- only the\n           stpxInconsistencyUpdate and\n           stpxLoopInconsistencyUpdate traps are\n           enabled. This value is read-only.\n\nenabledForRootLoopOnly -- only the\n           stpxRootInconsistencyUpdate and\n           stpxLoopInconsistencyUpdate traps are\n           enabled. This value is read-only.\n\nThis object is deprecated and replaced by\nstpxNotificationEnable in\nCISCO-STP-EXTENSIONS-MIB.")
sysExtendedRmonVlanModeEnable = MibScalar((0, 1, 1, 41), Integer().subtype(subtypeSpec=SingleValueConstraint(2,1,)).subtype(namedValues=NamedValues(("enabled", 1), ("disabled", 2), )).clone(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysExtendedRmonVlanModeEnable.setDescription("Indicates whether the Extended RMON VlanMode                      feature is enabled or not. If it is set to\nenabled(1), hostTable (rmon 4) will provide the\ninformation of a list of VLANs instead of a list\nof MAC addresses for a monitored trunking port.")
sysExtendedRmonNetflowPassword = MibScalar((0, 1, 1, 42), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 20))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysExtendedRmonNetflowPassword.setDescription("The password for enabling the Extended RMON                      Netflow feature and this object has to be set\nbefore setting sysExtendedRmonNetflowEnable to\nenabled(1). When reading this object, it will\nreturn empty string.\n\nIf the platform supports\nsysExtendedRmonNetflowModuleMask object, this\nobject will be not be supported.")
sysExtendedRmonNetflowEnable = MibScalar((0, 1, 1, 43), Integer().subtype(subtypeSpec=SingleValueConstraint(2,1,)).subtype(namedValues=NamedValues(("enabled", 1), ("disabled", 2), )).clone(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysExtendedRmonNetflowEnable.setDescription("Indicates whether the Extended RMON Netflow                      feature is enabled or not. Setting this object to\ndisabled(2), will clear\nsysExtendedRmonNetflowPassword automatically.\nSetting this object to enabled(1) will be rejected\nif sysExtendedRmonNetflowPassword does not contain\na valid password.\n\nIf the platform supports\nsysExtendedRmonNetflowModuleMask object, this\nobject will not be supported.")
sysExtendedRmonVlanAgentEnable = MibScalar((0, 1, 1, 44), Integer().subtype(subtypeSpec=SingleValueConstraint(2,1,)).subtype(namedValues=NamedValues(("enabled", 1), ("disabled", 2), )).clone(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysExtendedRmonVlanAgentEnable.setDescription("Indicates whether the Extended RMON VlanAgent                      feature is enabled or not. If it is set to\nenabled(1), the extended RMON will also provide\nthe information on VLAN based interface in\naddition to the port based interface for the\nmonitored traffic.\nSetting this object to enabled(1), it will consume\nmore CPU for processing each monitored frame and\naffect Extended RMON performance.")
sysExtendedRmonEnable = MibScalar((0, 1, 1, 45), Integer().subtype(subtypeSpec=SingleValueConstraint(2,3,1,)).subtype(namedValues=NamedValues(("enabled", 1), ("disabled", 2), ("noNAMPresent", 3), )).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysExtendedRmonEnable.setDescription("Indicates whether the SNMP agent supports the                      extended RMON feature. noNAMPresent(3) is a\nread-only value and the agent will return this\nvalue when the sysEnableExtendedRmon is set to\nenabled(1), but Network Analysis module is not\npresent in the system.")
sysConsolePrimaryLoginAuthentication = MibScalar((0, 1, 1, 46), Integer().subtype(subtypeSpec=SingleValueConstraint(1,3,2,)).subtype(namedValues=NamedValues(("tacacs", 1), ("radius", 2), ("local", 3), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysConsolePrimaryLoginAuthentication.setDescription("Indicates whether TACACS+ or RADIUS is the                      primary login authentication, i.e which method\nwill be tried first for a console session. If\ntacacsLoginAuthentication and\nradiusLoginAuthentication are set to disabled\nthen sysConsolePrimaryLoginAuthentication will\nhave a value of local(3).\n\nThis object is deprecated and replaced by\ncacPriorityTable in CISCO-AAA-CLIENT-MIB.")
sysConsolePrimaryEnableAuthentication = MibScalar((0, 1, 1, 47), Integer().subtype(subtypeSpec=SingleValueConstraint(1,3,2,)).subtype(namedValues=NamedValues(("tacacs", 1), ("radius", 2), ("local", 3), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysConsolePrimaryEnableAuthentication.setDescription("Indicates whether TACACS+ or RADIUS is the                      primary enable authentication, i.e which method\nwill be  tried first for a console session. If\ntacacsEnableAuthentication and\nradiusEnableAuthentication are set to disabled\nthen sysConsolePrimaryEnableAuthentication will\nhave a value of local(3).\n\nThis object is deprecated and replaced by\ncacPriorityTable in CISCO-AAA-CLIENT-MIB.")
sysTelnetPrimaryLoginAuthentication = MibScalar((0, 1, 1, 48), Integer().subtype(subtypeSpec=SingleValueConstraint(1,3,2,)).subtype(namedValues=NamedValues(("tacacs", 1), ("radius", 2), ("local", 3), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysTelnetPrimaryLoginAuthentication.setDescription("Indicates whether TACACS+ or RADIUS is the                      primary login authentication, i.e which method\nwill be  tried first for a telnet session. If\ntacacsLoginAuthentication and\nradiusLoginAuthentication are set to disabled then\nsysTelnetPrimaryLoginAuthentication will have a\nvalue of local(3).\n\nThis object is deprecated and replaced by\ncacPriorityTable in CISCO-AAA-CLIENT-MIB.")
sysTelnetPrimaryEnableAuthentication = MibScalar((0, 1, 1, 49), Integer().subtype(subtypeSpec=SingleValueConstraint(1,3,2,)).subtype(namedValues=NamedValues(("tacacs", 1), ("radius", 2), ("local", 3), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysTelnetPrimaryEnableAuthentication.setDescription("Indicates whether TACACS+ or RADIUS is the                      primary enable authentication, i.e which method\nwill be tried first for a telnet session. If\ntacacsEnableAuthentication and\nradiusEnableAuthentication are set to disabled\nthen sysTelnetPrimaryEnableAuthentication will\nhave a value of local(3).\n\nThis object is deprecated and replaced by\ncacPriorityTable in CISCO-AAA-CLIENT-MIB.")
sysStartupConfigSource = MibScalar((0, 1, 1, 50), Integer().subtype(subtypeSpec=SingleValueConstraint(1,2,)).subtype(namedValues=NamedValues(("flashFileRecurring", 1), ("flashFileNonRecurring", 2), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysStartupConfigSource.setDescription("Indicates whether the configuration file(s)                      specified in sysStartupConfigSourceFile will be\nused recurringly or not whenever the system\nresets.\nSetting this object to flashFileNonRecurring(2),\nthe configuration file(s) specified in\nsysStartupConfigSourceFile will only be used once\nand the value of sysStartupConfigSourceFile will\nbe reset to empty string automatically during the\nnext system reset.\n\nThis MIB object is only supported in systems with\nSupG supervisor models or supervisor models that\nhave flash file system support.")
sysStartupConfigSourceFile = MibScalar((0, 1, 1, 51), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysStartupConfigSourceFile.setDescription("Indicates which configuration file(s) on the                      flash device will be used during the next system\nstartup.\nIf the value of this MIB object contains one or\nmultiple valid configuration file(s), then the\nvalid configuration file(s) will reconfigure the\nsystem during the next system startup one by one\nin the order specified. If the value of this MIB\nobject does not contain the valid configuration\nfile(s) on the device, the NVRAM configuration\nwill be used instead.\n\nFor supervisor models wsx5540 and wsx5550, only\n'cfg1' and 'cfg2' are valid file names.\n\nFor supervisor models with the flash file system\nsupport, the valid file name has the format of\n'<device:><file>[;<device:><file>...]'.\n\nThis MIB object is only supported in systems with\nsupervisor models wsx5540 and wsx5550 or\nsupervisor models with the flash file system\nsupport.")
sysConfigSupervisorModuleNo = MibScalar((0, 1, 1, 52), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 16))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysConfigSupervisorModuleNo.setDescription("Indicates the supervisor module (active or                      standby, if applicable) that the MIB objects\nsysConfigRegister, sysBootVariable,\nsysStartupConfigSource, and\nsysStartupConfigSourceFile are specified for.\n\nThis MIB object is only supported by the\nsupervisor modules with the flash file system\nfeature support. The default value for this MIB\nobject is set to the active supervisor module\nnumber.")
sysStandbyPortEnable = MibScalar((0, 1, 1, 53), Integer().subtype(subtypeSpec=SingleValueConstraint(2,1,)).subtype(namedValues=NamedValues(("enabled", 1), ("disabled", 2), )).clone(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysStandbyPortEnable.setDescription("Indicates whether the standby port feature is                      enabled or not. If this object is set to\nenabled(1), the uplink ports on the standby\nsupervisor module are activated; otherwise, the\nuplink ports on the standby supervisor remain\ninactive.")
sysPortFastBpduGuard = MibScalar((0, 1, 1, 54), Integer().subtype(subtypeSpec=SingleValueConstraint(2,1,)).subtype(namedValues=NamedValues(("enabled", 1), ("disabled", 2), )).clone(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysPortFastBpduGuard.setDescription("Indicates whether BPDU Guard for Spanning Tree                      Port Fast Start feature is enabled or not. If the\nvalue of this object is set to enabled(1), then\nwhen the switch receives a BPDU from a port with\nthe value of portSpantreeFastStart object set to\nenabled(1), that port is immediately disabled.\n\nThis object is deprecated and replaced by\nstpxFastStartBpduGuardEnable in\nCISCO-STP-EXTENSIONS-MIB.")
sysErrDisableTimeoutEnable = MibScalar((0, 1, 1, 55), Bits().subtype(namedValues=NamedValues(("other", 0), ("udld", 1), ("noStaticInlinePwr", 10), ("camMonitor", 11), ("gl2ptCdpThresholdExceed", 12), ("gl2ptStpThresholdExceed", 13), ("gl2ptVtpThresholdExceed", 14), ("linkRxCrc", 15), ("linkTxCrc", 16), ("linkInErrors", 17), ("packetBufferError", 18), ("ethernetOam", 19), ("duplexMismatch", 2), ("gl2ptEoamThresholdExceed", 20), ("bpduPortGuard", 3), ("channelMisconfig", 4), ("crossBarFallBack", 5), ("gl2ptIngressLoop", 6), ("gl2ptThresholdExceed", 7), ("bcastSuppression", 8), ("arpInspectionRate", 9), )).clone(())).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysErrDisableTimeoutEnable.setDescription("Indicates whether errdisable timeout feature is                      enabled for each of the causes or not. The\nother(0) is for all causes other than:\nudld(1),\nduplexMismatch(2),\nbpduPortGuard(3),\nchannelMisconfig(4),\ncrossBarFallBack(5), (only supported on platforms\n                      that support this errdisable\n                      reason.)\ngl2ptIngressLoop(6), (only supported on platforms\n                      that support this errdisable\n                      reason.)\ngl2ptThresholdExceed(7), (only supported on\n                      platforms that support this\n                      errdisable reason.)\nbcastSuppression(8), (only supported on platforms\n                      that support this errdisable\n                      reason.)\narpInspectionRate(9), (only supported on platforms\n                      that support this errdisable\n                      reason.)\nnoStaticInlinePwr(10), (only supported on\n                       platforms that support this\n                       errdisable reason.)\ncamMonitor(11),       (only supported on\n                       platforms that support this\n                       errdisable reason.)\ngl2ptCdpThresholdExceed(12), (only supported on\n                       platforms that support this\n                       errdisable reason.)\ngl2ptStpThresholdExceed(13), (only supported on\n                       platforms that support this\n                       errdisable reason.)\ngl2ptVtpThresholdExceed(14), (only supported on\n                       platforms that support this\n                       errdisable reason.)\nlinkRxCrc(15),        (only supported on\n                       platforms that support this\n                       errdisable reason.)\nlinkTxCrc(16),        (only supported on\n                       platforms that support this\n                       errdisable reason.)\nlinkInErrors(17),     (only supported on\n                       platforms that support this\n                       errdisable reason.)\npacketBufferError(18), (only supported on\n                       platforms that support this\n                       errdisable reason.)\nethernetOam(19),       (only supported on\n                       platforms that support this\n                       errdisable reason.)\ngl2ptEoamThresholdExceed(20), (only supported on\n                       platforms that support this\n                       errdisable reason.)\n\nA port is in errdisable state if ifAdminStatus of\nthe port in the ifTable is up(1) while the port is\nshutdown during runtime by the system due to error\ndetection. If the value of object\nportAdditionalOperStatus for the port is\nerrdisable(11) then that port is in errdisable\nstate.\n\nBy setting the bit corresponding to a cause to\n'1', this errdisable timeout feature is enabled\non the system for the ports that are put into\nerrdisable state by that cause, then those ports\ncan be re-enabled automatically during the timeout\ninterval as specified by\nsysErrDisableTimeoutInterval object after they\nare put into errdisable state by that cause;\notherwise, by setting the bit corresponding to a\ncause to '0', this errdisable timeout feature is\ndisabled on the system for the ports that are put\ninto errdisable state by that cause, then those\nports will remain shutdown until the user\nre-enable it manually.")
sysErrDisableTimeoutInterval = MibScalar((0, 1, 1, 56), Integer32().subtype(subtypeSpec=ValueRangeConstraint(30, 86400)).clone(300)).setMaxAccess("readwrite").setUnits("seconds")
if mibBuilder.loadTexts: sysErrDisableTimeoutInterval.setDescription("Indicates the timeout interval in seconds for                      errdisable timeout feature.")
sysTrafficMonitorHighWaterMark = MibScalar((0, 1, 1, 57), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100)).clone(100)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysTrafficMonitorHighWaterMark.setDescription("Indicates the high watermark for the switching                      bus traffic in percentage. Syslog messages will be\ngenerated if the switching bus traffic goes over\nthis object value during the polling interval.\nSetting this object value to 100 would mean no\nsyslog message would be generated. For systems\nwith 3 switching buses, high watermark and syslog\nwill be for each switching bus.")
sysHighAvailabilityEnable = MibScalar((0, 1, 1, 58), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysHighAvailabilityEnable.setDescription("Indicates whether High System Availability                      feature is enabled or not. If this feature is\nenabled, the active supervisor's layer-2 protocol\nstate will be synched to the standby supervisor\nmodule, thus maintaining an up-to-date protocol\ndata on the standby supervisor whenever possible.\n\nThis object is supported in systems with High\nSystem Availability feature support.")
sysHighAvailabilityVersioningEnable = MibScalar((0, 1, 1, 59), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysHighAvailabilityVersioningEnable.setDescription("Indicates whether support for supervisor software                      image versioning (i.e., the capability to run\ndifferent images on the active and standby\nsupervisors) for the High System Availability\nfeature is enabled or not.\n\nThis object is supported in systems with High\nSystem Availability feature support.")
sysHighAvailabilityOperStatus = MibScalar((0, 1, 1, 60), Integer().subtype(subtypeSpec=SingleValueConstraint(1,2,)).subtype(namedValues=NamedValues(("running", 1), ("notRunning", 2), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysHighAvailabilityOperStatus.setDescription("Indicates the operational status of High System                      Availability feature. If the value of this object\nis notRunning(2), then the reason why this feature\nis actually not running is specified by the object\nsysHighAvailabilityNotRunningReason. If the value\nof this object is running(1), then the value of\nobject sysHighAvailabilityOperReason is empty\nstring.\n\nThis object is supported in systems with High\nSystem Availability feature support.")
sysHighAvailabilityNotRunningReason = MibScalar((0, 1, 1, 61), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysHighAvailabilityNotRunningReason.setDescription("Indicates the reason why High System Availability                      feature is not running when the value of\nsysHighAvailabilityOperStatus is notRunning(2).\n The value of this object is empty string when\nthe value of sysHighAvailabilityOperStatus is\nrunning(1).\n\nThis object is supported in systems with High\nSystem Availability feature support.")
sysExtendedRmonNetflowModuleMask = MibScalar((0, 1, 1, 62), Bits().subtype(namedValues=NamedValues(("module1", 0), ("module2", 1), ("module11", 10), ("module12", 11), ("module13", 12), ("module14", 13), ("module15", 14), ("module16", 15), ("module3", 2), ("module4", 3), ("module5", 4), ("module6", 5), ("module7", 6), ("module8", 7), ("module9", 8), ("module10", 9), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysExtendedRmonNetflowModuleMask.setDescription("Indicates Netflow Export Data (NDE) to be sent to                      which Network Analysis Modules (NAM) in the same\nchassis.\n\nIf users set a bit from off to on, the system will\ncheck the corresponding module is a NAM or not.\nIf it is not, the system should return error.\n\nThis mib object will only be supported by the\nsystem that can support the multiple NAM modules.")
sshPublicKeySize = MibScalar((0, 1, 1, 63), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0,0),ValueRangeConstraint(512,2048),))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sshPublicKeySize.setDescription("Indicates public key size in bits. In write, if                      a key does not exist, a value between 512 and 2048\nwill generate a RSA public key with the value as\nits key size for secured shell access. If a key\nexists a value other than 0 is valid, indicating a\nclear key operation. In read, the current key size\nis returned if a key exists. If not,a 0 is\nreturned.")
sysMaxRmonMemory = MibScalar((0, 1, 1, 64), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysMaxRmonMemory.setDescription("Indicates the maximum percentage of the memory                      usage for RMON.")
sysMacReductionAdminEnable = MibScalar((0, 1, 1, 65), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysMacReductionAdminEnable.setDescription("Indicates whether Mac Reduction feature (to                      reduce the number of MAC addresses used in\nbridge identifier) is administratively enabled\non the device or not.")
sysMacReductionOperEnable = MibScalar((0, 1, 1, 66), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysMacReductionOperEnable.setDescription("Indicates whether Mac Reduction feature (to                      reduce the number of MAC addresses used in\nbridge identifier) is operationaly enabled\non the device or not.\n\nIf the value of this object is true(1), then\nthe accepted values for dot1dStpPriority\nin BRIDGE-MIB should be multiples of 4096 plus\nbridge instance ID, such as VlanIndex. Changing\nthis object value might cause the values of\ndot1dBaseBridgeAddress and dot1dStpPriority\nin BRIDGE-MIB to be changed also.")
sysStatus = MibScalar((0, 1, 1, 67), Integer().subtype(subtypeSpec=SingleValueConstraint(3,1,2,4,)).subtype(namedValues=NamedValues(("other", 1), ("ok", 2), ("minorFault", 3), ("majorFault", 4), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysStatus.setDescription("The operational status of the system.")
chassisGrp = MibIdentifier((0, 1, 2))
chassisSysType = MibScalar((0, 1, 2, 1), Integer().subtype(subtypeSpec=SingleValueConstraint(18,25,40,5,38,19,26,13,45,20,6,9,30,37,52,17,24,14,8,10,4,3,36,31,42,32,51,1,22,23,7,33,11,28,34,41,48,43,15,16,35,27,12,)).subtype(namedValues=NamedValues(("other", 1), ("wsc5505", 10), ("wsc1200", 11), ("wsc1400", 12), ("wsc2926", 13), ("wsc5509", 14), ("wsc6006", 15), ("wsc6009", 16), ("wsc4003", 17), ("wsc5500e", 18), ("wsc4912g", 19), ("wsc2948g", 20), ("wsc6509", 22), ("wsc6506", 23), ("wsc4006", 24), ("wsc6509NEB", 25), ("wsc2980g", 26), ("wsc6513", 27), ("wsc2980ga", 28), ("wsc1000", 3), ("cisco7603", 30), ("cisco7606", 31), ("cisco7609", 32), ("wsc6503", 33), ("wsc6509NEBA", 34), ("wsc4507", 35), ("wsc4503", 36), ("wsc4506", 37), ("wsc65509", 38), ("wsc1001", 4), ("cisco7613", 40), ("wsc2948ggetx", 41), ("cisco7604", 42), ("wsc6504e", 43), ("mec6524gs8s", 45), ("mec6524gt8s", 48), ("wsc1100", 5), ("wsc6509ve", 51), ("cisco7603s", 52), ("wsc5000", 6), ("wsc2900", 7), ("wsc5500", 8), ("wsc5002", 9), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: chassisSysType.setDescription("The chassis system type.")
chassisBkplType = MibScalar((0, 1, 2, 2), Integer().subtype(subtypeSpec=SingleValueConstraint(8,3,1,9,7,4,6,5,2,)).subtype(namedValues=NamedValues(("other", 1), ("fddi", 2), ("fddiEthernet", 3), ("giga", 4), ("giga3", 5), ("giga3E", 6), ("giga12", 7), ("giga16", 8), ("giga40", 9), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: chassisBkplType.setDescription("The chassis backplane type.")
chassisPs1Type = MibScalar((0, 1, 2, 3), Integer().subtype(subtypeSpec=SingleValueConstraint(24,64,13,36,54,28,6,30,50,5,38,18,19,9,106,14,39,26,34,37,8,10,22,7,2,4,35,23,58,12,3,29,42,44,31,55,105,46,25,16,33,32,27,17,43,1,60,59,51,21,63,11,47,20,53,48,52,15,49,)).subtype(namedValues=NamedValues(("other", 1), ("w175", 10), ("pwr6000dc", 105), ("pwr1500dc", 106), ("wsc5068", 11), ("wsc5508", 12), ("wsc5568", 13), ("wsc5508a", 14), ("w155", 15), ("w175pfc", 16), ("w175dc", 17), ("wsc5008b", 18), ("wsc5008c", 19), ("none", 2), ("wsc5068b", 20), ("wscac1000", 21), ("wscac1300", 22), ("wscdc1000", 23), ("wscdc1360", 24), ("wsx4008", 25), ("wsc5518", 26), ("wsc5598", 27), ("w120", 28), ("externalPS", 29), ("w50", 3), ("wscac2500w", 30), ("wscdc2500w", 31), ("wsx4008dc", 32), ("wscac4000w", 33), ("pwr4000dc", 34), ("pwr950ac", 35), ("pwr950dc", 36), ("pwr1900ac", 37), ("pwr1900dc", 38), ("pwr1900ac6", 39), ("w200", 4), ("wsx4008ac650w", 42), ("wsx4008dc650w", 43), ("wscac3000w", 44), ("pwrc451000ac", 46), ("pwrc452800acv", 47), ("pwrc451300acv", 48), ("pwrc451400dcp", 49), ("w600", 5), ("wscdc3000w", 50), ("pwr1400ac", 51), ("w156", 52), ("wscac6000w", 53), ("pwr2700ac", 54), ("pwr2700dc", 55), ("wscac8700we", 58), ("pwr2700ac4", 59), ("w80", 6), ("pwr2700dc4", 60), ("pwr400dc", 63), ("pwr400ac", 64), ("w130", 7), ("wsc5008", 8), ("wsc5008a", 9), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: chassisPs1Type.setDescription("Type of power supply number 1.")
chassisPs1Status = MibScalar((0, 1, 2, 4), Integer().subtype(subtypeSpec=SingleValueConstraint(3,1,2,4,)).subtype(namedValues=NamedValues(("other", 1), ("ok", 2), ("minorFault", 3), ("majorFault", 4), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: chassisPs1Status.setDescription("Status of power supply number 1. If the status is                      not ok, the value of chassisPs1TestResult gives\nmore detailed information about the power supply's\nfailure condition(s).")
chassisPs1TestResult = MibScalar((0, 1, 2, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: chassisPs1TestResult.setDescription("Test result for power supply number 1. A zero                      indicates that the supply passed all tests. Bits\nset in the result indicate error conditions.")
chassisPs2Type = MibScalar((0, 1, 2, 6), Integer().subtype(subtypeSpec=SingleValueConstraint(24,64,13,36,54,28,6,30,50,5,38,18,19,9,106,14,39,26,34,37,8,10,22,7,2,4,35,23,58,12,3,29,42,44,31,55,105,46,25,16,33,32,27,17,43,1,60,59,51,21,63,11,47,20,53,48,52,15,49,)).subtype(namedValues=NamedValues(("other", 1), ("w175", 10), ("pwr6000dc", 105), ("pwr1500dc", 106), ("wsc5068", 11), ("wsc5508", 12), ("wsc5568", 13), ("wsc5508a", 14), ("w155", 15), ("w175pfc", 16), ("w175dc", 17), ("wsc5008b", 18), ("wsc5008c", 19), ("none", 2), ("wsc5068b", 20), ("wscac1000", 21), ("wscac1300", 22), ("wscdc1000", 23), ("wscdc1360", 24), ("wsx4008", 25), ("wsc5518", 26), ("wsc5598", 27), ("w120", 28), ("externalPS", 29), ("w50", 3), ("wscac2500w", 30), ("wscdc2500w", 31), ("wsx4008dc", 32), ("wscac4000w", 33), ("pwr4000dc", 34), ("pwr950ac", 35), ("pwr950dc", 36), ("pwr1900ac", 37), ("pwr1900dc", 38), ("pwr1900ac6", 39), ("w200", 4), ("wsx4008ac650w", 42), ("wsx4008dc650w", 43), ("wscac3000w", 44), ("pwrc451000ac", 46), ("pwrc452800acv", 47), ("pwrc451300acv", 48), ("pwrc451400dcp", 49), ("w600", 5), ("wscdc3000w", 50), ("pwr1400ac", 51), ("w156", 52), ("wscac6000w", 53), ("pwr2700ac", 54), ("pwr2700dc", 55), ("wscac8700we", 58), ("pwr2700ac4", 59), ("w80", 6), ("pwr2700dc4", 60), ("pwr400dc", 63), ("pwr400ac", 64), ("w130", 7), ("wsc5008", 8), ("wsc5008a", 9), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: chassisPs2Type.setDescription("Type of power supply number 2.")
chassisPs2Status = MibScalar((0, 1, 2, 7), Integer().subtype(subtypeSpec=SingleValueConstraint(3,1,2,4,)).subtype(namedValues=NamedValues(("other", 1), ("ok", 2), ("minorFault", 3), ("majorFault", 4), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: chassisPs2Status.setDescription("Status of power supply number 2. If the status is                      not ok, the value of chassisPs2TestResult gives\nmore detailed information about the power supply's\nfailure condition(s).")
chassisPs2TestResult = MibScalar((0, 1, 2, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: chassisPs2TestResult.setDescription("Test result for power supply number 2. A zero                      indicates that the supply passed all tests. Bits\nset in the result indicate error conditions.")
chassisFanStatus = MibScalar((0, 1, 2, 9), Integer().subtype(subtypeSpec=SingleValueConstraint(3,1,2,4,)).subtype(namedValues=NamedValues(("other", 1), ("ok", 2), ("minorFault", 3), ("majorFault", 4), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: chassisFanStatus.setDescription("Status of the chassis fan. If the status is not                      ok, the value of chassisFanTestResult gives more\ndetailed information about the fan's failure\ncondition(s).")
chassisFanTestResult = MibScalar((0, 1, 2, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: chassisFanTestResult.setDescription("Test result for the chassis fan. A zero indicates                      that the fan passed all tests. Bits set in the\nresult indicate error conditions.")
chassisMinorAlarm = MibScalar((0, 1, 2, 11), Integer().subtype(subtypeSpec=SingleValueConstraint(2,1,)).subtype(namedValues=NamedValues(("off", 1), ("on", 2), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: chassisMinorAlarm.setDescription("The chassis minor alarm status.")
chassisMajorAlarm = MibScalar((0, 1, 2, 12), Integer().subtype(subtypeSpec=SingleValueConstraint(2,1,)).subtype(namedValues=NamedValues(("off", 1), ("on", 2), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: chassisMajorAlarm.setDescription("The chassis major alarm status.")
chassisTempAlarm = MibScalar((0, 1, 2, 13), Integer().subtype(subtypeSpec=SingleValueConstraint(2,3,1,)).subtype(namedValues=NamedValues(("off", 1), ("on", 2), ("critical", 3), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: chassisTempAlarm.setDescription("The chassis temperature alarm status.")
chassisNumSlots = MibScalar((0, 1, 2, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 16))).setMaxAccess("readonly")
if mibBuilder.loadTexts: chassisNumSlots.setDescription("The number of slots in the chassis available for                      plug-in modules.")
chassisSlotConfig = MibScalar((0, 1, 2, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: chassisSlotConfig.setDescription("An indication of which slots in the chassis have                      modules inserted. This is an integer value with\nbits set to indicate configured modules. It can be\ninterpreted as a sum of f(x) as x goes from 1 to\nthe number of slots, where f(x) = 0 for no module\ninserted and f(x) = exp(2, x-1) for a module\ninserted.")
chassisModel = MibScalar((0, 1, 2, 16), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 20))).setMaxAccess("readonly")
if mibBuilder.loadTexts: chassisModel.setDescription("The manufacturer's model number for the chassis.")
chassisSerialNumber = MibScalar((0, 1, 2, 17), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 999999999))).setMaxAccess("readonly")
if mibBuilder.loadTexts: chassisSerialNumber.setDescription("The serial number of the chassis in a numeric                      format. If the chassis uses an alphanumeric\nserial number, this MIB object will return 0.\n\nThis object is deprecated and replaced by\nentPhysicalSerialNum in ENTITY-MIB.")
chassisComponentTable = MibTable((0, 1, 2, 18))
if mibBuilder.loadTexts: chassisComponentTable.setDescription("A list of the chassis related components in the                      chassis.\n\nThis table is deprecated and replaced by\nentPhysicalTable in ENTITY-MIB.")
chassisComponentEntry = MibTableRow((0, 1, 2, 18, 1)).setIndexNames((0, "CISCO-STACK-MIB", "chassisComponentIndex"))
if mibBuilder.loadTexts: chassisComponentEntry.setDescription("Entry containing information about one component                      in the chassis.")
chassisComponentIndex = MibTableColumn((0, 1, 2, 18, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: chassisComponentIndex.setDescription("A unique value for each chassis related component                      within the chassis.")
chassisComponentType = MibTableColumn((0, 1, 2, 18, 1, 2), Integer().subtype(subtypeSpec=SingleValueConstraint(5,11,18,1,13,2,7,14,15,17,16,4,20,21,3,6,19,8,10,)).subtype(namedValues=NamedValues(("unknown", 1), ("wsc6506eFan", 10), ("wsc6509eFan", 11), ("wsc6503eFan", 13), ("wsc6000vtte", 14), ("fanMod4Hs", 15), ("fan6524", 16), ("fanMod6Shs", 17), ("fanMod9Shs", 18), ("fanMod9St", 19), ("wsc6000cl", 2), ("wsc6509veFan", 20), ("fanMod3Hs", 21), ("wsc6000vtt", 3), ("wsc6000tempSensor", 4), ("wsc6513Clock", 5), ("clk7600", 6), ("ws9SlotFan", 7), ("fanMod9", 8), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: chassisComponentType.setDescription("The type of the chassis component.")
chassisComponentSerialNumber = MibTableColumn((0, 1, 2, 18, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 20))).setMaxAccess("readonly")
if mibBuilder.loadTexts: chassisComponentSerialNumber.setDescription("The serial number of the chassis component.")
chassisComponentHwVersion = MibTableColumn((0, 1, 2, 18, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 20))).setMaxAccess("readonly")
if mibBuilder.loadTexts: chassisComponentHwVersion.setDescription("The hardware version of the chassis component.")
chassisComponentModel = MibTableColumn((0, 1, 2, 18, 1, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 20))).setMaxAccess("readonly")
if mibBuilder.loadTexts: chassisComponentModel.setDescription("The manufacturer's model number for the chassis                      component.")
chassisSerialNumberString = MibScalar((0, 1, 2, 19), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 20))).setMaxAccess("readonly")
if mibBuilder.loadTexts: chassisSerialNumberString.setDescription("The serial number of the chassis. This MIB object                      will return the chassis serial number for any\nchassis that either a numeric or an alphanumeric\nserial number is being used.")
chassisPs3Type = MibScalar((0, 1, 2, 20), Integer().subtype(subtypeSpec=SingleValueConstraint(25,2,32,42,43,1,)).subtype(namedValues=NamedValues(("other", 1), ("none", 2), ("wsx4008", 25), ("wsx4008dc", 32), ("wsx4008ac650w", 42), ("wsx4008dc650w", 43), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: chassisPs3Type.setDescription("Type of power supply number 3. This object is                      only supported by systems that can have 3 or more\npower supplies.")
chassisPs3Status = MibScalar((0, 1, 2, 21), Integer().subtype(subtypeSpec=SingleValueConstraint(3,1,2,4,)).subtype(namedValues=NamedValues(("other", 1), ("ok", 2), ("minorFault", 3), ("majorFault", 4), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: chassisPs3Status.setDescription("Status of power supply number 3. If the status is                      not ok, the value of chassisPs3TestResult gives\nmore detailed information about the power supply's\nfailure condition(s). This object is only\nsupported by systems that can have 3 or more\npower supplies.")
chassisPs3TestResult = MibScalar((0, 1, 2, 22), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: chassisPs3TestResult.setDescription("Test result for power supply number 3. A zero                      indicates that the supply passed all tests. Bits\nset in the result indicate error conditions. This\nobject is only supported by systems that can\nhave 3 or more power supplies.")
chassisPEMInstalled = MibScalar((0, 1, 2, 23), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chassisPEMInstalled.setDescription("Indicates whether Power Entry Module is installed                      into the Chassis or not. Power Entry Module is a\nconnection into the system for an external\npower supply of -48 Volts. This object is only\nsupported by systems that can have 3 or more power\nsupplies.")
moduleGrp = MibIdentifier((0, 1, 3))
moduleTable = MibTable((0, 1, 3, 1))
if mibBuilder.loadTexts: moduleTable.setDescription("A list of module entries. The number of entries                      is the number of modules in the chassis.")
moduleEntry = MibTableRow((0, 1, 3, 1, 1)).setIndexNames((0, "CISCO-STACK-MIB", "moduleIndex"))
if mibBuilder.loadTexts: moduleEntry.setDescription("Entry containing information about one module in                      the chassis.")
moduleIndex = MibTableColumn((0, 1, 3, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 16))).setMaxAccess("readonly")
if mibBuilder.loadTexts: moduleIndex.setDescription("A unique value for each module within the                       chassis.")
moduleType = MibTableColumn((0, 1, 3, 1, 1, 2), Integer().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(303,320,1103,37,1105,282,280,209,608,219,317,203,294,73,20,321,244,88,342,213,598,502,229,924,296,293,57,92,332,91,83,319,235,311,305,511,611,312,79,96,77,25,26,24,50,76,75,603,34,33,32,43,44,225,928,204,236,74,18,17,925,15,617,49,48,248,54,247,85,52,286,231,206,78,1002,253,23,38,39,306,597,271,330,224,201,602,13,940,14,222,919,202,930,323,46,208,68,929,509,226,614,334,87,230,249,210,292,11,605,258,278,1004,289,284,600,300,318,254,261,255,325,218,21,22,217,19,606,), SingleValueConstraint(65,82,66,61,62,1007,326,503,510,84,242,913,207,273,30,29,28,307,912,923,1800,339,281,240,5,936,1001,1101,324,220,322,604,237,309,1023,920,290,304,245,1805,216,285,926,910,2,47,927,35,27,239,291,274,343,1010,613,506,615,346,234,1102,921,223,260,41,42,345,40,275,259,507,211,69,341,609,45,610,512,214,279,331,1009,4,3,599,268,53,607,276,516,246,1104,81,337,1801,251,911,915,250,914,301,1,1027,1008,270,36,16,601,302,616,67,200,310,295,241,243,313,12,252,272,221,1016,266,277,267,1033,238,515,), SingleValueConstraint(269,233,1106,297,212,1021,340,612,903,265,55,56,))).subtype(namedValues=NamedValues(("other", 1), ("wssup720", 1001), ("wssup720base", 1002), ("m7600Sip600", 1004), ("wsx6748getx", 1007), ("wsx670410ge", 1008), ("wsx6748sfp", 1009), ("wsx6724sfp", 1010), ("wsx670810ge", 1016), ("vss72010g", 1021), ("wsx6708a10ge", 1023), ("wsx671610ge", 1027), ("wsx671610t", 1033), ("wsc1200", 11), ("wsx65822pa", 1101), ("m7600Sip200", 1102), ("m7600Sip400", 1103), ("c7600ssc400", 1104), ("c7600ssc600", 1105), ("esm2x10ge", 1106), ("wsc1400", 12), ("wsx1441", 13), ("wsx1444", 14), ("wsx1450", 15), ("wsx1483", 16), ("wsx1454", 17), ("wsx1455", 18), ("rsp720", 1800), ("rsp720base", 1801), ("c7600msfc4", 1805), ("wsx1431", 19), ("empty", 2), ("wsx1465", 20), ("wsx6ksup12ge", 200), ("wsx6408gbic", 201), ("wsx6224mmmt", 202), ("wsx6248rj45", 203), ("wsx6248tel", 204), ("wsx6302msm", 206), ("wsf6kmsfc", 207), ("wsx6024flmt", 208), ("wsx6101oc12mmf", 209), ("wsx1436", 21), ("wsx6101oc12smf", 210), ("wsx6416gemt", 211), ("wsx61822pa", 212), ("osm2oc12AtmMM", 213), ("osm2oc12AtmSI", 214), ("osm4oc12PosMM", 216), ("osm4oc12PosSI", 217), ("osm4oc12PosSL", 218), ("wsx6ksup1a2ge", 219), ("wsx1434", 22), ("wsx6302amsm", 220), ("wsx6416gbic", 221), ("wsx6224ammmt", 222), ("wsx6380nam", 223), ("wsx6248arj45", 224), ("wsx6248atel", 225), ("wsx6408agbic", 226), ("wsx6608t1", 229), ("wsx5009", 23), ("wsx6608e1", 230), ("wsx6624fxs", 231), ("wsx6316getx", 233), ("wsf6kmsfc2", 234), ("wsx6324mmmt", 235), ("wsx6348rj45", 236), ("wsx6ksup22ge", 237), ("wsx6324sm", 238), ("wsx6516gbic", 239), ("wsx5013", 24), ("osm4geWanGbic", 240), ("osm1oc48PosSS", 241), ("osm1oc48PosSI", 242), ("osm1oc48PosSL", 243), ("wsx6381ids", 244), ("wsc6500sfm", 245), ("osm16oc3PosMM", 246), ("osm16oc3PosSI", 247), ("osm16oc3PosSL", 248), ("osm2oc12PosMM", 249), ("wsx5011", 25), ("osm2oc12PosSI", 250), ("osm2oc12PosSL", 251), ("wsx650210ge", 252), ("osm8oc3PosMM", 253), ("osm8oc3PosSI", 254), ("osm8oc3PosSL", 255), ("wsx6548rj45", 258), ("wsx6524mmmt", 259), ("wsx5010", 26), ("wsx6066SlbApc", 260), ("wsx6516getx", 261), ("osm2oc48OneDptSS", 265), ("osm2oc48OneDptSI", 266), ("osm2oc48OneDptSL", 267), ("osm2oc48OneDptSSDual", 268), ("osm2oc48OneDptSIDual", 269), ("wsx5113", 27), ("osm2oc48OneDptSLDual", 270), ("wsx6816gbic", 271), ("osm4choc12T3MM", 272), ("osm4choc12T3SI", 273), ("osm8choc12T3MM", 274), ("osm8choc12T3SI", 275), ("osm1choc48T3SS", 276), ("osm2choc48T3SS", 277), ("wsx6500sfm2", 278), ("osm1choc48T3SI", 279), ("wsx5101", 28), ("osm2choc48T3SI", 280), ("wsx6348rj21", 281), ("wsx6548rj21", 282), ("wsSvcCmm", 284), ("wsx650110gex4", 285), ("osm4oc3PosSI", 286), ("osm4oc3PosMM", 289), ("wsx5103", 29), ("wsSvcIdsm2", 290), ("wsSvcNam2", 291), ("wsSvcFwm1", 292), ("wsSvcCe1", 293), ("wsSvcSsl1", 294), ("osm8choc3DS0SI", 295), ("osm4choc3DS0SI", 296), ("osm1choc12T1SI", 297), ) + NamedValues(("wsc1000", 3), ("wsx5104", 30), ("wsx4012", 300), ("wsx4148rj", 301), ("wsx4232gbrj", 302), ("wsx4306gb", 303), ("wsx4418gb", 304), ("wsx44162gbtx", 305), ("wsx4912gb", 306), ("wsx2948gbrj", 307), ("wsx2948", 309), ("wsx4912", 310), ("wsx4424sxmt", 311), ("wsx4232rjxx", 312), ("wsx4148rj21", 313), ("wsx4124fxmt", 317), ("wsx4013", 318), ("wsx4232l3", 319), ("wsx5155", 32), ("wsx4604gwy", 320), ("wsx44122Gbtx", 321), ("wsx2980", 322), ("wsx2980rj", 323), ("wsx2980gbrj", 324), ("wsx4019", 325), ("wsx4148rj45v", 326), ("wsx5154", 33), ("wsx4424gbrj45", 330), ("wsx4148fxmt", 331), ("wsx4448gblx", 332), ("wsx4448gbrj45", 334), ("wsx4148lxmt", 337), ("wsx4548gbrj45", 339), ("wsx5153", 34), ("wsx4548gbrj45v", 340), ("wsx4248rj21v", 341), ("wsx4302gb", 342), ("wsx4248rj45v", 343), ("wsx2948ggetx", 345), ("wsx2948ggetxgbrj", 346), ("wsx5111", 35), ("wsx5213", 36), ("wsx5020", 37), ("wsx5006", 38), ("wsx5005", 39), ("wsc1001", 4), ("wsx5509", 40), ("wsx5506", 41), ("wsx5505", 42), ("wsx5156", 43), ("wsx5157", 44), ("wsx5158", 45), ("wsx5030", 46), ("wsx5114", 47), ("wsx5223", 48), ("wsx5224", 49), ("wsc1100", 5), ("wsx5012", 50), ("wsx6516aGbic", 502), ("wsx6148getx", 503), ("wsx6148x2rj45", 506), ("wsx6196rj21", 507), ("wssup32ge3b", 509), ("wssup3210ge3b", 510), ("mec6524gs8s", 511), ("mec6524gt8s", 512), ("wssup32pge", 515), ("wssup32p10ge", 516), ("wsx5302", 52), ("wsx5213a", 53), ("wsx5380", 54), ("wsx5201", 55), ("wsx5203", 56), ("wsx5530", 57), ("wssvcpisa32", 597), ("me6524msfc2a", 598), ("wsf6kmsfc2a", 599), ("osm12ct3T1", 600), ("osm12t3e3", 601), ("osm24t3e3", 602), ("osm4GeWanGbicPlus", 603), ("osm1choc12T3SI", 604), ("osm2choc12T3SI", 605), ("osm2oc12AtmMMPlus", 606), ("osm2oc12AtmSIPlus", 607), ("osm2oc12PosMMPlus", 608), ("osm2oc12PosSIPlus", 609), ("wsx5161", 61), ("osm16oc3PosSIPlus", 610), ("osm1oc48PosSSPlus", 611), ("osm1oc48PosSIPlus", 612), ("osm1oc48PosSLPlus", 613), ("osm4oc3PosSIPlus", 614), ("osm8oc3PosSLPlus", 615), ("osm8oc3PosSIPlus", 616), ("osm4oc12PosSIPlus", 617), ("wsx5162", 62), ("wsx5165", 65), ("wsx5166", 66), ("wsx5031", 67), ("wsx5410", 68), ("wsx5403", 69), ("wsx5201r", 73), ("wsx5225r", 74), ("wsx5014", 75), ("wsx5015", 76), ("wsx5236", 77), ("wsx5540", 78), ("wsx5234", 79), ("wsx5012a", 81), ("wsx5167", 82), ("wsx5239", 83), ("wsx5168", 84), ("wsx5305", 85), ("wsx5550", 87), ("wsf5541", 88), ("wsSvcIpSec1", 903), ("wsx5534", 91), ("wsSvcMwam1", 910), ("wsSvcCsg1", 911), ("wsx6148rj45v", 912), ("wsx6148rj21v", 913), ("wsSvcNam1", 914), ("wsx6548getx", 915), ("wsSvcPsd1", 919), ("wsx5536", 92), ("wsx6066SlbSk9", 920), ) + NamedValues(("wsx6148agetx", 921), ("wsx6148arj45", 923), ("wsSvcWlan1k9", 924), ("wsSvcAon1k9", 925), ("ace106500k9", 926), ("wsSvcWebVpnk9", 927), ("wsx6148FeSfp", 928), ("wsSvcAdm1k9", 929), ("wsSvcAgm1k9", 930), ("ace046500k9", 936), ("wsSvcSamiBb", 940), ("wsx5237", 96), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: moduleType.setDescription("The type of module.")
moduleSerialNumber = MibTableColumn((0, 1, 3, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 999999999))).setMaxAccess("readonly")
if mibBuilder.loadTexts: moduleSerialNumber.setDescription("The serial number of the module in a numeric                      format. If the module uses an alphanumeric serial\nnumber, this MIB object will return 0.\n\nThis object is deprecated and replaced by\nentPhysicalSerialNum in ENTITY-MIB.")
moduleHwHiVersion = MibTableColumn((0, 1, 3, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: moduleHwHiVersion.setDescription("The high part of the hardware version of the                      module.\nFor example, if the hardware version is 3.1, the\nvalue of moduleHwHiVersion is 3.\n\nThis object is deprecated and replaced by\nentPhysicalHardwareRev in ENTITY-MIB.")
moduleHwLoVersion = MibTableColumn((0, 1, 3, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: moduleHwLoVersion.setDescription("The low part of the hardware version of the                      module.\nFor example, if the hardware version is 3.1, the\nvalue of moduleHwLoVersion is 1.\n\nThis object is deprecated and replaced by\nentPhysicalHardwareRev in ENTITY-MIB.")
moduleFwHiVersion = MibTableColumn((0, 1, 3, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: moduleFwHiVersion.setDescription("The high part of the firmware version number. For                      example, if the firmware version is 3.1, the value\nof moduleFwHiVersion is 3.\n\nThis object is deprecated and replaced by\nentPhysicalFirmwareRev in ENTITY-MIB.")
moduleFwLoVersion = MibTableColumn((0, 1, 3, 1, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: moduleFwLoVersion.setDescription("The low part of the firmware version number. For                      example, if the firmware version is 3.1, the value\nof moduleFwLoVersion is 1.\n\nThis object is deprecated and replaced by\nentPhysicalFirmwareRev in ENTITY-MIB.")
moduleSwHiVersion = MibTableColumn((0, 1, 3, 1, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: moduleSwHiVersion.setDescription("The high part of the software version number. For                      example, if the software version is 3.1, the value\nof moduleSwHiVersion is 3.\n\nThis object is deprecated and replaced by\nentPhysicalSoftwareRev in ENTITY-MIB.")
moduleSwLoVersion = MibTableColumn((0, 1, 3, 1, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: moduleSwLoVersion.setDescription("The low part of the software version number. For                      example, if the software version is 3.1, the value\nof moduleSwLoVersion is 1.\n\nThis object is deprecated and replaced by\nentPhysicalSoftwareRev in ENTITY-MIB.")
moduleStatus = MibTableColumn((0, 1, 3, 1, 1, 10), Integer().subtype(subtypeSpec=SingleValueConstraint(3,1,2,4,)).subtype(namedValues=NamedValues(("other", 1), ("ok", 2), ("minorFault", 3), ("majorFault", 4), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: moduleStatus.setDescription("The operational status of the module. If the                      status is not ok, the value of moduleTestResult\ngives more detailed information about the\nmodule's failure condition(s).")
moduleTestResult = MibTableColumn((0, 1, 3, 1, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: moduleTestResult.setDescription("The result of the module's self test. A zero                      indicates that the module passed all tests. Bits\nset in the result indicate error conditions.")
moduleAction = MibTableColumn((0, 1, 3, 1, 1, 12), Integer().subtype(subtypeSpec=SingleValueConstraint(2,3,1,4,)).subtype(namedValues=NamedValues(("other", 1), ("reset", 2), ("enable", 3), ("disable", 4), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: moduleAction.setDescription("This object, when read, returns one of the                      following results:\nother(1):   module permanently enabled\nenable(3):  module currently enabled\ndisable(4): module currently disabled\nSetting this object to one of the acceptable\nvalues gives the following results:\nother(1):  gives an error\nreset(2):  resets the module's control logic\nenable(3): if the module status is configurable,\n          enables the module, else gives error\ndisable(4): if the module status is\n         configurable, disables the module,\n         else gives error.\nSetting this object to any other values results in\nan error.")
moduleName = MibTableColumn((0, 1, 3, 1, 1, 13), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 20))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: moduleName.setDescription("A descriptive string used by the network                      administrator to name the module.")
moduleNumPorts = MibTableColumn((0, 1, 3, 1, 1, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: moduleNumPorts.setDescription("The number of ports supported by the module.")
modulePortStatus = MibTableColumn((0, 1, 3, 1, 1, 15), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: modulePortStatus.setDescription("A series of bytes containing status information                      about the module and each of the ports on the\nmodule.\nThe first byte contains the status for the module\n(same value as moduleStatus), and subsequent bytes\ncontain status for the first through the last\nports on the module (same value as\nportOperStatus).")
moduleSubType = MibTableColumn((0, 1, 3, 1, 1, 16), Integer().subtype(subtypeSpec=SingleValueConstraint(205,228,226,227,107,207,103,221,224,101,200,230,3,4,202,102,100,206,208,201,106,104,216,9,8,7,6,1,105,223,213,218,217,203,225,2,)).subtype(namedValues=NamedValues(("other", 1), ("wsf6020", 100), ("wsf6020a", 101), ("wsf6kpfc", 102), ("wsf6kpfc2", 103), ("wsf6kvpwr", 104), ("wsf6kdfc", 105), ("wsf6kpfc2a", 106), ("wsf6kdfca", 107), ("empty", 2), ("vsp300dfc", 200), ("wsf6kpfc3a", 201), ("wsf6kdfc3a", 202), ("wsf6700dfc3a", 203), ("wsf6kdfc3bxl", 205), ("wsf6kpfc3bxl", 206), ("wsf6700dfc3bxl", 207), ("wsf6700cfc", 208), ("m7600pfc3c", 213), ("wsf6kpfc3b", 216), ("wsf6700dfc3b", 217), ("wsf6700dfc3c", 218), ("wsf6700dfc3cxl", 221), ("wsf6kdfc3b", 223), ("mec6524pfc3c", 224), ("sip600earl", 225), ("vsf6kpfc3cxl", 226), ("vsf6kpfc3c", 227), ("c7600esmdfc3cxl", 228), ("c7600esmdfc3c", 230), ("wsf5510", 3), ("wsf5511", 4), ("wsx5304", 6), ("wsf5520", 7), ("wsf5521", 8), ("wsf5531", 9), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: moduleSubType.setDescription("The type of daughterboard attached to this                      module.")
moduleModel = MibTableColumn((0, 1, 3, 1, 1, 17), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 20))).setMaxAccess("readonly")
if mibBuilder.loadTexts: moduleModel.setDescription("The manufacturer's model number for the module.")
moduleHwVersion = MibTableColumn((0, 1, 3, 1, 1, 18), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 12))).setMaxAccess("readonly")
if mibBuilder.loadTexts: moduleHwVersion.setDescription("The hardware version of the module.")
moduleFwVersion = MibTableColumn((0, 1, 3, 1, 1, 19), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 40))).setMaxAccess("readonly")
if mibBuilder.loadTexts: moduleFwVersion.setDescription("The firmware version of the module.")
moduleSwVersion = MibTableColumn((0, 1, 3, 1, 1, 20), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 40))).setMaxAccess("readonly")
if mibBuilder.loadTexts: moduleSwVersion.setDescription("The software version of the module.")
moduleStandbyStatus = MibTableColumn((0, 1, 3, 1, 1, 21), Integer().subtype(subtypeSpec=SingleValueConstraint(2,3,1,4,)).subtype(namedValues=NamedValues(("other", 1), ("active", 2), ("standby", 3), ("error", 4), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: moduleStandbyStatus.setDescription("Redundant status of a module that supports                      redundancy.")
moduleIPAddress = MibTableColumn((0, 1, 3, 1, 1, 22), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: moduleIPAddress.setDescription("If the module has a separate IP address to                       reach it by, then it is reported here.\nOtherwise, this object has a value of\n'00000000H'.")
moduleIPAddressVlan = MibTableColumn((0, 1, 3, 1, 1, 23), VlanIndex()).setMaxAccess("readonly")
if mibBuilder.loadTexts: moduleIPAddressVlan.setDescription("If the moduleIPAddress is valid then this                      object reports the VLAN to access that IP\naddress on. Otherwise this object has a value\nof zero.")
moduleSubType2 = MibTableColumn((0, 1, 3, 1, 1, 24), Integer().subtype(subtypeSpec=SingleValueConstraint(5,207,3,9,8,7,106,11,10,597,402,403,314,599,598,1001,406,107,234,109,108,404,6,405,102,103,1,1805,1701,315,104,105,2,1026,)).subtype(namedValues=NamedValues(("other", 1), ("wsu5538", 10), ("wssup720", 1001), ("wsg6488", 102), ("vsf6kmsfc3", 1026), ("wsg6489", 103), ("wsg6483", 104), ("wsg6485", 105), ("wsf6kFe48af", 106), ("wsf6kGe48af", 107), ("wsf6kVpwrGe", 108), ("wsf6kFe48x2af", 109), ("wsu5539", 11), ("esm2x10ge", 1701), ("c7600msfc4", 1805), ("empty", 2), ("wsf6kmsfc", 207), ("wsf6kmsfc2", 234), ("wsu5531", 3), ("wsu4504fxmt", 314), ("wsu4502gb", 315), ("wssvcidsupg", 402), ("wssvccmm6e1", 403), ("wssvccmm6t1", 404), ("wssvccmm24fxs", 405), ("wssvccmmact", 406), ("wsu5533", 5), ("wssvcpisa32", 597), ("me6524msfc2a", 598), ("wsf6kmsfc2a", 599), ("wsu5534", 6), ("wsu5535", 7), ("wsu5536", 8), ("wsu5537", 9), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: moduleSubType2.setDescription("The type of daughterboard attached to this                      module.")
moduleSlotNum = MibTableColumn((0, 1, 3, 1, 1, 25), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 16))).setMaxAccess("readonly")
if mibBuilder.loadTexts: moduleSlotNum.setDescription("This value is determined by the chassis slot                      number where the module is located. Valid entries\nare 1 to the value of chassisNumSlots")
moduleSerialNumberString = MibTableColumn((0, 1, 3, 1, 1, 26), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 20))).setMaxAccess("readonly")
if mibBuilder.loadTexts: moduleSerialNumberString.setDescription("The serial number of the module. This MIB object                       will return the module serial number for any\nmodule that either a numeric or an alphanumeric\nserial number is being used.")
moduleEntPhysicalIndex = MibTableColumn((0, 1, 3, 1, 1, 27), PhysicalIndex()).setMaxAccess("readonly")
if mibBuilder.loadTexts: moduleEntPhysicalIndex.setDescription("The value of the instance of the entPhysicalIndex                      object, defined in ENTITY-MIB, for the entity\nphysical index corresponding to this module.")
moduleAdditionalStatus = MibTableColumn((0, 1, 3, 1, 1, 28), Bits().subtype(namedValues=NamedValues(("fruInstalled", 0), ("powerDenied", 1), ("faulty", 2), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: moduleAdditionalStatus.setDescription("The additional status of the module.\nfruInstalled(0) indicates that whether or not\nFRU is installed on the module.\n\npowerDenied(1) indicates that whether phones\nconnected to the ports of this module are\ndenied of power.\n\nfaulty(2) indicates hardware faulty.")
portGrp = MibIdentifier((0, 1, 4))
portTable = MibTable((0, 1, 4, 1))
if mibBuilder.loadTexts: portTable.setDescription("A list of port entries. The number of entries is                      determined by the number of modules in the chassis\nand the number of ports on each module.")
portEntry = MibTableRow((0, 1, 4, 1, 1)).setIndexNames((0, "CISCO-STACK-MIB", "portModuleIndex"), (0, "CISCO-STACK-MIB", "portIndex"))
if mibBuilder.loadTexts: portEntry.setDescription("Entry containing information for a particular                      port on a module.")
portModuleIndex = MibTableColumn((0, 1, 4, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 16))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portModuleIndex.setDescription("An index value that uniquely identifies the                      module where this port is located.")
portIndex = MibTableColumn((0, 1, 4, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portIndex.setDescription("An index value that uniquely identifies this port                      within a module. The value is determined by the\nlocation of the port on the module. Valid entries\nare 1 to the value of moduleNumPorts for this\nmodule.")
portCrossIndex = MibTableColumn((0, 1, 4, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4080))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portCrossIndex.setDescription("A cross-reference to the port's index within                      another mib group. The value is dependent on the\ntype of port. For an FDDI port, this corresponds\nto the snmpFddiPORTIndex.")
portName = MibTableColumn((0, 1, 4, 1, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 20))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portName.setDescription("A descriptive string used by the network                      administrator to name the port.")
portType = MibTableColumn((0, 1, 4, 1, 1, 5), Integer().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(29,10,55,1062,17,1010,62,13,1080,1057,57,90,1022,1001,73,16,1077,72,1033,1064,1060,37,97,28,93,1016,41,76,1046,1078,46,42,1050,78,6,1076,81,52,1067,64,1008,89,1021,14,59,74,34,92,1006,70,18,21,111,1053,1018,38,4,100,69,30,1069,1035,53,1065,102,77,1070,88,1000,1044,33,44,45,54,1028,24,110,1038,84,8,82,51,1025,1079,50,1081,1042,1004,1040,35,1068,1002,49,56,63,1071,1073,105,1074,1034,1075,1058,36,1037,1027,79,1012,1009,1032,1056,91,43,1055,1014,25,1030,1061,27,32,60,86,1019,96,75,1015,66,2,), SingleValueConstraint(80,1041,1045,7,1026,85,1020,20,1052,68,1049,1017,1023,61,1003,1047,11,47,48,9,23,1048,1011,1007,109,1005,67,1024,1036,26,1043,1051,12,87,1066,1054,71,99,95,1031,1063,106,104,19,103,5,101,31,1059,39,40,1,1029,15,1013,83,1072,22,3,94,1039,98,65,))).subtype(namedValues=NamedValues(("other", 1), ("scf", 10), ("lwa", 100), ("e1000BaseUnknown", 1000), ("e10GBaseUnknown", 1001), ("e10GBaseUnapproved", 1002), ("e1000BaseWdmRxOnly", 1003), ("e1000BaseDwdm3033", 1004), ("e1000BaseDwdm3112", 1005), ("e1000BaseDwdm3190", 1006), ("e1000BaseDwdm3268", 1007), ("e1000BaseDwdm3425", 1008), ("e1000BaseDwdm3504", 1009), ("aons", 101), ("e1000BaseDwdm3582", 1010), ("e1000BaseDwdm3661", 1011), ("e1000BaseDwdm3819", 1012), ("e1000BaseDwdm3898", 1013), ("e1000BaseDwdm3977", 1014), ("e1000BaseDwdm4056", 1015), ("e1000BaseDwdm4214", 1016), ("e1000BaseDwdm4294", 1017), ("e1000BaseDwdm4373", 1018), ("e1000BaseDwdm4453", 1019), ("sslVpn", 102), ("e1000BaseDwdm4612", 1020), ("e1000BaseDwdm4692", 1021), ("e1000BaseDwdm4772", 1022), ("e1000BaseDwdm4851", 1023), ("e1000BaseDwdm5012", 1024), ("e1000BaseDwdm5092", 1025), ("e1000BaseDwdm5172", 1026), ("e1000BaseDwdm5252", 1027), ("e1000BaseDwdm5413", 1028), ("e1000BaseDwdm5494", 1029), ("e100BaseEmpty", 103), ("e1000BaseDwdm5575", 1030), ("e1000BaseDwdm5655", 1031), ("e1000BaseDwdm5817", 1032), ("e1000BaseDwdm5898", 1033), ("e1000BaseDwdm5979", 1034), ("e1000BaseDwdm6061", 1035), ("e10GBaseWdmRxOnly", 1036), ("e10GBaseDwdm3033", 1037), ("e10GBaseDwdm3112", 1038), ("e10GBaseDwdm3190", 1039), ("adsm", 104), ("e10GBaseDwdm3268", 1040), ("e10GBaseDwdm3425", 1041), ("e10GBaseDwdm3504", 1042), ("e10GBaseDwdm3582", 1043), ("e10GBaseDwdm3661", 1044), ("e10GBaseDwdm3819", 1045), ("e10GBaseDwdm3898", 1046), ("e10GBaseDwdm3977", 1047), ("e10GBaseDwdm4056", 1048), ("e10GBaseDwdm4214", 1049), ("agsm", 105), ("e10GBaseDwdm4294", 1050), ("e10GBaseDwdm4373", 1051), ("e10GBaseDwdm4453", 1052), ("e10GBaseDwdm4612", 1053), ("e10GBaseDwdm4692", 1054), ("e10GBaseDwdm4772", 1055), ("e10GBaseDwdm4851", 1056), ("e10GBaseDwdm5012", 1057), ("e10GBaseDwdm5092", 1058), ("e10GBaseDwdm5172", 1059), ("aces", 106), ("e10GBaseDwdm5252", 1060), ("e10GBaseDwdm5413", 1061), ("e10GBaseDwdm5494", 1062), ("e10GBaseDwdm5575", 1063), ("e10GBaseDwdm5655", 1064), ("e10GBaseDwdm5817", 1065), ("e10GBaseDwdm5898", 1066), ("e10GBaseDwdm5979", 1067), ("e10GBaseDwdm6061", 1068), ("e1000BaseBX10D", 1069), ("e1000BaseBX10U", 1070), ("e100BaseUnknown", 1071), ("e100BaseUnapproved", 1072), ("e100BaseSX", 1073), ("e100BaseBX10D", 1074), ("e100BaseBX10U", 1075), ("e10GBaseBad", 1076), ("e10GBaseZR", 1077), ("e100BaseEX", 1078), ("e100BaseZX", 1079), ("e10GBaseLRM", 1080), ("e10GBaseT", 1081), ("intrusionProtect", 109), ("e100BaseTX", 11), ("e1000BaseSvc", 110), ("e10GBaseSvc", 111), ("e100BaseT4", 12), ("e100BaseF", 13), ("atmOc3mmf", 14), ("atmOc3smf", 15), ("atmOc3utp", 16), ("e100BaseFsm", 17), ("e10a100BaseTX", 18), ("mii", 19), ("cddi", 2), ("vlanRouter", 20), ("remoteRouter", 21), ("tokenring", 22), ("atmOc12mmf", 23), ("atmOc12smf", 24), ("atmDs3", 25), ("tokenringMmf", 26), ("e1000BaseLX", 27), ("e1000BaseSX", 28), ("e1000BaseCX", 29), ("fddi", 3), ("networkAnalysis", 30), ("e1000Empty", 31), ("e1000BaseLH", 32), ("e1000BaseT", 33), ("e1000UnsupportedGbic", 34), ("e1000BaseZX", 35), ("depi2", 36), ("t1", 37), ("e1", 38), ("fxs", 39), ("tppmd", 4), ("fxo", 40), ) + NamedValues(("transcoding", 41), ("conferencing", 42), ("atmOc12mm", 43), ("atmOc12smi", 44), ("atmOc12sml", 45), ("posOc12mm", 46), ("posOc12smi", 47), ("posOc12sml", 48), ("posOc48sms", 49), ("mlt3", 5), ("posOc48smi", 50), ("posOc48sml", 51), ("posOc3mm", 52), ("posOc3smi", 53), ("posOc3sml", 54), ("intrusionDetect", 55), ("e10GBaseCPX", 56), ("e10GBaseLX4", 57), ("e10GBaseEX4", 59), ("sddi", 6), ("e10GEmpty", 60), ("e10a100a1000BaseT", 61), ("dptOc48mm", 62), ("dptOc48smi", 63), ("dptOc48sml", 64), ("e10GBaseLR", 65), ("chOc12smi", 66), ("chOc12mm", 67), ("chOc48ss", 68), ("chOc48smi", 69), ("smf", 7), ("e10GBaseSX4", 70), ("e10GBaseER", 71), ("contentEngine", 72), ("ssl", 73), ("firewall", 74), ("vpnIpSec", 75), ("ct3", 76), ("e1000BaseCwdm1470", 77), ("e1000BaseCwdm1490", 78), ("e1000BaseCwdm1510", 79), ("e10BaseT", 8), ("e1000BaseCwdm1530", 80), ("e1000BaseCwdm1550", 81), ("e1000BaseCwdm1570", 82), ("e1000BaseCwdm1590", 83), ("e1000BaseCwdm1610", 84), ("e1000BaseBT", 85), ("e1000BaseUnapproved", 86), ("chOc3smi", 87), ("mcr", 88), ("coe", 89), ("e10BaseF", 9), ("mwa", 90), ("psd", 91), ("e100BaseLX", 92), ("e10GBaseSR", 93), ("e10GBaseCX4", 94), ("e10GBaseWdm1550", 95), ("e10GBaseEdc1310", 96), ("e10GBaseSW", 97), ("e10GBaseLW", 98), ("e10GBaseEW", 99), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portType.setDescription("The type of physical layer medium dependent                      interface on the port.")
portOperStatus = MibTableColumn((0, 1, 4, 1, 1, 6), Integer().subtype(subtypeSpec=SingleValueConstraint(3,1,2,4,)).subtype(namedValues=NamedValues(("other", 1), ("ok", 2), ("minorFault", 3), ("majorFault", 4), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portOperStatus.setDescription("The current operational status of the port.")
portCrossGroupIndex = MibTableColumn((0, 1, 4, 1, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 16))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portCrossGroupIndex.setDescription("A cross-reference to another mib group for this                      port. The value is dependent on the type of port.\nFor an FDDI port this corresponds to the\nsnmpFddiPORTSMTIndex.")
portAdditionalStatus = MibTableColumn((0, 1, 4, 1, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portAdditionalStatus.setDescription("Additional status information for the port. The                      value is a sum. It initially takes the value zero,\nthen for each state that is true, 2 raised to a\npower is added to the sum. The powers are\naccording to the following table:\n         State    Power\n      Transmit    0\n       Receive    1\n     Collision    2\nTransmit state indicates that at least one packet\nwas transmitted by the port in the last polling\nperiod. Receive state indicates that at least one\npacket was received by the port in the last\npolling period. Collision state indicates that\nat least one collision was detected on the port\nin the last polling period.\nNote that if a state is not applicable to a\nparticular port or additional status is not\nsupported on a particular port, its value is\nalways false for that port.")
portAdminSpeed = MibTableColumn((0, 1, 4, 1, 1, 9), Integer().subtype(subtypeSpec=SingleValueConstraint(10000000,100000000,2000000,155000000,1,1544000,4000000,622000000,45000000,2048000,1000000000,16000000,64000,2,64000000,10,400000000,)).subtype(namedValues=NamedValues(("autoDetect", 1), ("s10G", 10), ("s10000000", 10000000), ("s100000000", 100000000), ("s1000000000", 1000000000), ("s1544000", 1544000), ("s155000000", 155000000), ("s16000000", 16000000), ("autoDetect10100", 2), ("s2000000", 2000000), ("s2048000", 2048000), ("s4000000", 4000000), ("s400000000", 400000000), ("s45000000", 45000000), ("s622000000", 622000000), ("s64000", 64000), ("s64000000", 64000000), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portAdminSpeed.setDescription("The desired speed of the port.                      The current operational speed of the port can be\ndetermined from ifSpeed.")
portDuplex = MibTableColumn((0, 1, 4, 1, 1, 10), Integer().subtype(subtypeSpec=SingleValueConstraint(4,1,3,2,)).subtype(namedValues=NamedValues(("half", 1), ("full", 2), ("disagree", 3), ("auto", 4), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portDuplex.setDescription("Indicates whether the port is operating in half-                      duplex, full-duplex, disagree or auto negotiation\nmode. If the port could not agree with the far end\non port duplex, the port will be in disagree(3)\nmode.")
portIfIndex = MibTableColumn((0, 1, 4, 1, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portIfIndex.setDescription("The value of the instance of the ifIndex object,                      defined in MIB-II, for the interface corresponding\nto this port.")
portSpantreeFastStart = MibTableColumn((0, 1, 4, 1, 1, 12), Integer().subtype(subtypeSpec=SingleValueConstraint(2,1,)).subtype(namedValues=NamedValues(("enabled", 1), ("disabled", 2), )).clone(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portSpantreeFastStart.setDescription("Indicates whether the port is operating in                      spantree fast start mode. A port with fast start\nenabled is immediately put in spanning tree\nforwarding state on link up, rather than starting\nin blocking state which is the normal operation.\nThis is useful when the port is known to be\nconnected to a single station which has problems\nwaiting for the normal spanning tree operation to\nput the port in forwarding state.\n\nThis object is deprecated and replaced by\nstpxFastStartPortTable in\nCISCO-STP-EXTENSIONS-MIB.")
portAdminRxFlowControl = MibTableColumn((0, 1, 4, 1, 1, 13), Integer().subtype(subtypeSpec=SingleValueConstraint(1,3,2,)).subtype(namedValues=NamedValues(("on", 1), ("off", 2), ("desired", 3), )).clone(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portAdminRxFlowControl.setDescription("Indicates the receive flow control administrative                      status set on the port. If the status is set to\non(1), the port will require the far end to send\nflow control. If the status is set to off(2), the\nport will not allow far end to send flow control.\nIf the status is set to desired(3), the port will\nallow the far end to send the flow control.")
portOperRxFlowControl = MibTableColumn((0, 1, 4, 1, 1, 14), Integer().subtype(subtypeSpec=SingleValueConstraint(1,2,3,)).subtype(namedValues=NamedValues(("on", 1), ("off", 2), ("disagree", 3), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portOperRxFlowControl.setDescription("Indicates the receive flow control operational                      status of the port. If the port could not agree\nwith the far end on a link protocol, its\noperational status will be disagree(3).")
portAdminTxFlowControl = MibTableColumn((0, 1, 4, 1, 1, 15), Integer().subtype(subtypeSpec=SingleValueConstraint(1,3,2,)).subtype(namedValues=NamedValues(("on", 1), ("off", 2), ("desired", 3), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portAdminTxFlowControl.setDescription("Indicates the transmit flow control                      administrative status set on the port.\nIf the status is set to on(1), the port will send\nflow control to the far end.\nIf the status is set to off(2), the port will not\nsend flow control to the far end. If the status is\nset to desired(3), the port will send flow control\nto the far end if the far end supports it.")
portOperTxFlowControl = MibTableColumn((0, 1, 4, 1, 1, 16), Integer().subtype(subtypeSpec=SingleValueConstraint(1,2,3,)).subtype(namedValues=NamedValues(("on", 1), ("off", 2), ("disagree", 3), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portOperTxFlowControl.setDescription("Indicates the transmit flow control operational                      status of the port. If the port could not agree\nwith the far end on a link protocol, its\noperational status will be disagree(3).")
portMacControlTransmitFrames = MibTableColumn((0, 1, 4, 1, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portMacControlTransmitFrames.setDescription("The total number of MAC control frames passed to                      the MAC sublayer for transmission.")
portMacControlReceiveFrames = MibTableColumn((0, 1, 4, 1, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portMacControlReceiveFrames.setDescription("The total number of MAC control frames passed by                      the MAC sublayer to the MAC Control sublayer on\nreceive.")
portMacControlPauseTransmitFrames = MibTableColumn((0, 1, 4, 1, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portMacControlPauseTransmitFrames.setDescription("The total number of PAUSE frames passed to                      the MAC sublayer for transmission.")
portMacControlPauseReceiveFrames = MibTableColumn((0, 1, 4, 1, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portMacControlPauseReceiveFrames.setDescription("The total number of PAUSE frames passed by                      the MAC sublayer to the MAC Control sublayer\non receive.")
portMacControlUnknownProtocolFrames = MibTableColumn((0, 1, 4, 1, 1, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portMacControlUnknownProtocolFrames.setDescription("The total number of MAC Control frames received                      with an opcode that is not supported by the\ndevice.")
portLinkFaultStatus = MibTableColumn((0, 1, 4, 1, 1, 22), Integer().subtype(subtypeSpec=SingleValueConstraint(7,1,5,3,4,6,2,)).subtype(namedValues=NamedValues(("noFault", 1), ("nearEndFault", 2), ("nearEndConfigFail", 3), ("farEndDisable", 4), ("farEndFault", 5), ("farEndConfigFail", 6), ("notApplicable", 7), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portLinkFaultStatus.setDescription("Specifies additional link fault status on a                      gigabit link.\n\nnoFault:\n        Link is up and operational.\nnearEndFault:\n        The port is enabled but there is no GBIC\n        present or the local port cannot\n        synchronize with the remote end.\nnearEndConfigFail:\n        The local port has detected a\n        configuration mismatch with the remote\n        end.\nfarEndDisable:\n        The far end is in the disabled state.\nfarEndFault:\n        The remote port is cannot synchronize.\nfarEndConfigFail:\n        The remote port has detected a\n        configuration mismatch with the local end.\nnotApplicable:\n        Link fault status is not applicable on\n        this port.")
portAdditionalOperStatus = MibTableColumn((0, 1, 4, 1, 1, 23), Bits().subtype(namedValues=NamedValues(("other", 0), ("connected", 1), ("errdisable", 10), ("linkFaulty", 11), ("onHook", 12), ("offHook", 13), ("reflector", 14), ("standby", 2), ("faulty", 3), ("notConnected", 4), ("inactive", 5), ("shutdown", 6), ("dripDis", 7), ("disabled", 8), ("monitor", 9), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portAdditionalOperStatus.setDescription("The current operational status of the port which                      is showing additional detailed information of the\nport.")
portInlinePowerDetect = MibTableColumn((0, 1, 4, 1, 1, 24), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portInlinePowerDetect.setDescription("Indicate if the port detects an inline power capable\ndevice connected to it.")
portEntPhysicalIndex = MibTableColumn((0, 1, 4, 1, 1, 25), PhysicalIndex()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portEntPhysicalIndex.setDescription("The value of the instance of the entPhysicalIndex                      object, defined in ENTITY-MIB, for the\nentity physical index corresponding to this port.")
portErrDisableTimeOutEnable = MibTableColumn((0, 1, 4, 1, 1, 26), Integer().subtype(subtypeSpec=SingleValueConstraint(2,1,)).subtype(namedValues=NamedValues(("enabled", 1), ("disabled", 2), )).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portErrDisableTimeOutEnable.setDescription("Indicates whether a port that is put into                      errdisable state by a cause as specified by\nsysErrDisableTimeoutEnable will be re-enabled\nautomatically during the timeout interval as\nspecified by sysErrDisableTimeoutInterval.")
tftpGrp = MibIdentifier((0, 1, 5))
tftpHost = MibScalar((0, 1, 5, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 64))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tftpHost.setDescription("Name of source/destination host for the TFTP                      transfer or storage device transfer. If the name\nis for the TFTP transfer, it can be the IP\naddress or the host name. If the name for the\nstorage device transfer, it will be in the format\nof deviceName: (e.g. slot0:, slot1:).")
tftpFile = MibScalar((0, 1, 5, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 64))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tftpFile.setDescription("Name of file for the TFTP transfer or for storage                       device transfer.")
tftpModule = MibScalar((0, 1, 5, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 16))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tftpModule.setDescription("Which module's code/configuration is being                      transferred.")
tftpAction = MibScalar((0, 1, 5, 4), Integer().subtype(subtypeSpec=SingleValueConstraint(1,2,4,7,5,3,6,)).subtype(namedValues=NamedValues(("other", 1), ("downloadConfig", 2), ("uploadConfig", 3), ("downloadSw", 4), ("uploadSw", 5), ("downloadFw", 6), ("uploadFw", 7), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tftpAction.setDescription("Setting this object to one of the acceptable                      values initiates the requested action using the\ninformation given in tftpHost, tftpFile,\ntftpModule.\n\n    downloadConfig(2): receive configuration from\n                       host/file\n    uploadConfig(3)  : send configuration to\n                       host/file\n    downloadSw(4)    : receive software image from\n                       host/file\n    uploadSw(5)      : send software image to\n                       host/file\n    downloadFw(6)    : receive firmware image from\n                       host/file\n    uploadFw(7)      : send firmware image to\n                       host/file\nSetting this object to any other value results in\nan error.")
tftpResult = MibScalar((0, 1, 5, 5), Integer().subtype(subtypeSpec=SingleValueConstraint(17,4,10,18,11,8,20,7,14,21,16,5,9,6,12,3,19,2,15,1,13,)).subtype(namedValues=NamedValues(("inProgress", 1), ("serverError", 10), ("userCanceled", 11), ("wrongCode", 12), ("fileNotFound", 13), ("invalidTftpHost", 14), ("invalidTftpModule", 15), ("accessViolation", 16), ("unknownStatus", 17), ("invalidStorageDevice", 18), ("insufficientSpaceOnStorageDevice", 19), ("success", 2), ("insufficientDramSize", 20), ("incompatibleImage", 21), ("noResponse", 3), ("tooManyRetries", 4), ("noBuffers", 5), ("noProcesses", 6), ("badChecksum", 7), ("badLength", 8), ("badFlash", 9), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tftpResult.setDescription("Contains result of the last tftp action request.")
brouterGrp = MibIdentifier((0, 1, 6))
brouterEnableRip = MibScalar((0, 1, 6, 1), Integer().subtype(subtypeSpec=SingleValueConstraint(2,1,)).subtype(namedValues=NamedValues(("enabled", 1), ("disabled", 2), )).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: brouterEnableRip.setDescription("Indicates whether the RIP protocol is enabled.")
brouterEnableSpantree = MibScalar((0, 1, 6, 2), Integer().subtype(subtypeSpec=SingleValueConstraint(2,1,)).subtype(namedValues=NamedValues(("enabled", 1), ("disabled", 2), )).clone(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: brouterEnableSpantree.setDescription("Indicates if Spanning Tree protocol is enabled.")
brouterEnableGiantCheck = MibScalar((0, 1, 6, 3), Integer().subtype(subtypeSpec=SingleValueConstraint(2,1,)).subtype(namedValues=NamedValues(("enabled", 1), ("disabled", 2), )).clone(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: brouterEnableGiantCheck.setDescription("Indicates whether special handling of giant                      packets is enabled.")
brouterEnableIpFragmentation = MibScalar((0, 1, 6, 4), Integer().subtype(subtypeSpec=SingleValueConstraint(2,1,)).subtype(namedValues=NamedValues(("enabled", 1), ("disabled", 2), )).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: brouterEnableIpFragmentation.setDescription("Indicates whether IP fragmentation is enabled.")
brouterEnableUnreachables = MibScalar((0, 1, 6, 5), Integer().subtype(subtypeSpec=SingleValueConstraint(2,1,)).subtype(namedValues=NamedValues(("enabled", 1), ("disabled", 2), )).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: brouterEnableUnreachables.setDescription("Indicates whether ICMP unreachable messages are                      sent by the system.")
brouterCamAgingTime = MibScalar((0, 1, 6, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1000000)).clone(300)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: brouterCamAgingTime.setDescription("The aging time for the CAM table. This duplicate                      item is the same value as dot1dTpAgingTime.")
brouterCamMode = MibScalar((0, 1, 6, 7), Integer().subtype(subtypeSpec=SingleValueConstraint(2,1,)).subtype(namedValues=NamedValues(("filtering", 1), ("forwarding", 2), )).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: brouterCamMode.setDescription("Mode in which the CAM module is operating.")
brouterIpxSnapToEther = MibScalar((0, 1, 6, 8), Integer().subtype(subtypeSpec=SingleValueConstraint(1,3,4,2,)).subtype(namedValues=NamedValues(("snap", 1), ("ethernetII", 2), ("iso8023", 3), ("raw8023", 4), )).clone(4)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: brouterIpxSnapToEther.setDescription("The default translation for IPX packets when                      bridging from FDDI SNAP to Ethernet.")
brouterIpx8023RawToFddi = MibScalar((0, 1, 6, 9), Integer().subtype(subtypeSpec=SingleValueConstraint(1,5,6,)).subtype(namedValues=NamedValues(("snap", 1), ("iso8022", 5), ("fddiRaw", 6), )).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: brouterIpx8023RawToFddi.setDescription("The default translation for IPX packets when                      bridging from Ethernet 802.3 Raw to FDDI.")
brouterEthernetReceiveMax = MibScalar((0, 1, 6, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 100)).clone(64)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: brouterEthernetReceiveMax.setDescription("Maximum number of Ethernet receive buffers                      processed at one time per port.")
brouterEthernetTransmitMax = MibScalar((0, 1, 6, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 100)).clone(64)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: brouterEthernetTransmitMax.setDescription("Maximum number of Ethernet transmit buffers                      processed at one time per port.")
brouterFddiReceiveMax = MibScalar((0, 1, 6, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 512)).clone(256)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: brouterFddiReceiveMax.setDescription("Maximum number of FDDI receive buffers processed                      at one time per port.")
brouterFddiTransmitMax = MibScalar((0, 1, 6, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 512)).clone(256)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: brouterFddiTransmitMax.setDescription("Maximum number of FDDI transmit buffers processed                      at one time per port.")
brouterPortTable = MibTable((0, 1, 6, 14))
if mibBuilder.loadTexts: brouterPortTable.setDescription("A list of brouter port entries. The number of                      entries is determined by the number of modules in\nthe chassis and the number of ports on each\nmodule.")
brouterPortEntry = MibTableRow((0, 1, 6, 14, 1)).setIndexNames((0, "CISCO-STACK-MIB", "brouterPortModule"), (0, "CISCO-STACK-MIB", "brouterPort"))
if mibBuilder.loadTexts: brouterPortEntry.setDescription("Entry containing bridge/router information for a                      particular port on a module.")
brouterPortModule = MibTableColumn((0, 1, 6, 14, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 16))).setMaxAccess("readonly")
if mibBuilder.loadTexts: brouterPortModule.setDescription("An index value that uniquely identifies the                      module index where this port is located.")
brouterPort = MibTableColumn((0, 1, 6, 14, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: brouterPort.setDescription("An index value that uniquely identifies this port                      within a module (see portIndex).")
brouterPortIpVlan = MibTableColumn((0, 1, 6, 14, 1, 3), VlanIndex()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: brouterPortIpVlan.setDescription("The IP Virtual LAN to which this port belongs.")
brouterPortIpAddr = MibTableColumn((0, 1, 6, 14, 1, 4), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: brouterPortIpAddr.setDescription("This port's IP address.")
brouterPortNetMask = MibTableColumn((0, 1, 6, 14, 1, 5), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: brouterPortNetMask.setDescription("This port's subnet mask.")
brouterPortBroadcast = MibTableColumn((0, 1, 6, 14, 1, 6), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: brouterPortBroadcast.setDescription("This port's broadcast address.")
brouterPortBridgeVlan = MibTableColumn((0, 1, 6, 14, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1023))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: brouterPortBridgeVlan.setDescription("The bridge Virtual LAN to which this port                      belongs.")
brouterPortIpHelpers = MibTableColumn((0, 1, 6, 14, 1, 8), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: brouterPortIpHelpers.setDescription("An indication of which other Virtual LANs UDP/IP                      broadcasts received on this port will be forwarded\nto. The normal situation is broadcasts NOT\nforwarded beyond the originating VLAN, but it can\nbe useful in certain circumstances. This is an\noctet string value with bits set to indicate\nforwarded to VLANs. It can be interpreted as a sum\nof f(x) as x goes from 0 to 1023, where f(x) = 0\nfor no forwarding to VLAN x and f(x) = exp(2, x)\nfor VLAN x forwarded to. If all bits are 0 or the\noctet string is zero length, then UDP/IP\nbroadcasts are not being forwarded to other\nVLANs.")
brouterIpx8022ToEther = MibScalar((0, 1, 6, 15), Integer().subtype(subtypeSpec=SingleValueConstraint(1,3,4,2,)).subtype(namedValues=NamedValues(("snap", 1), ("ethernetII", 2), ("iso8023", 3), ("raw8023", 4), )).clone(3)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: brouterIpx8022ToEther.setDescription("The default translation for IPX packets when                      bridging from FDDI 802.2 to Ethernet.")
brouterEnableTransitEncapsulation = MibScalar((0, 1, 6, 16), Integer().subtype(subtypeSpec=SingleValueConstraint(2,1,)).subtype(namedValues=NamedValues(("enabled", 1), ("disabled", 2), )).clone(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: brouterEnableTransitEncapsulation.setDescription("Indicates whether Ethernet packets are                      encapsulated on FDDI via transit encapsulation\nprotocol. Normally this option would be disabled\nto allow translational bridging between Ethernet\nand FDDI to take place.")
brouterEnableFddiCheck = MibScalar((0, 1, 6, 17), Integer().subtype(subtypeSpec=SingleValueConstraint(2,1,)).subtype(namedValues=NamedValues(("enabled", 1), ("disabled", 2), )).clone(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: brouterEnableFddiCheck.setDescription("Indicates whether MAC addresses learned one side                      of a translational bridge should not be allowed to\nbe learned on the other side of the bridge. The\npresence certain misbehaving devices on the\nnetwork may require this option to be enabled.")
brouterEnableAPaRT = MibScalar((0, 1, 6, 18), Integer().subtype(subtypeSpec=SingleValueConstraint(2,1,)).subtype(namedValues=NamedValues(("enabled", 1), ("disabled", 2), )).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: brouterEnableAPaRT.setDescription("Indicates whether the Automatic Packet                      Recognition and Translation feature is enabled on\ntranslational bridge(s) in the box. If APaRT is\ndisabled, the default translations as defined by\nthe objects brouterIpx8022ToEther,\nbrouterIpx8023RawToFddi, brouterIpxSnapToEther,\netc, are used on all packets and no automatic\nlearning of translation information is performed.")
filterGrp = MibIdentifier((0, 1, 7))
filterMacTable = MibTable((0, 1, 7, 1))
if mibBuilder.loadTexts: filterMacTable.setDescription("A list of filter mac entries.")
filterMacEntry = MibTableRow((0, 1, 7, 1, 1)).setIndexNames((0, "CISCO-STACK-MIB", "filterMacModule"), (0, "CISCO-STACK-MIB", "filterMacPort"), (0, "CISCO-STACK-MIB", "filterMacAddress"))
if mibBuilder.loadTexts: filterMacEntry.setDescription("Entry containing MAC address filter information.")
filterMacModule = MibTableColumn((0, 1, 7, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 16))).setMaxAccess("readonly")
if mibBuilder.loadTexts: filterMacModule.setDescription("An index value that uniquely identifies the                      module where this port is located\n(see portModuleIndex).")
filterMacPort = MibTableColumn((0, 1, 7, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: filterMacPort.setDescription("An index value that uniquely identifies this port                      within a module (see portIndex).")
filterMacAddress = MibTableColumn((0, 1, 7, 1, 1, 3), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: filterMacAddress.setDescription("A MAC address. If the source or destination MAC                      address equals this value, a match occurs. The\npacket is dropped if a match occurs and deny(1)\nwas specified. The packet is dropped if a match\ndoesn't occur and at least one MAC address filter\nwas specified with permit(3).")
filterMacType = MibTableColumn((0, 1, 7, 1, 1, 4), Integer().subtype(subtypeSpec=SingleValueConstraint(7,1,8,6,3,4,2,5,)).subtype(namedValues=NamedValues(("deny", 1), ("invalid", 2), ("permit", 3), ("permitSrc", 4), ("permitDst", 5), ("denySrc", 6), ("denyDst", 7), ("denySrcLearn", 8), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: filterMacType.setDescription("Setting this object to invalid(2) removes the                      corresponding entry from the filterMacTable.\nTo add a new entry to the filterMacTable, set this\nobject to deny(1) or any value from permit(3) to\ndenySrcLearn(8) for a module, port, and MAC\naddress not already in the table.")
filterVendorTable = MibTable((0, 1, 7, 2))
if mibBuilder.loadTexts: filterVendorTable.setDescription("A list of filter vendor ID entries.")
filterVendorEntry = MibTableRow((0, 1, 7, 2, 1)).setIndexNames((0, "CISCO-STACK-MIB", "filterVendorModule"), (0, "CISCO-STACK-MIB", "filterVendorPort"), (0, "CISCO-STACK-MIB", "filterVendorId"))
if mibBuilder.loadTexts: filterVendorEntry.setDescription("Entry containing vendor ID filter information.")
filterVendorModule = MibTableColumn((0, 1, 7, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 16))).setMaxAccess("readonly")
if mibBuilder.loadTexts: filterVendorModule.setDescription("An index value that uniquely identifies the                      module where this port is located\n(see portModuleIndex).")
filterVendorPort = MibTableColumn((0, 1, 7, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: filterVendorPort.setDescription("An index value that uniquely identifies this port                      within a module (see portIndex).")
filterVendorId = MibTableColumn((0, 1, 7, 2, 1, 3), VendorIdType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: filterVendorId.setDescription("The vendor ID portion of a MAC address. If the                      source or destination MAC address has the same\nvendor ID, a match occurs. The packet is dropped\nif a match occurs and deny(1) was specified. The\npacket is dropped if a match doesn't occur and at\nleast one Vendor ID filter was specified with\npermit(3).")
filterVendorType = MibTableColumn((0, 1, 7, 2, 1, 4), Integer().subtype(subtypeSpec=SingleValueConstraint(1,3,2,)).subtype(namedValues=NamedValues(("deny", 1), ("invalid", 2), ("permit", 3), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: filterVendorType.setDescription("Setting this object to invalid(2) removes the                      corresponding entry from the filterVendorTable.\nTo add a new entry to the filterVendorTable, set\nthis object to deny(1) or permit(3) for a module,\nport, and vendor ID not already in the table.")
filterProtocolTable = MibTable((0, 1, 7, 3))
if mibBuilder.loadTexts: filterProtocolTable.setDescription("A list of filter protocol entries.")
filterProtocolEntry = MibTableRow((0, 1, 7, 3, 1)).setIndexNames((0, "CISCO-STACK-MIB", "filterProtocolModule"), (0, "CISCO-STACK-MIB", "filterProtocolPort"), (0, "CISCO-STACK-MIB", "filterProtocolValue"))
if mibBuilder.loadTexts: filterProtocolEntry.setDescription("Entry containing PROTOCOL address filter                      information.")
filterProtocolModule = MibTableColumn((0, 1, 7, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 16))).setMaxAccess("readonly")
if mibBuilder.loadTexts: filterProtocolModule.setDescription("An index value that uniquely identifies the                      module where this port is located\n(see portModuleIndex).")
filterProtocolPort = MibTableColumn((0, 1, 7, 3, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: filterProtocolPort.setDescription("An index value that uniquely identifies this port                      within a module (see portIndex).")
filterProtocolValue = MibTableColumn((0, 1, 7, 3, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: filterProtocolValue.setDescription("A 16-bit protocol value. If the packet's type                      field or the packet's DSAP/SSAP field is equal to\nthis value, a match occurs. The packet is dropped\nif a match occurs and deny(1) was specified. The\npacket is dropped if a match doesn't occur and at\nleast one protocol type filter was specified with\npermit(3).")
filterProtocolType = MibTableColumn((0, 1, 7, 3, 1, 4), Integer().subtype(subtypeSpec=SingleValueConstraint(1,3,2,)).subtype(namedValues=NamedValues(("deny", 1), ("invalid", 2), ("permit", 3), ))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: filterProtocolType.setDescription("Setting this object to invalid(2) removes the                      corresponding entry from the filterProtocolTable.\nTo add a new entry to the filterProtocolTable, set\nthis object to deny(1) or permit(3) for a module,\nport, and protocol value not already in the\ntable.")
filterTestTable = MibTable((0, 1, 7, 4))
if mibBuilder.loadTexts: filterTestTable.setDescription("A list of filter test entries.")
filterTestEntry = MibTableRow((0, 1, 7, 4, 1)).setIndexNames((0, "CISCO-STACK-MIB", "filterTestModule"), (0, "CISCO-STACK-MIB", "filterTestPort"), (0, "CISCO-STACK-MIB", "filterTestIndex"))
if mibBuilder.loadTexts: filterTestEntry.setDescription("Entry containing test filter information.")
filterTestModule = MibTableColumn((0, 1, 7, 4, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 16))).setMaxAccess("readonly")
if mibBuilder.loadTexts: filterTestModule.setDescription("An index value that uniquely identifies the                      module where this port is located\n(see portModuleIndex).")
filterTestPort = MibTableColumn((0, 1, 7, 4, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: filterTestPort.setDescription("An index value that uniquely identifies this port                      within a module (see portIndex).")
filterTestIndex = MibTableColumn((0, 1, 7, 4, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: filterTestIndex.setDescription("An index value that uniquely identifies a test                       for a particular module/port.")
filterTestType = MibTableColumn((0, 1, 7, 4, 1, 4), Integer().subtype(subtypeSpec=SingleValueConstraint(1,2,)).subtype(namedValues=NamedValues(("valid", 1), ("invalid", 2), ))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: filterTestType.setDescription("Setting this object to invalid(2) removes the                      corresponding entry from the filterTestTable. To\nadd a new entry to the filterTestTable, set this\nobject to valid(1) for a module, port, and test\nindex not already in the table.")
filterTestOffset = MibTableColumn((0, 1, 7, 4, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4500))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: filterTestOffset.setDescription("A byte offset into packet. Must be a 32-bit word                      aligned offset, i.e. 0, 4, 8, etc.")
filterTestValue = MibTableColumn((0, 1, 7, 4, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: filterTestValue.setDescription("A 32-bit value to be compared against the packet                      location specified by filterTestOffset.")
filterTestMask = MibTableColumn((0, 1, 7, 4, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: filterTestMask.setDescription("A 32-bit value to be bitwise ANDed with the                      packet location specified by filterTestOffset\nbefore  being compared to filterTestValue.")
filterPortTable = MibTable((0, 1, 7, 5))
if mibBuilder.loadTexts: filterPortTable.setDescription("A list of filter port entries. The number of                      entries is determined by the number of modules in\nthe chassis and the number of ports on each\nmodule.")
filterPortEntry = MibTableRow((0, 1, 7, 5, 1)).setIndexNames((0, "CISCO-STACK-MIB", "filterPortModule"), (0, "CISCO-STACK-MIB", "filterPort"))
if mibBuilder.loadTexts: filterPortEntry.setDescription("Entry containing filter information for a                      particular port on a module.")
filterPortModule = MibTableColumn((0, 1, 7, 5, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 16))).setMaxAccess("readonly")
if mibBuilder.loadTexts: filterPortModule.setDescription("An index value that uniquely identifies the                      module where this port is located\n(see portModuleIndex).")
filterPort = MibTableColumn((0, 1, 7, 5, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: filterPort.setDescription("An index value that uniquely identifies this port                      within a module (see portIndex).")
filterPortComplex = MibTableColumn((0, 1, 7, 5, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 50))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: filterPortComplex.setDescription("A complex expression made up of the numbers 1                      through 8 indicating test results from\nfilterTestIndex and using logical operators '&'\n(and), '|' (or), '!' (not), and parenthesis. For\nexample: ((1 & 2) | !3). If this complex filter\nmatches a packet, it is dropped.")
filterPortBroadcastThrottle = MibTableColumn((0, 1, 7, 5, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 150000)).clone(0)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: filterPortBroadcastThrottle.setDescription("The maximum number of broadcast packets per                      second allowed on this port. If the number of\nincoming broadcast packets in a one second\ninterval exceeds this amount, packets are\ndropped for the rest of the interval. If the\ncapability exists, only broadcast packets should\nbe dropped. Otherwise, all packets are dropped\nduring the suppression interval.\n\nA value of 0 indicates broadcast packets should\nnot be limited.\n\nThe ability to suppress broadcast packets in this\nmanner exists only on certain ports. If it does\nnot exist on this port, attempts to write a value\nother than 0 are rejected.\n\nThis object also applies to multicast (and/or)\nunicast suppression when\nfilterPortSuppressionOption is enabled.")
filterPortBroadcastThreshold = MibTableColumn((0, 1, 7, 5, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100)).clone(100)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: filterPortBroadcastThreshold.setDescription("Indicates the integer part of the maximum                      percentage of available bandwidth allowed for\nincoming traffic of the specific traffic types on\nthis port. The associated object\nfilterPortBroadcastThresholdFraction indicates the\nfraction part of the maximum percentage of\navailable bandwidth allowed for incoming traffic\nof the specific traffic types on this port. Either\npackets of the specific traffic types are dropped\nof the port is put into errdisable state depending\non the value of filterPortSuppressionViolation on\nthis port if the percentage of incoming traffic of\nthe specific traffic types would exceed this\nlimit. The traffic types that are enabled for\nthis traffic suppression feature is indicated by\nfilterPortBroadcastOption.\n\nThe maximum percentage for the combination of this\nobject value and the object value of\nfilterPortBroadcastThresholdFraction is 100.00\nwhich indicates traffic of all traffic types\nshould not be limited.\n\nThe ability to suppress traffic in this manner\nexists only on certain ports. If it does not\nexist on this port, attempts to write a value of\nthis object other than 100 are rejected.\n\nOn platforms where filterPortSuppressionOption\nobject is not supported, this object only applies\nto broadcast suppression.")
filterPortBroadcastDiscards = MibTableColumn((0, 1, 7, 5, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: filterPortBroadcastDiscards.setDescription("The number of packets discarded due to traffic                      suppression on this port.")
filterPortBroadcastThresholdFraction = MibTableColumn((0, 1, 7, 5, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 99)).clone(0)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: filterPortBroadcastThresholdFraction.setDescription("Indicates the fraction part of the maximum                      percentage of available bandwidth allowed for\nincoming traffic of the specific traffic types on\nthis port. The associated object\nfilterPortBroadcastThreshold indicates the integer\npart of the maximum percentage of available\nbandwidth allowed for incoming traffic of the\nspecific traffic types on this port. Either\npackets of the specific traffic types are dropped\nor the port is put into errdisable state\ndepending on the value of\nfilterPortSuppressionViolation on this port if the\npercentage of incoming traffic of the specific\ntraffic type would exceed this limit. The\ntraffic types that are enabled for this traffic\nsuppression feature is indicated by\nfilterPortBroadcastOption.\n\nThe maximum percentage for the combination\nof this object value and the object value of\nfilterPortBroadcastThreshold is 100.00 which\nindicates traffic of all traffic types should not\nbe limited.\n\nThe ability to suppress traffic in this manner\nexists only on certain ports. If it does not exist\non this port, attempts to write a value of this\nobject other than 100 are rejected.\n\nOn platforms where filterPortSuppressionOption\nobject is not supported, this object only applies\nto broadcast suppression.")
filterPortSuppressionOption = MibTableColumn((0, 1, 7, 5, 1, 8), Bits().subtype(namedValues=NamedValues(("multicast", 0), ("unicast", 1), ("broadcast", 2), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: filterPortSuppressionOption.setDescription("Indicates the traffic types that traffic                      suppression feature is enabled for.\n\nmulticast(0) is set when multicast suppression is\nenabled. unicast(1) is set when unicast\nsuppression is enabled. broadcast(2) is set when\nbroadcast suppression is enabled.")
filterPortSuppressionViolation = MibTableColumn((0, 1, 7, 5, 1, 9), Integer().subtype(subtypeSpec=SingleValueConstraint(1,2,)).subtype(namedValues=NamedValues(("dropPackets", 1), ("errdisable", 2), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: filterPortSuppressionViolation.setDescription("Indicates the action that will be taken on this                      port when the percentage of either broadcast,\nmulticast or unicast traffic exceeds the limit as\nindicated by filterPortBroadcastThreshold and\nfilterPortBroadcastThresholdFraction.\n\n\ndropPackets - the excessive packets will be\n            - dropped on this port.\n\nerrdisable - the port will be put into errdisable\n           - state.\n\nThe object is only supported on platforms that\nsupport this suppression violation action\nfeature.")
monitorGrp = MibIdentifier((0, 1, 8))
monitorSourceModule = MibScalar((0, 1, 8, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 16))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: monitorSourceModule.setDescription("An index value that uniquely identifies the                      module where the monitoring source port is\nlocated. A value of 0 indicates that the\nmonitorSourcePort is really a source Virtual LAN\nnumber. To monitor multiple source ports, this\nobject should be set to 0 and\nmonitorAdminSourcePorts should be configured.")
monitorSourcePort = MibScalar((0, 1, 8, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1023))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: monitorSourcePort.setDescription("An index value that uniquely identifies the                      monitoring source port within a module or the\nmonitoring source Virtual LAN. To monitor multiple\nsource ports, this object should be set to 0 and\nmonitorAdminSourcePorts should be configured")
monitorDestinationModule = MibScalar((0, 1, 8, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 16))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: monitorDestinationModule.setDescription("An index value that uniquely identifies the                      module where the monitoring destination port is\nlocated.")
monitorDestinationPort = MibScalar((0, 1, 8, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: monitorDestinationPort.setDescription("An index value that uniquely identifies the                      monitoring destination port within a module.")
monitorDirection = MibScalar((0, 1, 8, 5), Integer().subtype(subtypeSpec=SingleValueConstraint(1,2,3,)).subtype(namedValues=NamedValues(("transmit", 1), ("receive", 2), ("transmitAndReceive", 3), )).clone(3)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: monitorDirection.setDescription("The type of packets to be monitored at the source                      port.")
monitorEnable = MibScalar((0, 1, 8, 6), Integer().subtype(subtypeSpec=SingleValueConstraint(2,1,)).subtype(namedValues=NamedValues(("enabled", 1), ("disabled", 2), )).clone(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: monitorEnable.setDescription("Indicates whether port monitoring is in                      progress.")
monitorAdminSourcePorts = MibScalar((0, 1, 8, 7), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: monitorAdminSourcePorts.setDescription("Indicates the administrative status of which                      ports are monitored. All the monitored ports have\nto be non-trunking port and belong to the same\nVirtual LAN. The octet string contains one bit\nper port. Each bit within the octet string\nrepresents one port of the device. The ordering\nof ports represented within the octet string is\nin the same order as in the RFC 1493\ndot1dStpPortTable.\n\nThe bit value interpretation is as follows:\n        1 = being monitored\n        0 = not being monitored")
monitorOperSourcePorts = MibScalar((0, 1, 8, 8), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: monitorOperSourcePorts.setDescription("Indicates which ports are actually being                      monitored. All the monitored ports have to be\nnon-trunking port and belong to the same Virtual\nLAN. The octet string contains one bit per port.\nEach bit within the octet string represents one\nport of the device. The ordering of ports\nrepresented within the octet string is in the same\norder as in the RFC 1493 dot1dStpPortTable.\n\nThe bit value interpretation is as follows:\n        1 = being monitored\n        0 = not being monitored")
vlanGrp = MibIdentifier((0, 1, 9))
vlanTable = MibTable((0, 1, 9, 2))
if mibBuilder.loadTexts: vlanTable.setDescription("A list of Virtual LAN entries. The number of                      entries is determined by the number of VLANs\nsupported by the system.")
vlanEntry = MibTableRow((0, 1, 9, 2, 1)).setIndexNames((0, "CISCO-STACK-MIB", "vlanIndex"))
if mibBuilder.loadTexts: vlanEntry.setDescription("Entry containing information for a particular                      Virtual LAN.")
vlanIndex = MibTableColumn((0, 1, 9, 2, 1, 1), VlanIndex()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vlanIndex.setDescription("An index value that uniquely identifies the                      Virtual LAN associated with this information.")
vlanSpantreeEnable = MibTableColumn((0, 1, 9, 2, 1, 2), Integer().subtype(subtypeSpec=SingleValueConstraint(2,3,1,)).subtype(namedValues=NamedValues(("enabled", 1), ("disabled", 2), ("notApplicable", 3), )).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vlanSpantreeEnable.setDescription("Indicates whether Spanning Tree protocol is                      enabled for this Virtual LAN.\n\nIf the device only supports a single global\nSpanning Tree PVST+ Protocol enable/disable\nfor all the existing VLANs, then the object\nvalue assigned to this VLAN will be applied\nto the object values of all the instances\nin this table which do not have the value\nof notApplicable(3).\n\nThis object is deprecated and replaced by\nstpxPVSTVlanEnable in\nCISCO-STP-EXTENSIONS-MIB.")
vlanIfIndex = MibTableColumn((0, 1, 9, 2, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vlanIfIndex.setDescription("The value of the ifIndex object defined in                      MIB-II, for the interface corresponding to this\nVLAN.\n\nThis object is deprecated and replaced by\nvtpVlanIfIndex in CISCO-VTP-MIB.")
vlanPortTable = MibTable((0, 1, 9, 3))
if mibBuilder.loadTexts: vlanPortTable.setDescription("A list of Virtual LAN port entries. The number of                      entries is determined by the number of modules in\nthe chassis and the number of ports on each\nmodule.")
vlanPortEntry = MibTableRow((0, 1, 9, 3, 1)).setIndexNames((0, "CISCO-STACK-MIB", "vlanPortModule"), (0, "CISCO-STACK-MIB", "vlanPort"))
if mibBuilder.loadTexts: vlanPortEntry.setDescription("Entry containing Virtual LAN information for a                      particular port on a module.")
vlanPortModule = MibTableColumn((0, 1, 9, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 16))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vlanPortModule.setDescription("An index value that uniquely identifies the                      module where this port is located\n(see portModuleIndex).")
vlanPort = MibTableColumn((0, 1, 9, 3, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vlanPort.setDescription("An index value that uniquely identifies this port                      within a module (see portIndex).")
vlanPortVlan = MibTableColumn((0, 1, 9, 3, 1, 3), VlanIndex()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vlanPortVlan.setDescription("The Virtual LAN to which this port belongs.")
vlanPortIslVlansAllowed = MibTableColumn((0, 1, 9, 3, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vlanPortIslVlansAllowed.setDescription("An indication of which Virtual LANs are allowed                      on this Inter-Switch Link. This is an octet string\nvalue with bits set to indicate allowed VLANs. It\ncan be interpreted as a sum of f(x) as x goes from\n0 to 1023, where f(x) = 0 for VLAN x not allowed\nand f(x) = exp(2, x) for VLAN x allowed.")
vlanPortSwitchLevel = MibTableColumn((0, 1, 9, 3, 1, 6), Integer().subtype(subtypeSpec=SingleValueConstraint(2,3,1,)).subtype(namedValues=NamedValues(("normal", 1), ("high", 2), ("notApplicable", 3), )).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vlanPortSwitchLevel.setDescription("Indicates the priority level the port uses to                      access the switching media. If vlanPortSwitchLevel\nis not applicable to the port, notApplicable(3)\nwill be returned by the device.")
vlanPortIslAdminStatus = MibTableColumn((0, 1, 9, 3, 1, 7), Integer().subtype(subtypeSpec=SingleValueConstraint(1,5,2,4,3,)).subtype(namedValues=NamedValues(("on", 1), ("off", 2), ("desirable", 3), ("auto", 4), ("onNoNegotiate", 5), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vlanPortIslAdminStatus.setDescription("Indicates the administrative status set on the                      trunk port while the operational status is the one\nthat indicates whether the port is actually\ntrunking or not. If the status is set to off(2),\nthe port is permanently set to be a non-trunk. If\nthe status is set to onNoNegotiate(5), the port is\npermanently set to be a trunk and no negotiation\ntakes place with the far end to try to ensure\nconsistent operation. If the status is set to\non(1), the port initiates a request to become a\ntrunk and will become a trunk regardless of the\nresponse from the far end. If the status is set to\ndesirable(3), the port initiates a request to\nbecome a trunk and will become a trunk if the far\nend agrees. If the status is set to auto(4), the\nport does not initiate a request to become a trunk\nbut will do so if it receives a request to become\na trunk from the far end.")
vlanPortIslOperStatus = MibTableColumn((0, 1, 9, 3, 1, 8), Integer().subtype(subtypeSpec=SingleValueConstraint(2,1,)).subtype(namedValues=NamedValues(("trunking", 1), ("notTrunking", 2), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vlanPortIslOperStatus.setDescription("Indicates if the port is actually trunking or                      not. In the case of ISL capable ports, the status\ndepends on the success or failure of the\nnegotiation process initiated by the port to\nbecome a trunk or non trunk.\nIn the case of 802.10 capable ports, it is\ndirectly related to the on/off administrative\nstatus.")
vlanPortIslPriorityVlans = MibTableColumn((0, 1, 9, 3, 1, 9), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vlanPortIslPriorityVlans.setDescription("An indication of which Virtual LANs have a better                      dot1dStpPortPriority value. This object can be\nused to perform load balancing on Inter-Switch\nLinks via spanning tree. An Inter-Switch Link has\ntwo dot1dStpPortPriority values which are shared\nby all the Virtual LANs on the link. The Virtual\nLANs indicated by this object have priority\nover the other Virtual LANs on the link.\n\nThis is an octet string value with bits set to\nindicate priority VLANs. It can be interpreted as\na sum of f(x) as x goes from 0 to 1023, where\nf(x) = 0 for a VLAN x which does not have priority\nand f(x) = exp(2, x) for a VLAN x which has\npriority.\n\nSetting the dot1dStpPortPriority value for any of\nthe Virtual LANs indicated by this object causes\nthe dot1dStpPortPriority value for all the Virtual\nLANs indicated by this object to be set to the\nsame value.\n\nSetting the dot1dStpPortPriority value for any\nother Virtual LAN causes the dot1dStpPortPriority\nvalue for all other Virtual LANs to be set to the\nsame value.")
vlanPortAdminStatus = MibTableColumn((0, 1, 9, 3, 1, 10), Integer().subtype(subtypeSpec=SingleValueConstraint(2,1,)).subtype(namedValues=NamedValues(("static", 1), ("dynamic", 2), )).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vlanPortAdminStatus.setDescription("Indicates whether the port will get assigned to a                      VLAN statically or dynamically. When it is set to\ndynamic, the needed information will be accessed\nfrom one of the Vlan Membership Policy Servers\nspecified in the vmpsTable. Default value is\nstatic(1).\nNote that vlanPortAdminStatus cannot be set to\ndynamic(2) for a port which has\nportSecurityAdminStatus set to enabled(1) or for a\nport which currently has a vlanPortIslOperStatus\nof trunking(1).")
vlanPortOperStatus = MibTableColumn((0, 1, 9, 3, 1, 11), Integer().subtype(subtypeSpec=SingleValueConstraint(2,1,4,3,)).subtype(namedValues=NamedValues(("inactive", 1), ("active", 2), ("shutdown", 3), ("vlanActiveFault", 4), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vlanPortOperStatus.setDescription("An indication of the current VLAN status of the                      port.\nA status of inactive(1) indicates that a dynamic\nport does not yet have a VLAN assigned or that a\nstatic or dynamic port has been assigned a VLAN\nthat is not currently active. A status of\nactive(2) indicates that the currently assigned\nVLAN is active. A status of shutdown(3) indicates\nthat the port has been shutdown as a result of a\nVMPS response on a dynamic port.\nA status of vlanActiveFault(4) only applies to\ntokenring ports and indicates that the port is\noperationally disabled because the TR-CRF VLAN of\nwhich the port is a member has active ports on\nanother device and only ports on that remote\ndevice may participate in that TR-CRF VLAN.")
vlanPortAuxiliaryVlan = MibTableColumn((0, 1, 9, 3, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0,1000),ValueRangeConstraint(1025,4096),))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vlanPortAuxiliaryVlan.setDescription("The Voice Virtual Vlan ID (VVID) to which this                      port belongs to.\nIf the VVID is not supported on the port, this MIB\nobject will not be configurable and will return\n4096.\n\nSetting this MIB object to 4096, the CDP packets\ntransmitting through this port would not include\nAppliance VLAN-ID TLV.\n\nSetting this MIB object to 4095, the CDP packets\ntransmitting through this port would contain\nAppliance VLAN-ID TLV with value of 4095 - VoIP\nand related packets are expected to be sent and\nreceived untagged without an 802.1p priority.\n\nSetting this MIB object to 0, the CDP packets\ntransmitting through this port would contain\nAppliance VLAN-ID TLV with value of 0 - VoIP\nand related packets are expected to be sent and\nreceived with VLAN-id=0 and an 802.1p priority.\n\nSetting this MIB object to N (1..1000|1025..4094),\nthe CDP packets transmitting through this port\nwould contain Appliance VLAN-ID TLV with N - VoIP\nand related packets are expected to be sent and\nreceived with VLAN-id=N and an 802.1p priority.\n\nThis object is deprecated and replaced by\nvmVoiceVlanId in CISCO-VLAN-MEMBERSHIP-MIB.")
vmpsTable = MibTable((0, 1, 9, 4))
if mibBuilder.loadTexts: vmpsTable.setDescription("This table lists a maximum of 3 IP addresses of                      Vlan Membership Policy Servers.")
vmpsEntry = MibTableRow((0, 1, 9, 4, 1)).setIndexNames((0, "CISCO-STACK-MIB", "vmpsAddr"))
if mibBuilder.loadTexts: vmpsEntry.setDescription("A VMPS table entry.")
vmpsAddr = MibTableColumn((0, 1, 9, 4, 1, 1), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vmpsAddr.setDescription("The IP address of a Vlan Membership Policy                      Server. To configure the internal VMPS, use the\nsame IP address as specified in sysIpAddr.")
vmpsType = MibTableColumn((0, 1, 9, 4, 1, 2), Integer().subtype(subtypeSpec=SingleValueConstraint(3,2,1,)).subtype(namedValues=NamedValues(("invalid", 1), ("primary", 2), ("other", 3), ))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vmpsType.setDescription("To add a new entry to the vmpsTable, set this                      object to primary(2) or other(3) for an IP address\nwhich is not already in the table. The primary\nentry will be used first, if it is reachable.\nOtherwise one of the other entries will be used.\nSetting one entry to primary(2) causes any\nprevious primary entry to change to other(3).\nTo remove an entry from the table, set this\nobject to invalid(1).")
vmpsAction = MibScalar((0, 1, 9, 5), Integer().subtype(subtypeSpec=SingleValueConstraint(8,6,1,7,3,5,2,4,)).subtype(namedValues=NamedValues(("other", 1), ("inProgress", 2), ("success", 3), ("noResponse", 4), ("noPrimaryVmps", 5), ("noDynamicPort", 6), ("noHostConnected", 7), ("reconfirm", 8), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vmpsAction.setDescription("This object, when read, returns the result of the                      last action requested: other(1), inProgress(2),\nsuccess(3), noResponse(3), noPrimaryVmps(5),\nnoDynamicPort(6), or noHostConnected(7).\n\nSetting this object to reconfirm(8) causes the\nswitch to contact the Vlan Membership Policy\nServer immediately to reconfirm the current VLAN\nassignments for all dynamic ports on the switch.\nNormally VLAN assignments for dynamic ports are\nreconfirmed once an hour.")
vmpsAccessed = MibScalar((0, 1, 9, 6), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vmpsAccessed.setDescription("The IP address of the last Vlan Membership Policy                      Server accessed. If there was no response from the\nlast VMPS request, the value returned is 0.")
vlanTrunkMappingMax = MibScalar((0, 1, 9, 7), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly").setUnits("entries")
if mibBuilder.loadTexts: vlanTrunkMappingMax.setDescription("Maximum number of active configurable trunk VLAN                      mapping entries allowed. A value of zero indicates\nno limitation on the number of active configurable\ntrunk VLAN mapping.")
vlanTrunkMappingTable = MibTable((0, 1, 9, 8))
if mibBuilder.loadTexts: vlanTrunkMappingTable.setDescription("This table contains zero or more rows of trunk                      VLAN to VLAN associations. The maximum number of\nactive entries is determined by\nvlanTrunkMappingMax.\n\nVLAN above 1k can not be created if the value of\ncorresponding instance of vlanTrunkMappingType is\ndot1qToisl(2).")
vlanTrunkMappingEntry = MibTableRow((0, 1, 9, 8, 1)).setIndexNames((0, "CISCO-STACK-MIB", "vlanTrunkMappingFromVlan"))
if mibBuilder.loadTexts: vlanTrunkMappingEntry.setDescription("Information about the VLAN mapping of a                      particular trunk VLAN to another VLAN.")
vlanTrunkMappingFromVlan = MibTableColumn((0, 1, 9, 8, 1, 1), VlanIndex()).setMaxAccess("noaccess")
if mibBuilder.loadTexts: vlanTrunkMappingFromVlan.setDescription("The VLAN with this VLAN ID will be mapped to the                      VLAN in the corresponding instance of\nvlanTrunkMappingToVlan in the device.\n\nAgent returns inconsistentValue if this VLAN\nexists in the device.\n\nAgent returns inconsistentValue if this VLAN is\nnot a reserved VLAN and the value of corresponding\ninstance of vlanTrunkMappingType is\nreservedToNonReserved(1).\n\nAgent returns wrongValue if this VLAN is not a\nvalid 802.1Q VLAN and the value of corresponding\ninstance of vlanTrunkMappingType is\ndot1qToisl(2).")
vlanTrunkMappingToVlan = MibTableColumn((0, 1, 9, 8, 1, 2), VlanIndex()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vlanTrunkMappingToVlan.setDescription("The VLAN which the corresponding instance of                      vlanTrunkMappingFromVlan will be mapped to.\n\nAgent returns inconsistentValue if this VLAN\nexists in the device.\n\nAgent returns inconsistentValue if this VLAN is a\nreserved VLAN and the value of corresponding\ninstance of vlanTrunkMappingType is\nreservedToNonReserved(1).\n\nAgent returns inconsistentValue if this VLAN is\nnot a valid ISL VLAN and the value of\ncorresponding instance of vlanTrunkMappingType\nis dot1qToisl(2).")
vlanTrunkMappingType = MibTableColumn((0, 1, 9, 8, 1, 3), Integer().subtype(subtypeSpec=SingleValueConstraint(1,2,)).subtype(namedValues=NamedValues(("reservedToNonReserved", 1), ("dot1qToisl", 2), ))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vlanTrunkMappingType.setDescription("The type of this trunk VLAN mapping.\nreservedToNonReserved(1)\n    An user defined association which maps a\n    reserved VLAN to a non-reserved VLAN.\n\ndot1qToisl(2)\n    An user defined association which maps a VLAN\n    in 802.1q trunk to a VLAN in ISL trunk.\n\nImplementations are allowed to restrict the\navailable types for this object.\n\nFor devices which support the range of VlanIndex\nbetween 1024 and 4095, the default value is\nreservedToNonReserved(1).  The default value is\ndot1qToisl(2) for devices which do not support the\nrange of VlanIndex between 1024 and 4095.")
vlanTrunkMappingOper = MibTableColumn((0, 1, 9, 8, 1, 4), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vlanTrunkMappingOper.setDescription("Indicates whether this VLAN mapping is effective                      or not.")
vlanTrunkMappingStatus = MibTableColumn((0, 1, 9, 8, 1, 5), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vlanTrunkMappingStatus.setDescription("The status of this trunk VLAN mapping.\nOnce a row becomes active, value in any other\ncolumn within such row cannot be modified except\nby setting vlanTrunkMappingStatus to\nnotInService(2) for such row.")
securityGrp = MibIdentifier((0, 1, 10))
portSecurityTable = MibTable((0, 1, 10, 1))
if mibBuilder.loadTexts: portSecurityTable.setDescription("A list of port security entries. The number of                      entries is determined by the number of ports in\nthe system which support the Security feature.")
portSecurityEntry = MibTableRow((0, 1, 10, 1, 1)).setIndexNames((0, "CISCO-STACK-MIB", "portSecurityModuleIndex"), (0, "CISCO-STACK-MIB", "portSecurityPortIndex"))
if mibBuilder.loadTexts: portSecurityEntry.setDescription("Entry containing security information for a                      particular port.")
portSecurityModuleIndex = MibTableColumn((0, 1, 10, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 16))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portSecurityModuleIndex.setDescription("An index value that uniquely identifies the                      module where this port is located\n(see portModuleIndex).")
portSecurityPortIndex = MibTableColumn((0, 1, 10, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portSecurityPortIndex.setDescription("An index value that uniquely identifies this port                      within a module (see portIndex).")
portSecurityAdminStatus = MibTableColumn((0, 1, 10, 1, 1, 3), Integer().subtype(subtypeSpec=SingleValueConstraint(2,1,)).subtype(namedValues=NamedValues(("enabled", 1), ("disabled", 2), )).clone(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portSecurityAdminStatus.setDescription("When security is enabled, source MAC addresses                      are monitored for all packets received on the\nport. If an address is detected that does not\nmatch the portSecuritySecureSrcAddr and any\ncorresponding portSecurityExtSecureSrcAddr, of\nwhich portSecurityExtModuleIndex and\nportSecurityExtPortIndex in the\nportSecurityExtTable is the same as the\nportSecurityModuleIndex and portSecurityPortIndex,\nand the number of MAC address learned or\nconfigured for this port is equal to\nportSecurityMaxSrcAddr, the port will shutdown or\ndrop packets. If the\nportSecurityViolationPolicy is set to shutdown(2),\nthe port is shutdown and a linkDown trap is sent;\notherwise the port drops the invalid packets.")
portSecurityOperStatus = MibTableColumn((0, 1, 10, 1, 1, 4), Integer().subtype(subtypeSpec=SingleValueConstraint(2,1,)).subtype(namedValues=NamedValues(("notShutdown", 1), ("shutdown", 2), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portSecurityOperStatus.setDescription("An indication of whether the port has been shut                      down as a result of an insecure address being\ndetected on a secure port.")
portSecurityLastSrcAddr = MibTableColumn((0, 1, 10, 1, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readonly")
if mibBuilder.loadTexts: portSecurityLastSrcAddr.setDescription("The last source MAC address in a receive packet                      seen on the port.")
portSecuritySecureSrcAddr = MibTableColumn((0, 1, 10, 1, 1, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portSecuritySecureSrcAddr.setDescription("The address to be compared with source MAC                      addresses of received packets when the\nportSecurityAdminStatus is enabled(1). Setting\nthis value to 0.0.0.0.0.0 puts the port in\nlearning mode so that the next source MAC\naddress received by the port becomes the\nportSecuritySecureSrcAddr.")
portSecurityMaxSrcAddr = MibTableColumn((0, 1, 10, 1, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1025)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portSecurityMaxSrcAddr.setDescription("The maximum number (N) of MAC address to be                      secured on the port. The first N MAC addresses\nlearned or configured are made secured. If the\nuser wants to make the port secured for more than\none MAC address, the portSecurityExtTable is used\nin addition to portSecuritySecureSrcAddr. If\nchanging the maximum number N of Mac address to M,\nwhich is smaller than N, some MAC addresses are\nremoved. Setting this value to 1,\nthe portSecurityExtTable will not be used for this\nport and the corresponding entries for this port\nwill also be removed from portSecurityExtTable.")
portSecurityAgingTime = MibTableColumn((0, 1, 10, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0,0),ValueRangeConstraint(10,1440),)).clone(0)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portSecurityAgingTime.setDescription("The interval in which the port is secured. After                      the expiration of the time, the corresponding\nportSecuritySecureSrcAddr or\nportSecurityExtSecureSrcAddr will be removed from\nthe secure address list. If the value of this\nobject is 0, the aging mechanism is disabled.")
portSecurityShutdownTimeOut = MibTableColumn((0, 1, 10, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0,0),ValueRangeConstraint(10,1440),)).clone(0)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portSecurityShutdownTimeOut.setDescription("The interval in which the port is shutdown due to                      the violation of security. After the expiration\nof the time all the security configuration of this\nport is re-installed and the port is enabled. If\nthe value of this object is 0, the port is shut\ndown permanently.")
portSecurityViolationPolicy = MibTableColumn((0, 1, 10, 1, 1, 10), Integer().subtype(subtypeSpec=SingleValueConstraint(1,2,)).subtype(namedValues=NamedValues(("restrict", 1), ("shutdown", 2), )).clone(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portSecurityViolationPolicy.setDescription("If the value of this object is                        restrict(1)  - the port drops all packets with\ninsecured addresses.\nshutdown(2)  - the port is forced to shut down\nif there is a violation of\nsecurity.")
portSecurityExtTable = MibTable((0, 1, 10, 2))
if mibBuilder.loadTexts: portSecurityExtTable.setDescription("A list of port security entries. The number of                      entries is determined by the number of ports in\nthe system which support the Security feature and\nthe number of MAC addresses learned/configured to\nbe secured per port.")
portSecurityExtEntry = MibTableRow((0, 1, 10, 2, 1)).setIndexNames((0, "CISCO-STACK-MIB", "portSecurityExtModuleIndex"), (0, "CISCO-STACK-MIB", "portSecurityExtPortIndex"), (0, "CISCO-STACK-MIB", "portSecurityExtSecureSrcAddr"))
if mibBuilder.loadTexts: portSecurityExtEntry.setDescription("Entry containing security information for a                      particular port and a particular MAC address. The\nentry can be configured by the user and can be\nadded by the agent when the device learns a new\nsecured MAC address.")
portSecurityExtModuleIndex = MibTableColumn((0, 1, 10, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 16))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portSecurityExtModuleIndex.setDescription("An index value that uniquely identifies the                      module where this port is located\n(see portModuleIndex).")
portSecurityExtPortIndex = MibTableColumn((0, 1, 10, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portSecurityExtPortIndex.setDescription("An index value that uniquely identifies this port                      within a module (see portIndex).")
portSecurityExtSecureSrcAddr = MibTableColumn((0, 1, 10, 2, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readonly")
if mibBuilder.loadTexts: portSecurityExtSecureSrcAddr.setDescription("An index value that uniquely identifies the  MAC                      address, which is to be secured.")
portSecurityExtControlStatus = MibTableColumn((0, 1, 10, 2, 1, 4), Integer().subtype(subtypeSpec=SingleValueConstraint(1,2,)).subtype(namedValues=NamedValues(("valid", 1), ("invalid", 2), ))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: portSecurityExtControlStatus.setDescription("This object used to add or remove a secured                      MAC address of the corresponding port in\nthe row. If setting this object to valid(1), the\nportSecurityExtSecureSrcAddr is made to be secured\nfor the port. If setting this object to\ninvalid(2), the portSecurityExtSecureSrcAddr is\nno longer to be secured for the current port.")
tokenRingGrp = MibIdentifier((0, 1, 11))
tokenRingPortTable = MibTable((0, 1, 11, 1))
if mibBuilder.loadTexts: tokenRingPortTable.setDescription("Table containing token ring configuration                      information.")
tokenRingPortEntry = MibTableRow((0, 1, 11, 1, 1)).setIndexNames((0, "CISCO-STACK-MIB", "tokenRingModuleIndex"), (0, "CISCO-STACK-MIB", "tokenRingPortIndex"))
if mibBuilder.loadTexts: tokenRingPortEntry.setDescription("Entry containing token ring configuration                      information for a particular port.")
tokenRingModuleIndex = MibTableColumn((0, 1, 11, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 16))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokenRingModuleIndex.setDescription("An index value that uniquely identifies the                      module where this port is located\n(see portModuleIndex).")
tokenRingPortIndex = MibTableColumn((0, 1, 11, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokenRingPortIndex.setDescription("An index value that uniquely identifies this port                      within a module (see portIndex).")
tokenRingPortSetACbits = MibTableColumn((0, 1, 11, 1, 1, 3), Integer().subtype(subtypeSpec=SingleValueConstraint(2,1,)).subtype(namedValues=NamedValues(("enabled", 1), ("disabled", 2), )).clone(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tokenRingPortSetACbits.setDescription("Specifies if the AC bits shall be set                      unconditionally when a port forwards certain LLC\nframes.")
tokenRingPortMode = MibTableColumn((0, 1, 11, 1, 1, 4), Integer().subtype(subtypeSpec=SingleValueConstraint(5,7,1,4,2,3,)).subtype(namedValues=NamedValues(("auto", 1), ("fdxCport", 2), ("fdxStation", 3), ("hdxCport", 4), ("hdxStation", 5), ("riro", 7), )).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tokenRingPortMode.setDescription("Specifies the port's mode of operation.\nauto:       Automatically detect the port mode\n            upon insertion.\n\nfdxCport:   Transmit Immediate (full-duplex)\n            Concentrator Port\n\nfdxStation: Transmit Immediate (full-duplex)\n            Station emulation\n\nhdxCport:   Token Passing Protocol (half-duplex)\n            Concentrator Port\n\nhdxStation: Token Passing Protocol (half-duplex)\n            Station emulation\n\nriro:       RingIn/RingOut mode. (wsx5031 only)")
tokenRingPortEarlyTokenRel = MibTableColumn((0, 1, 11, 1, 1, 9), Integer().subtype(subtypeSpec=SingleValueConstraint(2,1,)).subtype(namedValues=NamedValues(("enabled", 1), ("disabled", 2), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tokenRingPortEarlyTokenRel.setDescription("This object provides the ability to enable or                      disable early token release for a particular port.\n\nEarly token release only applies to ports\noperating at 16 Mbps. If ifSpeed reflects 4 Mbps\nfor a particular port, then the corresponding\ninstance of this object will have a value of\ndisabled(2) regardless of attempts to set the\nobject to enabled(1).\n\nWhenever a port is opened with a ring speed of\n16 Mbps, by default, early token release will be\nenabled.")
tokenRingPortPriorityThresh = MibTableColumn((0, 1, 11, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7)).clone(3)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tokenRingPortPriorityThresh.setDescription("The highest token ring frame priority that shall                      go to the low-priority transmit queue.")
tokenRingPortPriorityMinXmit = MibTableColumn((0, 1, 11, 1, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 6)).clone(4)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tokenRingPortPriorityMinXmit.setDescription("The minimum token priority that will be used for                      transmit.")
tokenRingPortCfgLossThresh = MibTableColumn((0, 1, 11, 1, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 100)).clone(8)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tokenRingPortCfgLossThresh.setDescription("Number of configuration loss events during the                      sample interval which, if exceeded, should cause\nthe port to be disabled. If the port is disabled\nby this function the port must be administratively\nre-enabled.")
tokenRingPortCfgLossInterval = MibTableColumn((0, 1, 11, 1, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 9999)).clone(10)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tokenRingPortCfgLossInterval.setDescription("The sampling interval, in minutes, for which the                      port monitors to see if the configuration loss\nthreshold has been exceeded.")
tokenRingDripDistCrfMode = MibScalar((0, 1, 11, 2), Integer().subtype(subtypeSpec=SingleValueConstraint(2,1,)).subtype(namedValues=NamedValues(("enabled", 1), ("disabled", 2), )).clone(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tokenRingDripDistCrfMode.setDescription("This object reflects whether TR-CRFs can be                      distributed across ISL topologies. Setting\nthis object to enabled(1) allows TR-CRFs to be\ndistributed. Setting this object to disabled(2)\nprevents TR-CRFs from being distributed across\nISL topologies. When this object is set to\ndisabled(2), the system will disable ports\ninvolved in the distributed TR-CRF.")
tokenRingDripAreReductionMode = MibScalar((0, 1, 11, 3), Integer().subtype(subtypeSpec=SingleValueConstraint(2,1,)).subtype(namedValues=NamedValues(("enabled", 1), ("disabled", 2), )).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tokenRingDripAreReductionMode.setDescription("This object reflects whether or not All                      Routes Explorer (ARE) reduction capabilities are\nenabled or disabled on this system. Setting\nthis object to enabled(1) will permit DRiP to\nparticipate in the configuration of Token Ring\nports ARE reduction capabilities on the system.\nSetting this object to disabled(2) will prevent\nDRiP from participating in the configuration\nof Token Ring port ARE reduction capabilities.")
tokenRingDripLocalNodeID = MibScalar((0, 1, 11, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokenRingDripLocalNodeID.setDescription("The unique system identifier that will be sent                      in all advertisements generated by this system.\nIt uniquely identifies this system from other\nDRiP capable systems.")
tokenRingDripLastRevision = MibScalar((0, 1, 11, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 9999999))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokenRingDripLastRevision.setDescription("The revision number transmitted in the most                      recent advertisement. That advertisement may\nor may not have contained changed data.")
tokenRingDripLastChangedRevision = MibScalar((0, 1, 11, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 9999999))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokenRingDripLastChangedRevision.setDescription("The revision number transmitted in the most                      recent advertisement containing changed data.")
tokenRingDripAdvertsReceived = MibScalar((0, 1, 11, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokenRingDripAdvertsReceived.setDescription("The number of DRiP advertisements received                      by this system.")
tokenRingDripAdvertsTransmitted = MibScalar((0, 1, 11, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokenRingDripAdvertsTransmitted.setDescription("The number of DRiP advertisements transmitted                      by this system.")
tokenRingDripAdvertsProcessed = MibScalar((0, 1, 11, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokenRingDripAdvertsProcessed.setDescription("The number of DRiP advertisements processed                      by this system.")
tokenRingDripInputQueueDrops = MibScalar((0, 1, 11, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokenRingDripInputQueueDrops.setDescription("The number of DRiP advertisements dropped                      from this system's input queue.")
tokenRingDripOutputQueueDrops = MibScalar((0, 1, 11, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokenRingDripOutputQueueDrops.setDescription("The number of DRiP advertisements dropped                      from this system's output queue.")
tokenRingDripLocalVlanStatusTable = MibTable((0, 1, 11, 12))
if mibBuilder.loadTexts: tokenRingDripLocalVlanStatusTable.setDescription("A table containing DRiP VLAN status information                      local to this system. The existence of an\nentry indicates that at least one local port\nis assigned to the associated TR-CRF VLAN.")
tokenRingDripLocalVlanStatusEntry = MibTableRow((0, 1, 11, 12, 1)).setIndexNames((0, "CISCO-STACK-MIB", "tokenRingDripVlan"))
if mibBuilder.loadTexts: tokenRingDripLocalVlanStatusEntry.setDescription("Entry containing DRiP related information for                      a particular TR-CRF VLAN.")
tokenRingDripVlan = MibTableColumn((0, 1, 11, 12, 1, 1), VlanIndex()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokenRingDripVlan.setDescription("A TR-CRF VLAN ID.")
tokenRingDripLocalPortStatus = MibTableColumn((0, 1, 11, 12, 1, 2), Integer().subtype(subtypeSpec=SingleValueConstraint(1,2,)).subtype(namedValues=NamedValues(("active", 1), ("inactive", 2), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokenRingDripLocalPortStatus.setDescription("This object reflects DRiP's status regarding                      the overall set of local ports assigned to\nthe TR-CRF VLAN associated with this entry.\nA value of active(1) indicates that at least\none local port is inserted/connected (i.e.,\nactive on the Token Ring). A value of inactive(2)\nindicates that none of the local ports are\ninserted/connected. All local ports are either\ndisabled or are simply not connected.")
tokenRingDripRemotePortStatus = MibTableColumn((0, 1, 11, 12, 1, 3), Integer().subtype(subtypeSpec=SingleValueConstraint(1,2,)).subtype(namedValues=NamedValues(("active", 1), ("inactive", 2), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokenRingDripRemotePortStatus.setDescription("This object reflects DRiP's status regarding                      any ports on remote systems. A value of\nactive(1) indicates that at least one remote\nport is inserted/connected (i.e., active on\nthe Token Ring). A value of inactive(2) indicates\nthat none of the remote ports are\ninserted/connected. All remote ports are either\ndisabled or are simply not connected.")
tokenRingDripRemotePortConfigured = MibTableColumn((0, 1, 11, 12, 1, 4), Integer().subtype(subtypeSpec=SingleValueConstraint(2,1,)).subtype(namedValues=NamedValues(("true", 1), ("false", 2), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokenRingDripRemotePortConfigured.setDescription("This object reflects whether or not DRiP has                      detected remote ports assigned to the TR-CRF\nVLAN associated with this entry. A value of\ntrue(1) indicates there is at least one port\non a remote system assigned to this TR-CRF VLAN.\nA value of false(2) indicates no remote ports\nare assigned to this TR-CRF VLAN.")
tokenRingDripDistributedCrf = MibTableColumn((0, 1, 11, 12, 1, 5), Integer().subtype(subtypeSpec=SingleValueConstraint(2,1,)).subtype(namedValues=NamedValues(("true", 1), ("false", 2), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokenRingDripDistributedCrf.setDescription("This object reflects whether DRiP considers the                      TR-CRF VLAN associated with this entry to be\ndistributed across systems. A value of true(1)\nindicates the TR-CRF is distributed. A value\nof false(2) indicates the TR-CRF is not\ndistributed.")
tokenRingDripBackupCrf = MibTableColumn((0, 1, 11, 12, 1, 6), Integer().subtype(subtypeSpec=SingleValueConstraint(2,1,)).subtype(namedValues=NamedValues(("true", 1), ("false", 2), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokenRingDripBackupCrf.setDescription("This object reflects whether or not the TR-CRF                      VLAN associated with this entry is configured\nas a backup TR-CRF. A value of true(1) indicates\nthe TR-CRF is a configured as a backup. A value\nof false(2) indicates the TR-CRF is not configured\nas a backup.")
tokenRingDripOwnerNodeID = MibTableColumn((0, 1, 11, 12, 1, 7), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokenRingDripOwnerNodeID.setDescription("The unique identifier  of the system that has                      advertised that it has local ports assigned to the\nTR-CRF VLAN associated with this entry.")
tokenRingPortSoftErrTable = MibTable((0, 1, 11, 14))
if mibBuilder.loadTexts: tokenRingPortSoftErrTable.setDescription("Table containing token ring soft error monitoring                       configuration information.")
tokenRingPortSoftErrEntry = MibTableRow((0, 1, 11, 14, 1))
if mibBuilder.loadTexts: tokenRingPortSoftErrEntry.setDescription("Entry containing token ring soft error monitoring                       configuration information for a particular port.")
tokenRingPortSoftErrThresh = MibTableColumn((0, 1, 11, 14, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255)).clone(100)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tokenRingPortSoftErrThresh.setDescription("The number of soft errors reported from a station                       connected to this port which, if exceeded, should\ncause a soft error exceeded trap to be issued.\nThe error counters being monitored and compared to\nthis threshold value are all of the error counters\nin the ringStationTable (see RFC 1513).")
tokenRingPortSoftErrReportInterval = MibTableColumn((0, 1, 11, 14, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)).clone(60)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tokenRingPortSoftErrReportInterval.setDescription("The sampling period, in seconds, in which each                        station connected to this port will be monitored\nfor excessive soft error reports. If a station\nreports more than tokenRingPortSoftErrThreshold\nerrors within the sampling period a trap will be\nissued to the management station(s). Setting a\nvalue of 0 will cause no traps to be sent for\nthis port.")
tokenRingPortSoftErrResetCounters = MibTableColumn((0, 1, 11, 14, 1, 3), Integer().subtype(subtypeSpec=SingleValueConstraint(2,1,)).subtype(namedValues=NamedValues(("noop", 1), ("reset", 2), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tokenRingPortSoftErrResetCounters.setDescription("When this object is set to reset(2), all Soft                       Error Monitoring related counters on this port\nwill be set to 0.")
tokenRingPortSoftErrLastCounterReset = MibTableColumn((0, 1, 11, 14, 1, 4), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokenRingPortSoftErrLastCounterReset.setDescription("The time (in hundredths of a second) since Soft                       Error Monitoring counters for this port were last\ncleared.")
tokenRingPortSoftErrEnable = MibTableColumn((0, 1, 11, 14, 1, 5), Integer().subtype(subtypeSpec=SingleValueConstraint(2,1,)).subtype(namedValues=NamedValues(("enabled", 1), ("disabled", 2), )).clone(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tokenRingPortSoftErrEnable.setDescription("Indicates whether the Token Ring Soft Error                      Monitoring feature is enabled on this port or not.\nThe detailed soft error statistics are provided\nby Token Ring RMON SNMP objects. Thus, if RMON\n(sysEnableRmon) is disabled(2) then the soft error\nstatistics will only be available from the CLI.")
multicastGrp = MibIdentifier((0, 1, 12))
mcastRouterTable = MibTable((0, 1, 12, 1))
if mibBuilder.loadTexts: mcastRouterTable.setDescription("A list of multicast router port entries. The                      number of entries is determined by the number of\nports in the system.")
mcastRouterEntry = MibTableRow((0, 1, 12, 1, 1)).setIndexNames((0, "CISCO-STACK-MIB", "mcastRouterModuleIndex"), (0, "CISCO-STACK-MIB", "mcastRouterPortIndex"))
if mibBuilder.loadTexts: mcastRouterEntry.setDescription("Entry containing multicast router information for                      a particular port.")
mcastRouterModuleIndex = MibTableColumn((0, 1, 12, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 16))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mcastRouterModuleIndex.setDescription("An index value that uniquely identifies the                      module where this port is located\n(see portModuleIndex).")
mcastRouterPortIndex = MibTableColumn((0, 1, 12, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mcastRouterPortIndex.setDescription("An index value that uniquely identifies this port                      within a module (see portIndex).")
mcastRouterAdminStatus = MibTableColumn((0, 1, 12, 1, 1, 3), Integer().subtype(subtypeSpec=SingleValueConstraint(1,3,)).subtype(namedValues=NamedValues(("routerPresent", 1), ("dynamic", 3), )).clone(3)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mcastRouterAdminStatus.setDescription("And indication of whether the presence of an IP                      multicast router on this port is to be determined\nstatically or dynamically. The value\nrouterPresent(1) indicates that the presence of a\nrouter is statically configured to be present.\nThe value dynamic(3) indicates the presence is to\nbe learned dynamically.")
mcastRouterOperStatus = MibTableColumn((0, 1, 12, 1, 1, 4), Integer().subtype(subtypeSpec=SingleValueConstraint(1,2,)).subtype(namedValues=NamedValues(("routerPresent", 1), ("noRouter", 2), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mcastRouterOperStatus.setDescription("An indication of whether an IP multicast router                      is present on this port.")
mcastEnableCgmp = MibScalar((0, 1, 12, 2), Integer().subtype(subtypeSpec=SingleValueConstraint(2,1,)).subtype(namedValues=NamedValues(("enabled", 1), ("disabled", 2), )).clone(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mcastEnableCgmp.setDescription("Indicates whether Cisco Group Management Protocol                      is enabled on the device or not. When CGMP is\nenabled in conjunction with Cisco routers running\nCGMP, only the required ports will participate in\nIP multicast groups.")
mcastEnableIgmp = MibScalar((0, 1, 12, 3), Integer().subtype(subtypeSpec=SingleValueConstraint(2,1,)).subtype(namedValues=NamedValues(("enabled", 1), ("disabled", 2), )).clone(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mcastEnableIgmp.setDescription("Indicates whether Internet Group Management                      Protocol is enabled on the device or not. When\nIGMP is enabled in conjunction with Cisco routers\nrunning CGMP, only the required ports will\nparticipate in IP multicast groups.")
mcastEnableRgmp = MibScalar((0, 1, 12, 4), Integer().subtype(subtypeSpec=SingleValueConstraint(2,1,)).subtype(namedValues=NamedValues(("enabled", 1), ("disabled", 2), )).clone(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mcastEnableRgmp.setDescription("Indicates whether Router Group Management                      Protocol is enabled on the device or not. When\nRGMP is enabled in conjunction with Cisco routers\nrunning RGMP, multicast data traffic is forwarded\nonly to those multicast routers that are\ninterested to receive that data traffic. IGMP\nsnooping feature must be enabled on the system\nto make RGMP feature operational.")
dnsGrp = MibIdentifier((0, 1, 13))
dnsEnable = MibScalar((0, 1, 13, 1), Integer().subtype(subtypeSpec=SingleValueConstraint(2,1,)).subtype(namedValues=NamedValues(("enabled", 1), ("disabled", 2), )).clone(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dnsEnable.setDescription("Indicates if the DNS feature is enabled or                      disabled.")
dnsServerTable = MibTable((0, 1, 13, 2))
if mibBuilder.loadTexts: dnsServerTable.setDescription("This table lists a maximum of 3 DNS servers.")
dnsServerEntry = MibTableRow((0, 1, 13, 2, 1)).setIndexNames((0, "CISCO-STACK-MIB", "dnsServerAddr"))
if mibBuilder.loadTexts: dnsServerEntry.setDescription("A DNS server table entry.")
dnsServerAddr = MibTableColumn((0, 1, 13, 2, 1, 1), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dnsServerAddr.setDescription("The IP address of a DNS server.")
dnsServerType = MibTableColumn((0, 1, 13, 2, 1, 2), Integer().subtype(subtypeSpec=SingleValueConstraint(3,2,1,)).subtype(namedValues=NamedValues(("invalid", 1), ("primary", 2), ("other", 3), ))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dnsServerType.setDescription("To add a new entry to the dnsServerTable, set                       this object to primary(2) or other(3) for an IP\naddress which is not already in the table. The\nprimary entry will be used first, if it is\nreachable. Otherwise, one of the other entries\nwill be used. Setting one entry to primary(2)\ncauses any previous primary entry to change to\nother(3). To remove an entry from the table, set\nthis object to invalid(1).")
dnsDomainName = MibScalar((0, 1, 13, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 127))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dnsDomainName.setDescription("DNS domain name.")
syslogGrp = MibIdentifier((0, 1, 14))
syslogServerTable = MibTable((0, 1, 14, 1))
if mibBuilder.loadTexts: syslogServerTable.setDescription("This table lists a maximum of 3 system log                      servers.")
syslogServerEntry = MibTableRow((0, 1, 14, 1, 1)).setIndexNames((0, "CISCO-STACK-MIB", "syslogServerAddr"))
if mibBuilder.loadTexts: syslogServerEntry.setDescription("A system log server table entry.")
syslogServerAddr = MibTableColumn((0, 1, 14, 1, 1, 1), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: syslogServerAddr.setDescription("The IP address of a system log Server.")
syslogServerType = MibTableColumn((0, 1, 14, 1, 1, 2), Integer().subtype(subtypeSpec=SingleValueConstraint(1,2,)).subtype(namedValues=NamedValues(("valid", 1), ("invalid", 2), ))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: syslogServerType.setDescription("To add/remove a new entry to the                      syslogServerTable, setting to invalid(2) removes\nthe corresponding entry from the\nsyslogServerTable. To add a new entry into\nsyslogServerTable, set this object to valid(1)\nfor an IP address which is not already in the\ntable.")
syslogConsoleEnable = MibScalar((0, 1, 14, 2), Integer().subtype(subtypeSpec=SingleValueConstraint(2,1,)).subtype(namedValues=NamedValues(("enabled", 1), ("disabled", 2), )).clone(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: syslogConsoleEnable.setDescription("Indicate whether the system log messages should                       be sent to console.")
syslogHostEnable = MibScalar((0, 1, 14, 3), Integer().subtype(subtypeSpec=SingleValueConstraint(2,1,)).subtype(namedValues=NamedValues(("enabled", 1), ("disabled", 2), )).clone(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: syslogHostEnable.setDescription("Indicate whether the system log messages should                      be sent to syslog servers.")
syslogMessageControlTable = MibTable((0, 1, 14, 4))
if mibBuilder.loadTexts: syslogMessageControlTable.setDescription("This table contains the information about what                      system log messages should be sent to syslog host,\nconsole, login session, and/or logged into the\ninternal buffer.")
syslogMessageControlEntry = MibTableRow((0, 1, 14, 4, 1)).setIndexNames((0, "CISCO-STACK-MIB", "syslogMessageFacility"))
if mibBuilder.loadTexts: syslogMessageControlEntry.setDescription("A system log message control table entry.")
syslogMessageFacility = MibTableColumn((0, 1, 14, 4, 1, 1), Integer().subtype(subtypeSpec=SingleValueConstraint(30,13,1,34,33,40,9,11,16,27,32,36,35,14,29,45,22,5,21,23,25,3,10,18,28,7,44,47,2,38,26,19,12,8,24,37,6,17,46,20,31,42,15,43,4,)).subtype(namedValues=NamedValues(("cdp", 1), ("spantree", 10), ("system", 11), ("tac", 12), ("tcp", 13), ("telnet", 14), ("tftp", 15), ("vtp", 16), ("vmps", 17), ("kernel", 18), ("filesys", 19), ("mcast", 2), ("drip", 20), ("pagp", 21), ("mgmt", 22), ("mls", 23), ("protfilt", 24), ("security", 25), ("radius", 26), ("udld", 27), ("gvrp", 28), ("cops", 29), ("dtp", 3), ("qos", 30), ("acl", 31), ("rsvp", 32), ("ld", 33), ("privatevlan", 34), ("ethc", 35), ("gl2pt", 36), ("callhome", 37), ("dhcpsnooping", 38), ("dvlan", 4), ("diags", 40), ("eou", 42), ("backup", 43), ("eoam", 44), ("webauth", 45), ("dom", 46), ("mvrp", 47), ("earl", 5), ("fddi", 6), ("ip", 7), ("pruning", 8), ("snmp", 9), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: syslogMessageFacility.setDescription("System log message facility.")
syslogMessageSeverity = MibTableColumn((0, 1, 14, 4, 1, 2), Integer().subtype(subtypeSpec=SingleValueConstraint(1,8,3,4,5,6,2,7,)).subtype(namedValues=NamedValues(("emergencies", 1), ("alerts", 2), ("critical", 3), ("errors", 4), ("warnings", 5), ("notification", 6), ("informational", 7), ("debugging", 8), ))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: syslogMessageSeverity.setDescription("System log message severity.")
syslogTimeStampOption = MibScalar((0, 1, 14, 5), Integer().subtype(subtypeSpec=SingleValueConstraint(2,1,)).subtype(namedValues=NamedValues(("enabled", 1), ("disabled", 2), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: syslogTimeStampOption.setDescription("Indicates whether syslog Time Stamp Option is                      enabled or not. If it is set to enabled(1), the\nTime Stamp will be in the beginning of each\nsyslog message.")
syslogTelnetEnable = MibScalar((0, 1, 14, 6), Integer().subtype(subtypeSpec=SingleValueConstraint(2,1,)).subtype(namedValues=NamedValues(("enabled", 1), ("disabled", 2), )).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: syslogTelnetEnable.setDescription("Indicate whether the system log messages should                       be sent to telnet sessions.")
ntpGrp = MibIdentifier((0, 1, 15))
ntpBcastClient = MibScalar((0, 1, 15, 1), Integer().subtype(subtypeSpec=SingleValueConstraint(2,1,)).subtype(namedValues=NamedValues(("enabled", 1), ("disabled", 2), )).clone(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ntpBcastClient.setDescription("Entry which tells if Cat5000 should act as a                      Broadcast client or not.")
ntpBcastDelay = MibScalar((0, 1, 15, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 999999)).clone(3000)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ntpBcastDelay.setDescription("Estimated Round trip time (in micro seconds) for                      NTP broadcasts. The range is from 1 to 999999.")
ntpClient = MibScalar((0, 1, 15, 3), Integer().subtype(subtypeSpec=SingleValueConstraint(2,1,)).subtype(namedValues=NamedValues(("enabled", 1), ("disabled", 2), )).clone(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ntpClient.setDescription("Entry which tells if the device can act as a NTP                      client (in a client-server configuration type).")
ntpServerTable = MibTable((0, 1, 15, 4))
if mibBuilder.loadTexts: ntpServerTable.setDescription("A list of NTP Server entries. This table lists a                      maximum of 10 Entries.")
ntpServerEntry = MibTableRow((0, 1, 15, 4, 1)).setIndexNames((0, "CISCO-STACK-MIB", "ntpServerAddress"))
if mibBuilder.loadTexts: ntpServerEntry.setDescription("Entry containing NTP information for a particular                      entry.")
ntpServerAddress = MibTableColumn((0, 1, 15, 4, 1, 1), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntpServerAddress.setDescription("Entry containing NTP Server's IP address.")
ntpServerType = MibTableColumn((0, 1, 15, 4, 1, 2), Integer().subtype(subtypeSpec=SingleValueConstraint(1,2,)).subtype(namedValues=NamedValues(("valid", 1), ("invalid", 2), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ntpServerType.setDescription("To add or remove an entry to ntpServerTable.                      Setting to 1 adds the entry and setting to 2\nclears the entry.")
ntpServerPublicKey = MibTableColumn((0, 1, 15, 4, 1, 3), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ntpServerPublicKey.setDescription("The key to be used when communicating with this                      server.\nA key with a value of zero indicates an invalid\nntpServerPublicKey. When the authentication\nfeature is enabled the system will not sync with\nthis server when ntpAuthenticationPublicKey\ndoesn't match with NTP Packet's public key.\n  or\nIf the ntpAuthenticationTrustedMode is trusted but\nencrypted message of ntpAuthenticationSecretKey\nwith NTP packet's data doesn't match with NTP\npacket's crypto checksum in the message\nauthentication mode (MAC).\n  or\nIf the ntpAuthenticationTrustedMode is untrusted.\n\nIn client mode NMP will not send request NTP\nPacket to the server when ntpServerPublicKey\ndoesn't match with any of the\nntpAuthenticationPublicKey in\nntpAuthenticationTable.\n  or\nIf the ntpAuthenticationTrustedMode is untrusted.")
ntpSummertimeStatus = MibScalar((0, 1, 15, 5), Integer().subtype(subtypeSpec=SingleValueConstraint(2,1,)).subtype(namedValues=NamedValues(("enabled", 1), ("disabled", 2), )).clone(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ntpSummertimeStatus.setDescription("Enabling or Disabling will set the clock ahead or                      behind 1 hour respectively.(daylight savings time\nin USA). This command gets active only in Summer\ntime.")
ntpSummerTimezoneName = MibScalar((0, 1, 15, 6), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 20))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ntpSummerTimezoneName.setDescription("Summertime time zone name for display purposes.")
ntpTimezoneName = MibScalar((0, 1, 15, 7), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 20))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ntpTimezoneName.setDescription("Time zone name for display purposes.")
ntpTimezoneOffsetHour = MibScalar((0, 1, 15, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-12, 12))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ntpTimezoneOffsetHour.setDescription("Time offset (Hour) from Greenwich Mean Time.")
ntpTimezoneOffsetMinute = MibScalar((0, 1, 15, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 59))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ntpTimezoneOffsetMinute.setDescription("Time offset (Minutes) from Greenwich Mean Time.")
ntpAuthenticationEnable = MibScalar((0, 1, 15, 10), Integer().subtype(subtypeSpec=SingleValueConstraint(2,1,)).subtype(namedValues=NamedValues(("enabled", 1), ("disabled", 2), )).clone(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ntpAuthenticationEnable.setDescription("Specifies if authentication feature is enabled or                      disabled in the system.")
ntpAuthenticationTable = MibTable((0, 1, 15, 11))
if mibBuilder.loadTexts: ntpAuthenticationTable.setDescription("A list of NTP Authentication Key entries.                      This table lists a maximum of 10 Entries")
ntpAuthenticationEntry = MibTableRow((0, 1, 15, 11, 1)).setIndexNames((0, "CISCO-STACK-MIB", "ntpAuthenticationPublicKey"))
if mibBuilder.loadTexts: ntpAuthenticationEntry.setDescription("An entry in the ntpAuthenticationTable,                      containing values of an NTP authentication key\npair.")
ntpAuthenticationPublicKey = MibTableColumn((0, 1, 15, 11, 1, 1), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntpAuthenticationPublicKey.setDescription("A unique value to identify the authentication                      key. When the authentication feature is enabled\nand the ntpAuthenticationPublicKey matches with\nthe NTP packet's public key then this entry is\nused.")
ntpAuthenticationSecretKey = MibTableColumn((0, 1, 15, 11, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ntpAuthenticationSecretKey.setDescription("An arbitrary string known as the secret key used                      for encrypting of the NTP packet. This key is\nuseful when the ntpAuthenticationTrustedMode is\nset to trusted(1).\nThis key has to be specified when this\nntpAuthenticationEntry is created. When reading\nthis object, it will return empty string.")
ntpAuthenticationTrustedMode = MibTableColumn((0, 1, 15, 11, 1, 3), Integer().subtype(subtypeSpec=SingleValueConstraint(2,1,)).subtype(namedValues=NamedValues(("trusted", 1), ("untrusted", 2), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ntpAuthenticationTrustedMode.setDescription("A flag indicates whether the                      ntpAuthenticationSecretKey is trusted or\nuntrusted. Setting a ntpAuthenticationSecretKey\nto trusted(1) allows authentication on NTP\npackets containing this key, and setting a\nntpAuthenticationSecretKey to untrusted(2) drops\nall NTP packets containing this key.")
ntpAuthenticationType = MibTableColumn((0, 1, 15, 11, 1, 4), Integer().subtype(subtypeSpec=SingleValueConstraint(1,2,)).subtype(namedValues=NamedValues(("valid", 1), ("invalid", 2), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ntpAuthenticationType.setDescription("To add or remove an entry to                      ntpAuthenticationTable. Setting to 1 adds the\nentry and setting to 2 clears the entry.")
tacacsGrp = MibIdentifier((0, 1, 16))
tacacsLoginAuthentication = MibScalar((0, 1, 16, 1), Integer().subtype(subtypeSpec=SingleValueConstraint(2,4,1,3,)).subtype(namedValues=NamedValues(("enabled", 1), ("disabled", 2), ("enabledForTelnetOnly", 3), ("enabledForConsoleOnly", 4), )).clone(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tacacsLoginAuthentication.setDescription("Indicates whether the login authentication using                      the TACACS+ feature is enabled or disabled for\nconsole sessions and/or telnet sessions.\n\nSetting this object to enabled(1), the login\nauthentication using the TACACS+ feature is\nenabled for both telnet and console sessions.\n\nSetting this object to disabled(2), the login\nauthentication using the TACACS+ feature is\ndisabled for both telnet and console sessions.\n\nSetting this object to enabledForTelnetOnly(3),\nthe login authentication using the TACACS+\nfeature is enabled only for telnet sessions, but\ndisabled for console sessions.\n\nSetting this object to enabledForConsoleOnly(4),\nthe login authentication using the TACACS+\nfeature is enabled only for console sessions,\nbut disabled for telnet sessions.\n\nThis object is deprecated and replaced by\ncacPriorityTable in CISCO-AAA-CLIENT-MIB.")
tacacsEnableAuthentication = MibScalar((0, 1, 16, 2), Integer().subtype(subtypeSpec=SingleValueConstraint(2,4,1,3,)).subtype(namedValues=NamedValues(("enabled", 1), ("disabled", 2), ("enabledForTelnetOnly", 3), ("enabledForConsoleOnly", 4), )).clone(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tacacsEnableAuthentication.setDescription("Indicates whether the enable authentication using                      the TACACS+ feature is enabled or disabled for\nconsole sessions and/or telnet sessions based on\nthe value.\n\nSetting this object to enabled(1), the enable\nauthentication using the TACACS+ feature is\nenabled for both telnet and console sessions.\n\nSetting this object to disabled(2), the enable\nauthentication using the TACACS+ feature is\ndisabled for both telnet and console sessions.\n\nSetting this object to enabledForTelnetOnly(3),\nthe enable authentication using the TACACS+\nfeature is enabled only for telnet sessions, but\ndisabled for console sessions.\n\nSetting this object to enabledForConsoleOnly(4),\nthe enable authentication using the TACACS+\nfeature is enabled only for console sessions,\nbut disabled for telnet sessions.\n\nThis object is deprecated and replaced by\ncacPriorityTable in CISCO-AAA-CLIENT-MIB.")
tacacsLocalLoginAuthentication = MibScalar((0, 1, 16, 3), Integer().subtype(subtypeSpec=SingleValueConstraint(2,4,1,3,)).subtype(namedValues=NamedValues(("enabled", 1), ("disabled", 2), ("enabledForTelnetOnly", 3), ("enabledForConsoleOnly", 4), )).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tacacsLocalLoginAuthentication.setDescription("Indicates whether the login authentication using                      local password is enabled or disabled for Console\nsession and/or Telnet session based on the value.\n\nSetting this object to enabled(1),the login\nauthentication using local password is enabled for\nboth telnet and console sessions.\n\nSetting this object to disabled(2), the login\nauthentication using local password is disabled\nfor both telnet and console sessions.\n\nSetting this object to enabledForTelnetOnly(3),\nthe login authentication using local password is\nenabled only for telnet sessions, but disabled for\nconsole session.\n\nSetting this object to enabledForConsoleOnly(4),\nthe login authentication using local password is\nenabled only for console session, but disabled for\ntelnet sessions.\n\nThis object is deprecated and replaced by\ncacPriorityTable in CISCO-AAA-CLIENT-MIB.")
tacacsLocalEnableAuthentication = MibScalar((0, 1, 16, 4), Integer().subtype(subtypeSpec=SingleValueConstraint(2,4,1,3,)).subtype(namedValues=NamedValues(("enabled", 1), ("disabled", 2), ("enabledForTelnetOnly", 3), ("enabledForConsoleOnly", 4), )).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tacacsLocalEnableAuthentication.setDescription("Indicates whether the enable authentication using                      local password is enabled or disabled for Console\nsession and/or Telnet sessions.\n\nSetting this object to enabled(1),the enable\nauthentication using local password is enabled for\nboth telnet and console sessions.\n\nSetting this object to disabled(2), the enable\nauthentication using local password is disabled\nfor both telnet and console sessions.\n\nSetting this object to enabledForTelnetOnly(3),\nthe enable authentication using local password is\nenabled only for telnet sessions, but disabled for\nconsole sessions.\n\nSetting this object to enabledForConsoleOnly(4),\nthe enable authentication using local password is\nenabled only for console sessions, but disabled\nfor telnet sessions.\n\nThis object is deprecated and replaced by\ncacPriorityTable in CISCO-AAA-CLIENT-MIB.")
tacacsNumLoginAttempts = MibScalar((0, 1, 16, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 10)).clone(3)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tacacsNumLoginAttempts.setDescription("The number of login attempts allowed.\nThis object is deprecated and replaced by\ncacMaxLoginAttempt in CISCO-AAA-CLIENT-MIB.")
tacacsDirectedRequest = MibScalar((0, 1, 16, 6), Integer().subtype(subtypeSpec=SingleValueConstraint(2,1,)).subtype(namedValues=NamedValues(("enabled", 1), ("disabled", 2), )).clone(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tacacsDirectedRequest.setDescription("Indicates whether the directed-request feature of                      TACACS+ is enabled or disabled.")
tacacsTimeout = MibScalar((0, 1, 16, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255)).clone(5)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tacacsTimeout.setDescription("The duration in seconds to wait for a response                      from the TACACS+ server host.\n\nThis object is deprecated and replaced by\ncacLockoutPeriodExt in CISCO-AAA-CLIENT-MIB.")
tacacsAuthKey = MibScalar((0, 1, 16, 8), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 100))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tacacsAuthKey.setDescription("The key used in encrypting the packets passed                      between the TACACS+ server and the client. This\nkey must match the one configured on the server.\n\nNote that this item is only accessible when using\nthe community string defined in sysCommunityRwa.")
tacacsServerTable = MibTable((0, 1, 16, 9))
if mibBuilder.loadTexts: tacacsServerTable.setDescription("This table lists a maximum of 3 TACACS+ servers.")
tacacsServerEntry = MibTableRow((0, 1, 16, 9, 1)).setIndexNames((0, "CISCO-STACK-MIB", "tacacsServerAddr"))
if mibBuilder.loadTexts: tacacsServerEntry.setDescription("A TACACS+ server table entry.")
tacacsServerAddr = MibTableColumn((0, 1, 16, 9, 1, 1), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tacacsServerAddr.setDescription("The IP address of a TACACS+ Server.")
tacacsServerType = MibTableColumn((0, 1, 16, 9, 1, 2), Integer().subtype(subtypeSpec=SingleValueConstraint(3,2,1,)).subtype(namedValues=NamedValues(("invalid", 1), ("primary", 2), ("other", 3), ))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tacacsServerType.setDescription("To add a new entry to the tacacsServerTable, set                      this object to primary(2) or other(3) for an IP\naddress which is not already in the table. The\nprimary entry will be used first, if it is\nreachable. Otherwise, one of the other entries\nwill be used. Setting one entry to primary(2)\ncauses any previous primary entry to change to\nother(3). To remove an entry from the table, set\nthis object to invalid(1).")
ipPermitListGrp = MibIdentifier((0, 1, 17))
ipPermitEnable = MibScalar((0, 1, 17, 1), Integer().subtype(subtypeSpec=SingleValueConstraint(2,4,1,3,)).subtype(namedValues=NamedValues(("enabled", 1), ("disabled", 2), ("enabledForTelnetOnly", 3), ("enabledForSnmpOnly", 4), )).clone(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipPermitEnable.setDescription("This is deprecated and replaced by                      ipPermitAccessTypeEnable.\n\nIndicate whether the IP permit feature is enabled\nor disabled for Telnet and/or SNMP.\n\nSetting this object to enabled(1), the IP permit\nfeature is enabled for both telnet and SNMP.\n\nSetting this object to disabled(2), the IP permit\nfeature is disabled for both telnet and SNMP.\n\nSetting this object to enabledForTelnetOnly(3),\nthe IP permit feature is enabled for Telnet, but\ndisabled for the rest.\n\nSetting this object to enabledForSnmpOnly(4), the\nIP permit feature is enabled for SNMP, but\ndisabled for the rest.")
ipPermitListTable = MibTable((0, 1, 17, 2))
if mibBuilder.loadTexts: ipPermitListTable.setDescription("This table lists a maximum of 100 IP Addresses                      with net masks of IP permit hosts. If\nipPermitEnable is set to enabled(1), the system\nwill only accept inbound accesses which come from\nthe configured hosts with their permit access\ntypes in this table.")
ipPermitListEntry = MibTableRow((0, 1, 17, 2, 1)).setIndexNames((0, "CISCO-STACK-MIB", "ipPermitAddress"), (0, "CISCO-STACK-MIB", "ipPermitMask"))
if mibBuilder.loadTexts: ipPermitListEntry.setDescription("A IP permit list table entry.")
ipPermitAddress = MibTableColumn((0, 1, 17, 2, 1, 1), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipPermitAddress.setDescription("The IP address of a IP permit host.")
ipPermitMask = MibTableColumn((0, 1, 17, 2, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipPermitMask.setDescription("The IP net mask of a IP permit host.")
ipPermitType = MibTableColumn((0, 1, 17, 2, 1, 3), Integer().subtype(subtypeSpec=SingleValueConstraint(1,2,)).subtype(namedValues=NamedValues(("valid", 1), ("invalid", 2), ))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipPermitType.setDescription("Setting this object to invalid(2), removes the                      corresponding entry from the ipPermitListTable. To\nadd a new entry into ipPermitListTable, set this\nobject to valid(1), for an IP address and IP net\nmask which are not already in the table.")
ipPermitAccessType = MibTableColumn((0, 1, 17, 2, 1, 4), Bits().subtype(namedValues=NamedValues(("telnet", 0), ("snmp", 1), ("ssh", 2), ("http", 3), )).clone(("telnet","snmp","ssh","http",))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipPermitAccessType.setDescription("The IP access type of a IP permit host.                      At least one access type has to be set.")
ipPermitTelnetConnectLimit = MibTableColumn((0, 1, 17, 2, 1, 5), Unsigned32().clone(0)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipPermitTelnetConnectLimit.setDescription("Indicates the telnet connection limit that                         will be applied when accepting new telnet \nconnections for a specific host. A value of \nzero means no limit will be applied for telnet \nconnections.\n\n	Setting this object to a non-zero value will\n turn on the 'telnet' bit in the corresponding \n ipPermitAccessType. Turnning off the 'telnet' \n bit in the corresponding ipPermitAccessType will\n reset this ipPermitTelnetConnectLimit value to\n zero.")
ipPermitSshConnectLimit = MibTableColumn((0, 1, 17, 2, 1, 6), Unsigned32().clone(0)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipPermitSshConnectLimit.setDescription("Indicates the ssh connection limit that will        			be applied when accepting new ssh connections \nfor a specific host. A value of zero means no \nlimit will be applied for ssh connections.\n\nSetting this object to a non-zero value will\nturn on the 'ssh' bit in the corresponding \nipPermitAccessType. Turnning off the 'ssh' bit \nin the corresponding ipPermitAccessType will\nreset this ipPermitSshConnectLimit value to\nzero.")
ipPermitDeniedListTable = MibTable((0, 1, 17, 3))
if mibBuilder.loadTexts: ipPermitDeniedListTable.setDescription("This table lists up to 10 the most recently                      denied IP addresses with the access type.")
ipPermitDeniedListEntry = MibTableRow((0, 1, 17, 3, 1)).setIndexNames((0, "CISCO-STACK-MIB", "ipPermitDeniedAddress"))
if mibBuilder.loadTexts: ipPermitDeniedListEntry.setDescription("A IP permit denied list table entry.")
ipPermitDeniedAddress = MibTableColumn((0, 1, 17, 3, 1, 1), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipPermitDeniedAddress.setDescription("The IP address of a IP permit denied access.")
ipPermitDeniedAccess = MibTableColumn((0, 1, 17, 3, 1, 2), Integer().subtype(subtypeSpec=SingleValueConstraint(4,2,3,1,)).subtype(namedValues=NamedValues(("telnet", 1), ("snmp", 2), ("ssh", 3), ("http", 4), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipPermitDeniedAccess.setDescription("The denied access type.")
ipPermitDeniedTime = MibTableColumn((0, 1, 17, 3, 1, 3), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipPermitDeniedTime.setDescription("The time (in hundredths of a second) since the IP                      permit denied access happens.")
ipPermitAccessTypeEnable = MibScalar((0, 1, 17, 4), Bits().subtype(namedValues=NamedValues(("telnet", 0), ("snmp", 1), ("ssh", 2), ("http", 3), )).clone(())).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipPermitAccessTypeEnable.setDescription("This is to replace ipPermitEnable.                      Indicates whether the IP permit feature is\nenabled or disabled for Telnet, SNMP, ssh and\nhttp. If a bit is set the coresponding feature is\nenabled. If a bit is not set the coresponding\nfeature is disabled.")
portChannelGrp = MibIdentifier((0, 1, 18))
portChannelTable = MibTable((0, 1, 18, 1))
if mibBuilder.loadTexts: portChannelTable.setDescription("A list of port channel entries. The number of                      entries is determined by the number of ports in\nthe system which support the Ethernet Channelling\nfeature.\n\nThis table is deprecated and replaced by\npagpEtherChannelTable in CISCO-PAGP-MIB and\ndot3adAggTable in IEEE8023-LAG-MIB.")
portChannelEntry = MibTableRow((0, 1, 18, 1, 1)).setIndexNames((0, "CISCO-STACK-MIB", "portChannelModuleIndex"), (0, "CISCO-STACK-MIB", "portChannelPortIndex"))
if mibBuilder.loadTexts: portChannelEntry.setDescription("Entry containing information for a particular                      port on a module.")
portChannelModuleIndex = MibTableColumn((0, 1, 18, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 16))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portChannelModuleIndex.setDescription("An index value that uniquely identifies the                      module where this port is located.")
portChannelPortIndex = MibTableColumn((0, 1, 18, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portChannelPortIndex.setDescription("An index value that uniquely identifies this port                      within a module (see portIndex).")
portChannelPorts = MibTableColumn((0, 1, 18, 1, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 8))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portChannelPorts.setDescription("The set of ports on a module channelling                      together. Each Octet within the value of this\nobject specifies a set of eight ports, with the\nfirst octet specifying ports 1 through 8, the\nsecond octet specifying ports 9 through 16, etc.\nWithin each octet, the most significant bit\nrepresents the lowest numbered port, and the\nleast significant bit rep resents the highest\nnumbered port. Thus, each port is represented by\na single bit within the value of this object. If\nthat bit has a value of `1' then that port is\nincluded in the set of channel ports. The default\nvalue of this object is a string which only has a\nvalue of `1' on its own port.")
portChannelAdminStatus = MibTableColumn((0, 1, 18, 1, 1, 4), Integer().subtype(subtypeSpec=SingleValueConstraint(1,2,4,3,5,6,)).subtype(namedValues=NamedValues(("on", 1), ("off", 2), ("desirable", 3), ("auto", 4), ("desirableSilent", 5), ("autoSilent", 6), )).clone(4)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portChannelAdminStatus.setDescription("Indicates the administrative status set on the                      channel ports. If the status is set to on(1), the\nchannelling is enabled. If the status is set to\noff(2), the channelling is disabled. If the status\nis set to desirable(3), the port initiates a pagp\nnegotiation request to become a channel and will\nbecome a channel if the far end agrees. If the\nstatus is set to auto(4), the port does not\ninitiate a request to become a channel but will do\nso if it receives a request to become a channel\nfrom the far end. If the status is set to\ndesirableSilent(5), the port initiates a pagp\nnegotiation request to become a channel and will\nbecome a channel if the far end agrees. If the\nport doesn't receive any packets from far end,\nthen  after some timeout period the port forms a\nchannel by itself. If the status is set to\nautoSilent(6), the port does not initiate a\nrequest to become a channel, but will do so if it\nreceives a request to become a channel from the\nfar end. If the port doesn't receive any request,\nthen after some timeout period the port forms a\nchannel by itself.")
portChannelOperStatus = MibTableColumn((0, 1, 18, 1, 1, 5), Integer().subtype(subtypeSpec=SingleValueConstraint(1,2,)).subtype(namedValues=NamedValues(("channelling", 1), ("notChannelling", 2), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portChannelOperStatus.setDescription("Indicates whether the ports current channelling                      operational status is channel or not.")
portChannelNeighbourDeviceId = MibTableColumn((0, 1, 18, 1, 1, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readonly")
if mibBuilder.loadTexts: portChannelNeighbourDeviceId.setDescription("Indicates the neighbors device id.")
portChannelNeighbourPortId = MibTableColumn((0, 1, 18, 1, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portChannelNeighbourPortId.setDescription("Indicates the neighbor ports' Id.")
portChannelProtInPackets = MibTableColumn((0, 1, 18, 1, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portChannelProtInPackets.setDescription("Indicates the number of protocol packets received                      on the ports.")
portChannelProtOutPackets = MibTableColumn((0, 1, 18, 1, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portChannelProtOutPackets.setDescription("Indicates the number of protocol packets                      transmitted on the ports.")
portChannelIfIndex = MibTableColumn((0, 1, 18, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portChannelIfIndex.setDescription("The value of the instance of the ifIndex object                      defined in MIB-II, for the interface corresponding\nto the channel which the port belongs to. This\nobject will have a non zero value if its\nportChannelOperStatus is channelling and the link\nof this port is up.")
portCpbGrp = MibIdentifier((0, 1, 19))
portCpbTable = MibTable((0, 1, 19, 1))
if mibBuilder.loadTexts: portCpbTable.setDescription("A list of port capability entries. The number of                      entries is determined by the number of modules in\nthe chassis and the number of ports on each\nmodule.")
portCpbEntry = MibTableRow((0, 1, 19, 1, 1)).setIndexNames((0, "CISCO-STACK-MIB", "portCpbModuleIndex"), (0, "CISCO-STACK-MIB", "portCpbPortIndex"))
if mibBuilder.loadTexts: portCpbEntry.setDescription("Entry containing port capability information for                      a particular port on a module.")
portCpbModuleIndex = MibTableColumn((0, 1, 19, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 16))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portCpbModuleIndex.setDescription("An index value that uniquely identifies the                      module where this port is located (see\nportModuleIndex).")
portCpbPortIndex = MibTableColumn((0, 1, 19, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portCpbPortIndex.setDescription("An index value that uniquely identifies this port                      within a module (see portIndex).")
portCpbSpeed = MibTableColumn((0, 1, 19, 1, 1, 3), Bits().subtype(namedValues=NamedValues(("auto", 0), ("mbps4", 1), ("mbps1dot544", 10), ("mbps2", 11), ("mbps2dot048", 12), ("kps64", 13), ("mbps10000", 14), ("mbps10", 2), ("mbps16", 3), ("mbps45", 4), ("mbps100", 5), ("mbps155", 6), ("mbps400", 7), ("mbps622", 8), ("mbps1000", 9), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portCpbSpeed.setDescription("Indicates the port speed capability of a port.")
portCpbDuplex = MibTableColumn((0, 1, 19, 1, 1, 4), Bits().subtype(namedValues=NamedValues(("half", 0), ("full", 1), ("auto", 2), ("hdx", 3), ("fdx", 4), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portCpbDuplex.setDescription("Indicates the duplex capability of a port.                      The fdx(4) is specially for tokenring full-duplex\nand hdx(3) is specially for tokenring\nhalf-duplex.")
portCpbTrunkEncapsulationType = MibTableColumn((0, 1, 19, 1, 1, 5), Bits().subtype(namedValues=NamedValues(("lane", 0), ("dot10", 1), ("dot1Q", 2), ("isl", 3), ("negotiate", 4), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portCpbTrunkEncapsulationType.setDescription("Indicates the VLAN encapsulation capability of a                      port, The dot10(1) is for 801.10 and dot1q(2) is\nfor 801.1Q.")
portCpbTrunkMode = MibTableColumn((0, 1, 19, 1, 1, 6), Bits().subtype(namedValues=NamedValues(("on", 0), ("off", 1), ("desirable", 2), ("auto", 3), ("onNoNegotiate", 4), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portCpbTrunkMode.setDescription("Indicates the trunk capability of a port.")
portCpbChannel = MibTableColumn((0, 1, 19, 1, 1, 7), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portCpbChannel.setDescription("Indicates the channelling capability of a port.")
portCpbBroadcastSuppression = MibTableColumn((0, 1, 19, 1, 1, 8), Bits().subtype(namedValues=NamedValues(("pps", 0), ("percentage", 1), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portCpbBroadcastSuppression.setDescription("Indicates the broadcast suppression capability of                      a port. The pps(0) is for ports capable of\nspecifying suppression in packets per second and\npercentage(1) is for ports capable of specifying\nsuppression in terms of percentage of bandwidth.")
portCpbFlowControl = MibTableColumn((0, 1, 19, 1, 1, 9), Bits().subtype(namedValues=NamedValues(("receiveOff", 0), ("receiveOn", 1), ("receiveDesired", 2), ("sendOff", 3), ("sendOn", 4), ("sendDesired", 5), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portCpbFlowControl.setDescription("Indicates the flow control capability of a port.")
portCpbSecurity = MibTableColumn((0, 1, 19, 1, 1, 10), Integer().subtype(subtypeSpec=SingleValueConstraint(1,2,)).subtype(namedValues=NamedValues(("yes", 1), ("no", 2), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portCpbSecurity.setDescription("Indicates whether a port supports security.")
portCpbVlanMembership = MibTableColumn((0, 1, 19, 1, 1, 11), Bits().subtype(namedValues=NamedValues(("static", 0), ("dynamic", 1), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portCpbVlanMembership.setDescription("Indicates the vlan membership capability of a                      port.")
portCpbPortfast = MibTableColumn((0, 1, 19, 1, 1, 12), Integer().subtype(subtypeSpec=SingleValueConstraint(1,2,)).subtype(namedValues=NamedValues(("yes", 1), ("no", 2), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portCpbPortfast.setDescription("Indicates whether a port supports portfast.")
portCpbUdld = MibTableColumn((0, 1, 19, 1, 1, 13), Integer().subtype(subtypeSpec=SingleValueConstraint(1,2,)).subtype(namedValues=NamedValues(("yes", 1), ("no", 2), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portCpbUdld.setDescription("Indicates whether the port is capable of UDLD                      (UniDirectional Link Detection) or not.")
portCpbInlinePower = MibTableColumn((0, 1, 19, 1, 1, 14), Bits().subtype(namedValues=NamedValues(("auto", 0), ("on", 1), ("off", 2), ("static", 3), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portCpbInlinePower.setDescription("Indicate the inline power capability of a port.                      'auto' denotes the ability that the switch\nautomatically determines whether or not power\nshould be provided. 'on' denotes the ability to\nmanually turn on inline power.\n'off' denotes the ability to manually turn off\ninline power. 'static' denotes the ability to\npreallocate power for a port.")
portCpbAuxiliaryVlan = MibTableColumn((0, 1, 19, 1, 1, 15), Bits().subtype(namedValues=NamedValues(("vlanNo", 0), ("untagged", 1), ("dot1p", 2), ("none", 3), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portCpbAuxiliaryVlan.setDescription("Indicate the voice vlan capability of a port.")
portCpbSpan = MibTableColumn((0, 1, 19, 1, 1, 16), Bits().subtype(namedValues=NamedValues(("source", 0), ("destination", 1), ("reflector", 2), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portCpbSpan.setDescription("Indicates port span capabilities.                      source(0) denotes the capability of being SPAN\nsource destination(1) denotes the capability of\nbeing SPAN destination, reflector(2) denotes the\ncapability of being SPAN reflector.")
portCpbCosRewrite = MibTableColumn((0, 1, 19, 1, 1, 17), Integer().subtype(subtypeSpec=SingleValueConstraint(1,2,)).subtype(namedValues=NamedValues(("yes", 1), ("no", 2), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portCpbCosRewrite.setDescription("Indicates whether a port supports CoS rewrite.")
portCpbTosRewrite = MibTableColumn((0, 1, 19, 1, 1, 18), Bits().subtype(namedValues=NamedValues(("dscp", 0), ("ipPrecedence", 1), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portCpbTosRewrite.setDescription("Indicates the ToS rewrite capability of a port.                      dscp(0) denotes the port capability to classify\npackets according to the DSCP.\nipPrecedence(1) denotes the port capability to\nclassify packets according to the IP Precedence.")
portCpbCopsGrouping = MibTableColumn((0, 1, 19, 1, 1, 19), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portCpbCopsGrouping.setDescription("The set of ports on a module that are configured                      together as far as the Differentiated Services\nCops feature is concerned. Each Octet within the\nvalue of this object specifies a set of eight\nports, with the first octet specifying ports 1\nthrough 8, the second octet specifying ports 9\nthrough 16, etc. Within each octet, the most\nsignificant bit represents the lowest numbered\nport, and the least significant bit represents\nthe highest numbered port. Thus, each port is\nrepresented by a single bit within the value of\nthis object. If that bit has a value of `1' then\nthat port is included in the set of Cops\ngrouping.")
portCpbDot1x = MibTableColumn((0, 1, 19, 1, 1, 20), Integer().subtype(subtypeSpec=SingleValueConstraint(1,2,)).subtype(namedValues=NamedValues(("yes", 1), ("no", 2), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portCpbDot1x.setDescription("Indicates whether a port supports 802.1x.")
portCpbIgmpFilter = MibTableColumn((0, 1, 19, 1, 1, 21), Integer().subtype(subtypeSpec=SingleValueConstraint(1,2,)).subtype(namedValues=NamedValues(("yes", 1), ("no", 2), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portCpbIgmpFilter.setDescription("Indicates whether a port supports IGMP filter.")
portTopNGrp = MibIdentifier((0, 1, 20))
portTopNControlTable = MibTable((0, 1, 20, 1))
if mibBuilder.loadTexts: portTopNControlTable.setDescription("A list of top N port control entries.")
portTopNControlEntry = MibTableRow((0, 1, 20, 1, 1)).setIndexNames((0, "CISCO-STACK-MIB", "portTopNControlIndex"))
if mibBuilder.loadTexts: portTopNControlEntry.setDescription("A set of parameters that control the creation of                      a report of the top N ports according to several\nmetrics.\nFor example, an instance of the portTopNDuration\nobject might be named portTopNDuration.3")
portTopNControlIndex = MibTableColumn((0, 1, 20, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 5))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portTopNControlIndex.setDescription("An index that uniquely identifies an entry                      in the portTopNControl table. Each such\nentry defines one top N report.")
portTopNRateBase = MibTableColumn((0, 1, 20, 1, 1, 2), Integer().subtype(subtypeSpec=SingleValueConstraint(2,6,4,1,5,3,7,)).subtype(namedValues=NamedValues(("portTopNUtilization", 1), ("portTopNIOOctets", 2), ("portTopNIOPkts", 3), ("portTopNIOBroadcastPkts", 4), ("portTopNIOMulticastPkts", 5), ("portTopNInErrors", 6), ("portTopNBufferOverflow", 7), )).clone(1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: portTopNRateBase.setDescription("The variable for all ports in this system                      based on which portTopNTable/report is ordered.\n\nThis object may not be modified if the associated\nportTopNStatus object is equal to active(1).")
portTopNType = MibTableColumn((0, 1, 20, 1, 1, 3), Integer().subtype(subtypeSpec=SingleValueConstraint(4,3,7,8,6,1,5,2,)).subtype(namedValues=NamedValues(("portTopNAllPorts", 1), ("portTopNEthernet", 2), ("portTopNFastEthernet", 3), ("portTopNGigaEthernet", 4), ("portTopNTokenRing", 5), ("portTopNFDDI", 6), ("portTopNAllEthernetPorts", 7), ("portTopN10GigaEthernet", 8), )).clone(1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: portTopNType.setDescription("The sampling port type.\nThis object may not be modified if the associated\nportTopNStatus object is equal to active(1).")
portTopNMode = MibTableColumn((0, 1, 20, 1, 1, 4), Integer().subtype(subtypeSpec=SingleValueConstraint(2,1,)).subtype(namedValues=NamedValues(("portTopNForeground", 1), ("portTopNBackground", 2), )).clone(2)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: portTopNMode.setDescription("The running mode of this portTopN control entry.                      portTopNForeground (1) means when\nportTopNTimeRemaining reaches to 0, the report\nwill show on the CLI at once and it won't be kept\nin the portTopNTable. portTopNBackground (2) means\nthe report will not show on the CLI it will be\nkept in the portTopNTable.\n\nThis object may not be modified if the associated\nportTopNStatus object is equal to active(1).")
portTopNReportStatus = MibTableColumn((0, 1, 20, 1, 1, 5), Integer().subtype(subtypeSpec=SingleValueConstraint(2,1,)).subtype(namedValues=NamedValues(("progressing", 1), ("ready", 2), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portTopNReportStatus.setDescription("The report status of this portTopN control entry.                      Progressing (1) means that the report of this\nportTopN control entry is still in progress. The\nmanagement station can poll this mib object to\ncheck the report data is available or not.\nReady (2) means the report is available.")
portTopNDuration = MibTableColumn((0, 1, 20, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0,0),ValueRangeConstraint(10,999),)).clone(30)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: portTopNDuration.setDescription("The sampling interval in seconds during which                      statistics are collected for this report.\n\nWhen this is set a value and the corresponding\nportTopNControlEntry is valid, the\nportTopNTimeRemaining object shall be set to the\nsame value.\nportTopNTimeRemaining starts at the same value as\nportTopNDuration and counts down as the collection\ngoes on.\n\nIf this object is set to be zero, it will do the\ncollection immediately. And the collecting report\nvalue should be the absolute counter value.")
portTopNTimeRemaining = MibTableColumn((0, 1, 20, 1, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portTopNTimeRemaining.setDescription("The number of seconds left in the report                      currently being collected. When portTopNDuration\nobject is modified by the management station, a\nnew collection is started, possibly aborting a\ncurrently running report. The new value is used as\nthe requested duration of this report, which is\nloaded from the associated portTopNDuration\nobject.\n\nWhen this object is a non-zero value, any\nassociated portTopNEntries shall be made\ninaccessible by the monitor.\n\nWhile the value of this object is non-zero and the\ncorresponding portTopNControlENtry is valid, it\ndecrements by one per second until it reaches\nzero. During this time, all associated\nportTopNEntries shall remain inaccessible. At\nthe time that this object decrements to zero, the\nreport is made accessible in the portTopNTable.\nThus, the portTopN table is to be created only at\nthe end of the collection interval.")
portTopNStartTime = MibTableColumn((0, 1, 20, 1, 1, 8), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portTopNStartTime.setDescription("The value of sysUpTime when this top N report was                      last started. In other words, this is the time\nthat the associated portTopNTimeRemaining object\nwas modified to start the requested report.")
portTopNRequestedSize = MibTableColumn((0, 1, 20, 1, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)).clone(20)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: portTopNRequestedSize.setDescription("The maximum number of ports requested for the top                      N entry.\n\nWhen this object is created or modified, the value\nof portTopNGrantedSize is set as closely to this\nobject as is possible for the particular\nimplementation and available resources.\nValid value for this object is 1 to maximum number\nof physical ports. The default value is 20 ports.")
portTopNGrantedSize = MibTableColumn((0, 1, 20, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portTopNGrantedSize.setDescription("The maximum number of ports in the top N table.                      When the associated portTopNRequestedSize object\nis created or modified, the value of this object\nshould be set as closely to the requested value as\nis possible for the particular implementation and\navailable resources. The value must not be lowered\nexcept as a result of a set to the associated\nportTopNRequestedSize object.\nPorts with the highest value of portTopNRateBase\nshall be placed in this table in decreasing order\nof this rate until there is no more room or until\nthere are no more ports.")
portTopNOwner = MibTableColumn((0, 1, 20, 1, 1, 11), OwnerString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: portTopNOwner.setDescription("The entity that configured this entry and is                      therefore using the resources assigned to it.")
portTopNStatus = MibTableColumn((0, 1, 20, 1, 1, 12), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: portTopNStatus.setDescription("The status of this portTopNControl entry.                      The Management station sends the user set values\nwith a portTopNStatus value of createAndGo(4).\nWhen the agent receives it the collection of the\nreport starts.\nWhen the portTopNReportStatus is ready(2) the user\ncan get the reports (portTopNTable).\nFor the current implementation createAndWait(5)\nwill not be supported.\nThere can be only 5 rows in the control table.")
portTopNTable = MibTable((0, 1, 20, 2))
if mibBuilder.loadTexts: portTopNTable.setDescription("A list of top N port entries.")
portTopNEntry = MibTableRow((0, 1, 20, 2, 1)).setIndexNames((0, "CISCO-STACK-MIB", "portTopNControlIndex"), (0, "CISCO-STACK-MIB", "portTopNIndex"))
if mibBuilder.loadTexts: portTopNEntry.setDescription("A set of statistics for a port that is part of a                      top N report. For example, an instance of the\nportTopNRateBase object might be named\nportTopNUtilization.3.10")
portTopNIndex = MibTableColumn((0, 1, 20, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portTopNIndex.setDescription("An index that uniquely identifies an entry in                      the portTopN table among those in the same report.\nThis index is between 1 and N, where N is the\nportTopNGrantedSize of ports with the highest\nportTopNRateBase. Increasing values of\nportTopNIndex shall be assigned to entries with\ndecreasing values of portTopNRateBase until index\nN is assigned to the entry with the lowest value\nof portTopNRateBase or there are no more\nportTopNEntries.")
portTopNModuleNumber = MibTableColumn((0, 1, 20, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 20))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portTopNModuleNumber.setDescription("The module number of the port counter data                      entry.")
portTopNPortNumber = MibTableColumn((0, 1, 20, 2, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portTopNPortNumber.setDescription("The port number of the port counter data entry.")
portTopNUtilization = MibTableColumn((0, 1, 20, 2, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portTopNUtilization.setDescription("The utilization of the port in the system.                      The utilization is computed in the following\nmethods:\n\nEthernet Utilization: (If Full Duplex, multiply by 2)\n\n10 Mbps         I/O-pkts * (9.6 + 6.4) + (0.8 * I/O-Bytes)\nEthernet Util = -----------------------------------------\n        Interval * 10,000\n\n        where 9.6 is interframe gap of Ethernet\n        6.4 is preamble of Ethernet\n        10,000 is 10Mbps\n\n100 Mbps        I/O-pkts * (96 + 64) + (8 * I/O-Bytes)\nEthernet Util = --------------------------------------\n        Interval * 1,000,000\n\n1000 Mbps       I/O-pkts * (96 + 64) + (8 * I/O-Bytes)\nEthernet Util = --------------------------------------\n        Interval * 10,000,000\n\nAll other       I/O-pkts * (9.6 + 6.4) + (0.8 * I/O-Bytes)\nEthernet Util = ------------------------------------------\n        Interval * N * 1,000\n        (where N is N Mbps)\n\nToken Ring Utilization:\n(Assuming that Octets is from AC byte through FCS)\n\n\n4 Mbps                  Pkts * 32 + (8 * Octets)\nToken Ring Util = 100 * ------------------------\n                Interval * 4,000,000\n           where 32 is bits in SD, ED, FS and IFG\n\n16 Mbps                 Pkts * 64 + (8 * Octets)\nToken Ring Util = 100 * ------------------------\n                Interval * 16,000,000\n          where 64 is bits in SD, ED, FS and IFG\n\nFDDI Utilization:\n\n   I/O-Pkts * (64 + 8 + 32 + 16) + (8 * I/O-Bytes)\nFDDI Util = ----------------------------------------------\n   Interval * 100,000,000\n\n   where 64 is Preamble of FDDI,\n   8 is the Start Delimiter (SD) of FDDI,\n   32 is the CRC, and\n   16 is the End of Frame Sequence (EFS) of FDDI.")
portTopNIOOctets = MibTableColumn((0, 1, 20, 2, 1, 5), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portTopNIOOctets.setDescription("The Input and Output octets of the port in the                      system.")
portTopNIOPkts = MibTableColumn((0, 1, 20, 2, 1, 6), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portTopNIOPkts.setDescription("The Input and Output packets of the port in the                      system.")
portTopNIOBroadcast = MibTableColumn((0, 1, 20, 2, 1, 7), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portTopNIOBroadcast.setDescription("The Input and Output broadcast packets of the                      port in the system.")
portTopNIOMulticast = MibTableColumn((0, 1, 20, 2, 1, 8), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portTopNIOMulticast.setDescription("The Input and Output multicast packets of the                       port in the system.")
portTopNInErrors = MibTableColumn((0, 1, 20, 2, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portTopNInErrors.setDescription("The Input error packets of the port in the                      system.")
portTopNBufferOverFlow = MibTableColumn((0, 1, 20, 2, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portTopNBufferOverFlow.setDescription("The number of buffer overflow of the port in                      the system.")
mdgGrp = MibIdentifier((0, 1, 21))
mdgGatewayTable = MibTable((0, 1, 21, 1))
if mibBuilder.loadTexts: mdgGatewayTable.setDescription("This table lists a maximum of 3 MDG gateways.")
mdgGatewayEntry = MibTableRow((0, 1, 21, 1, 1)).setIndexNames((0, "CISCO-STACK-MIB", "mdgGatewayAddr"))
if mibBuilder.loadTexts: mdgGatewayEntry.setDescription("A MDG gateway table entry.")
mdgGatewayAddr = MibTableColumn((0, 1, 21, 1, 1, 1), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mdgGatewayAddr.setDescription("The IP address of a default gateway.")
mdgGatewayType = MibTableColumn((0, 1, 21, 1, 1, 2), Integer().subtype(subtypeSpec=SingleValueConstraint(3,2,1,)).subtype(namedValues=NamedValues(("invalid", 1), ("primary", 2), ("other", 3), ))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mdgGatewayType.setDescription("To add a new entry to the mdgGatewayTable, set                      this object to primary(2) or other(3) for an IP\naddress which is not already in the table. The\nprimary entry will be used first, if it is\nreachable. Otherwise, one of the other entries\nwill be used. Setting one entry to primary(2)\ncauses any previous primary entry to change to\nother(3). To remove an entry from the table, set\nthis object to invalid(1). Changing an existing\nentry from primary(2) to other(3) is not allowed.\nIf the value of this object is updated, the\ncorresponding entry of the ipRouteTable (mibII)\nwill be updated and vice versa.")
radiusGrp = MibIdentifier((0, 1, 22))
radiusLoginAuthentication = MibScalar((0, 1, 22, 1), Integer().subtype(subtypeSpec=SingleValueConstraint(2,4,1,3,)).subtype(namedValues=NamedValues(("enabled", 1), ("disabled", 2), ("enabledForTelnetOnly", 3), ("enabledForConsoleOnly", 4), )).clone(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: radiusLoginAuthentication.setDescription("Indicates whether the login authentication using                      RADIUS feature is enabled or disabled for console\nand/or telnet sessions.\n\nSetting this object to enabled(1), the login\nauthentication using RADIUS feature is enabled for\nboth console and telnet sessions.\n\nSetting this object to disabled(2), the login\nauthentication using RADIUS feature is disabled\nfor both console and telnet sessions.\n\nSetting this object to enabledForTelnetOnly(3),the\nlogin authentication using RADIUS feature is\nenabled only for telnet sessions, but disabled\nfor console session.\n\nSetting this object to enabledForConsoleOnly(4),\nthe login authentication using RADIUS feature is\nenabled only for console sessions, but disabled\nfor telnet sessions.\n\nThis object is deprecated and replaced by\ncacPriorityTable in CISCO-AAA-CLIENT-MIB.")
radiusEnableAuthentication = MibScalar((0, 1, 22, 2), Integer().subtype(subtypeSpec=SingleValueConstraint(2,4,1,3,)).subtype(namedValues=NamedValues(("enabled", 1), ("disabled", 2), ("enabledForTelnetOnly", 3), ("enabledForConsoleOnly", 4), )).clone(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: radiusEnableAuthentication.setDescription("Indicates whether the enable authentication using                      the RADIUS feature is enabled or disabled for\nConsole and telnet sessions.\n\nSetting this object to enabled(1), the enable\nauthentication using RADIUS feature is enabled for\nboth console and telnet sessions.\n\nSetting this object to disabled(2), the enable\nauthentication using RADIUS feature is disabled\nfor both console and telnet sessions.\n\nSetting this object to enabledForTelnetOnly(3),\nthe enable authentication using RADIUS feature is\nenabled only for telnet sessions, but disabled for\nconsole sessions.\n\nSetting this object to enabledForConsoleOnly(4),\nthe enable authentication using RADIUS feature is\nenabled only for console sessions, but disabled\nfor telnet sessions.\n\nThis object is deprecated and replaced by\ncacPriorityTable in CISCO-AAA-CLIENT-MIB.")
radiusDeadtime = MibScalar((0, 1, 22, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1440)).clone(0)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: radiusDeadtime.setDescription("Indicates the length of time in minutes that                      the system will mark the server dead when a RADIUS\nserver does not respond to an authentication\nrequest. During the interval of the dead time, any\nauthentication request that comes up would not be\nsent to that RADIUS server that was marked as\ndead. The default value of 0 means that the\nRADIUS servers will not be marked dead if they\ndo not respond.")
radiusAuthKey = MibScalar((0, 1, 22, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 64))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: radiusAuthKey.setDescription("The key used in encrypting the packets passed                      between the RADIUS server and the client. This key\nmust match the one configured on the server.\n\nNote that this item is only accessible when using\nthe community string defined in sysCommunityRwa.")
radiusTimeout = MibScalar((0, 1, 22, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1000)).clone(5)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: radiusTimeout.setDescription("This is the time in seconds between                      retransmissions to the RADIUS server.")
radiusRetransmits = MibScalar((0, 1, 22, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 100)).clone(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: radiusRetransmits.setDescription("Indicates number of times the RADIUS server                      should be tried before giving up on the server.")
radiusServerTable = MibTable((0, 1, 22, 7))
if mibBuilder.loadTexts: radiusServerTable.setDescription("This table lists a maximum of 3 RADIUS servers.\nThis object is deprecated and replaced by\ncrRadiusServerTable in CISCO-RADIUS-MIB.")
radiusServerEntry = MibTableRow((0, 1, 22, 7, 1)).setIndexNames((0, "CISCO-STACK-MIB", "radiusServerAddr"))
if mibBuilder.loadTexts: radiusServerEntry.setDescription("A RADIUS server table entry.")
radiusServerAddr = MibTableColumn((0, 1, 22, 7, 1, 1), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: radiusServerAddr.setDescription("The IP address of a RADIUS Server.")
radiusServerAuthPort = MibTableColumn((0, 1, 22, 7, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)).clone(1812)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: radiusServerAuthPort.setDescription("This is the destination UDP port number to which                      RADIUS messages should be sent. The RADIUS server\nwill not be used for authentication if this port\nnumber is 0.")
radiusServerType = MibTableColumn((0, 1, 22, 7, 1, 3), Integer().subtype(subtypeSpec=SingleValueConstraint(3,2,1,)).subtype(namedValues=NamedValues(("invalid", 1), ("primary", 2), ("other", 3), ))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: radiusServerType.setDescription("To add a new entry to the radiusServerTable, set                      this object to primary(2) or other(3) for an IP\naddress which is not already in the table. The\nprimary entry will be used first, if it is\nreachable. Otherwise, one of the other entries\nwill be used. Setting one entry to primary(2)\ncauses any previous primary entry to change to\nother(3). To remove an entry from the table,\nset this object to invalid(1).")
traceRouteGrp = MibIdentifier((0, 1, 24))
traceRouteMaxQueries = MibScalar((0, 1, 24, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 20))).setMaxAccess("readonly")
if mibBuilder.loadTexts: traceRouteMaxQueries.setDescription("Maximum number of query entries allowed to be                      outstanding at any time, in the\ntraceRouteQueryTable.\nThe typical value for this object is 5.")
traceRouteQueryTable = MibTable((0, 1, 24, 2))
if mibBuilder.loadTexts: traceRouteQueryTable.setDescription("A control table used to query the information                      about each gateway along the path to a host by\nspecifying retrieval criteria for the host. The\nresulting data for each instance of a query in\nthis table is returned in the traceRouteDataTable.\nThe maximum number of entries (rows) in this table\ncannot exceed the value returned by\ntraceRouteMaxQueries.")
traceRouteQueryEntry = MibTableRow((0, 1, 24, 2, 1)).setIndexNames((0, "CISCO-STACK-MIB", "traceRouteQueryIndex"))
if mibBuilder.loadTexts: traceRouteQueryEntry.setDescription("A conceptual row of the traceRouteQueryTable used                      to setup retrieval criteria to search for gateways\nbelongs to the path to a particular host\nidentified by its IP address. The actual search\nis started by setting the value of\ntraceRouteQueryStatus to valid(1).")
traceRouteQueryIndex = MibTableColumn((0, 1, 24, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: traceRouteQueryIndex.setDescription("Object which specifies an unique entry in the                      traceRouteQueryTable.")
traceRouteHost = MibTableColumn((0, 1, 24, 2, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: traceRouteHost.setDescription("Network(IP) address in dotted decimal format or                     the DNS hostname of the host which is tracerouted.")
traceRouteQueryDNSEnable = MibTableColumn((0, 1, 24, 2, 1, 3), Integer().subtype(subtypeSpec=SingleValueConstraint(2,1,)).subtype(namedValues=NamedValues(("enabled", 1), ("disabled", 2), )).clone(1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: traceRouteQueryDNSEnable.setDescription("If this value of this object is true, the                      traceroute operation will do a DNS lookup for each\nhop on the path, so the corresponding instance of\nthe traceRouteDataTable will contain the host name\nand the ip address; otherwise, that instance only\ncontains the ip address.")
traceRouteQueryWaitingTime = MibTableColumn((0, 1, 24, 2, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 300)).clone(5)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: traceRouteQueryWaitingTime.setDescription("The trace route waiting time in seconds for an                      ICMP response message.")
traceRouteQueryInitTTL = MibTableColumn((0, 1, 24, 2, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255)).clone(1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: traceRouteQueryInitTTL.setDescription("If this value of this object is set, it allows                      users skip processing for gateways that are less\nthan traceRouteQueryInitTTL away by sending\ndatagram with the value of this object instead of\nthe default value of one.")
traceRouteQueryMaxTTL = MibTableColumn((0, 1, 24, 2, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255)).clone(30)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: traceRouteQueryMaxTTL.setDescription("The maximum TTL value used in outgoing packets.")
traceRouteQueryUDPPort = MibTableColumn((0, 1, 24, 2, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)).clone(33434)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: traceRouteQueryUDPPort.setDescription("The base UDP destination port is used in the                      traceroute datagrams. This value of this object is\noften larger than 30,000 to make it improbable\nthat this port is used (this causes the\ndestination host's UDP module to generate an ICMP\nport unreachable so the traceroute operation\nknows when the operation is accomplished).\nThe traceroute operation will increment this value\nof this object each time it sends a datagram. This\nobject should be used in the unlikely event that\nthe destination port is listening to a port in the\ndefault traceroute port range.")
traceRouteQueryPacketCount = MibTableColumn((0, 1, 24, 2, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1000)).clone(3)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: traceRouteQueryPacketCount.setDescription("Specifies the number of traceroute packets to                      send to the target host in this sequence.")
traceRouteQueryPacketSize = MibTableColumn((0, 1, 24, 2, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1420)).clone(0)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: traceRouteQueryPacketSize.setDescription("Specifies the size of traceroute packets to send                      to the target host in this sequence. ")
traceRouteQueryTOS = MibTableColumn((0, 1, 24, 2, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255)).clone(0)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: traceRouteQueryTOS.setDescription("The type of service to be set in the IP header of                      the outgoing packets.This value can set to see if\ndifferent types-of-service result in different\npaths. Not all values of TOS are legal or\nmeaningful (see the IP spec for definitions.\nUseful values are probably 16 (low delay) and 8\n(high throughput).")
traceRouteQueryResult = MibTableColumn((0, 1, 24, 2, 1, 21), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: traceRouteQueryResult.setDescription("The result status of the query. Possible values                      are:\n\n-1 -Either the query has not been initiated or the\nagent is busy processing this query instance. Time\nto completion of the query processing depends on\nthe complexity of the query and the number of\nmatches that satisfy this query.\n\n0..2147483647 - The search has ended and this is\nthe number of rows in the traceRouteDataTable,\nresulting from this query.")
traceRouteQueryTime = MibTableColumn((0, 1, 24, 2, 1, 22), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: traceRouteQueryTime.setDescription("The value of sysUpTime at the time when the query                      is configured.")
traceRouteQueryOwner = MibTableColumn((0, 1, 24, 2, 1, 23), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 50))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: traceRouteQueryOwner.setDescription("The manager entity that configured this entry and                      is therefore using the resources assigned to it.")
traceRouteQueryStatus = MibTableColumn((0, 1, 24, 2, 1, 24), Integer().subtype(subtypeSpec=SingleValueConstraint(1,2,)).subtype(namedValues=NamedValues(("valid", 1), ("invalid", 2), ))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: traceRouteQueryStatus.setDescription("The status object used to manage rows in this                      table.\nWhen set this object to valid(1), the query is\ninitiated. Once initiated, all the read-write\nobjects of this table can't be modified. To remove\nan entry from the  table, set this object to\ninvalid(2).")
traceRouteDataTable = MibTable((0, 1, 24, 3))
if mibBuilder.loadTexts: traceRouteDataTable.setDescription("A table containing information about the gateway                      belongs to the path to the host corresponding to\nall the completed queries setup in the\ntraceRouteQueryTable.")
traceRouteDataEntry = MibTableRow((0, 1, 24, 3, 1)).setIndexNames((0, "CISCO-STACK-MIB", "traceRouteQueryIndex"), (0, "CISCO-STACK-MIB", "traceRouteDataIndex"))
if mibBuilder.loadTexts: traceRouteDataEntry.setDescription("A conceptual row of the traceRouteDataTable used                      to return information about all the gateway\nbelongs to the host of which search criteria is\ncorresponding instance of the\ntraceRouteQueryTable.")
traceRouteDataIndex = MibTableColumn((0, 1, 24, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: traceRouteDataIndex.setDescription("Object which specifies an unique entry in the                      traceRouteDataTable.")
traceRouteDataGatewayName = MibTableColumn((0, 1, 24, 3, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: traceRouteDataGatewayName.setDescription("The DNS name of the gateway if available.")
traceRouteDataGatewayIp = MibTableColumn((0, 1, 24, 3, 1, 3), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: traceRouteDataGatewayIp.setDescription("The ip address of the gateway. If the traceroute                      packet was sent and timed-out, the ip address is\nset to 0.0.0.0.")
traceRouteDataRtt = MibTableColumn((0, 1, 24, 3, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: traceRouteDataRtt.setDescription("The  round trip time of the current packet that                      have been sent in this sequence.")
traceRouteDataHopCount = MibTableColumn((0, 1, 24, 3, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: traceRouteDataHopCount.setDescription("The number of hop starting from the place where                      the traceroute operation is initialized to the\ngateway which has the traceRouteDataGatewayIp.")
traceRouteDataErrors = MibTableColumn((0, 1, 24, 3, 1, 6), Integer().subtype(subtypeSpec=SingleValueConstraint(4,8,1,7,15,6,14,13,17,5,16,19,12,3,9,18,11,10,2,)).subtype(namedValues=NamedValues(("icmpUnreachNet", 1), ("icmpUnreachNetProhib", 10), ("icmpUnreachProhib", 11), ("icmpUnreachNetTos", 12), ("icmpUnreachHostTos", 13), ("icmpUnreachAdmin", 14), ("icmpUnreachHostPrec", 15), ("icmpUnreachPrecedence", 16), ("icmpUnknown", 17), ("icmpTimeOut", 18), ("icmpTTLExpired", 19), ("icmpUnreachHost", 2), ("icmpUnreachProtocol", 3), ("icmpUnreachPort", 4), ("icmpUnreachNeedFrag", 5), ("icmpUnreachSrcFail", 6), ("icmpUnreachNoNet", 7), ("icmpUnreachNoHost", 8), ("icmpUnreachHostIsolated", 9), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: traceRouteDataErrors.setDescription("The error of the traceroute operation.")
fileCopyGrp = MibIdentifier((0, 1, 25))
fileCopyProtocol = MibScalar((0, 1, 25, 1), Integer().subtype(subtypeSpec=SingleValueConstraint(1,2,)).subtype(namedValues=NamedValues(("tftp", 1), ("rcp", 2), )).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fileCopyProtocol.setDescription("The protocol to be used for any remote copy.                      If the config file transfer is to occur locally on\nthe SNMP agent, the method of transfer is left up\nto the implementation, and is not restricted to\nthe protocols above.\n\nThe value of this object can not be changed when\nthe fileCopyResult object has the value of\ninProgress(1).")
fileCopyRemoteServer = MibScalar((0, 1, 25, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 64))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fileCopyRemoteServer.setDescription("The IP address  or the host name of the tftp/rcp                      remote server from (or to) which to copy the file.\nIf the copy operation  is local on the SNMP agent,\nthis object is not applicable.\n\nThe value of this object can not be changed when\nthe fileCopyResult object has the value of\ninProgress(1).")
fileCopySrcFileName = MibScalar((0, 1, 25, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 64))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fileCopySrcFileName.setDescription("The source file name (including the path, if                      applicable) of the file. The accepted value of\nthis object is 'cfg1' or 'cfg2' when the requested\naction is one of the following:\n\ncopyConfigFromFlashToRuntime(8), and\ncopyConfigFileFromFlashToHost(11).\n\nThe value of this object can not be changed when\nthe fileCopyResult object has the value of\ninProgress(1).")
fileCopyDstFileName = MibScalar((0, 1, 25, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 64))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fileCopyDstFileName.setDescription("The destination file name (including the path, if                      applicable) of the file. The accepted value of\nthis object is 'cfg1' or 'cfg2' when the requested\naction is one of the following:\n\ncopyConfigFromRuntimeToFlash(9),\ncopyConfigFileFromHostToFlash(10).\n\nThe value of this object can not be changed when\nthe fileCopyResult object has the value of\ninProgress(1).")
fileCopyModuleNumber = MibScalar((0, 1, 25, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 16))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fileCopyModuleNumber.setDescription("The module number specified in the copy                      operation.\n\nIf the value of this object is 0 and the\nfileCopyAction object has the value of\ncopyImageFromHostToFlash(4), the switch will do\nmultiple download to the modules with matching\nimage type. It is left to the SNMP agent to allow\nthe individual modules to be reset with the\ndownloaded images or not.\n\nThe value of this object can not be changed when\nthe fileCopyResult object has the value of\ninProgress(1).")
fileCopyUserName = MibScalar((0, 1, 25, 6), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 40))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fileCopyUserName.setDescription("Remote user name for copy via rcp protocol. This                      object must be specified when the\nfileCopyProtocol is rcp.")
fileCopyAction = MibScalar((0, 1, 25, 7), Integer().subtype(subtypeSpec=SingleValueConstraint(5,3,4,12,9,11,1,8,10,2,)).subtype(namedValues=NamedValues(("other", 1), ("copyConfigFileFromHostToFlash", 10), ("copyConfigFileFromFlashToHost", 11), ("copyTechReportFromRuntimeToHost", 12), ("copyConfigFromHostToRuntime", 2), ("copyConfigFromRuntimeToHost", 3), ("copyImageFromHostToFlash", 4), ("copyImageFromFlashToHost", 5), ("copyConfigFromFlashToRuntime", 8), ("copyConfigFromRuntimeToFlash", 9), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fileCopyAction.setDescription("Setting this object to one of the acceptable                      values will initiate the requested action using\nthe information provided by fileCopyProtocol,\nfileCopyRemoteServer, fileCopySrcFileName,\nfileCopyDstFileName,fileCopyModuleNumber and\nfileCopyUserName.\n\ncopyConfigFromHostToRuntime(2):\n   Copy the configuration file from host to\n   runtime configuration over the network through\n   tftp/rcp. This action will use\n   fileCopyProtocol, fileCopyRemoteServer,\n   fileCopySrcFileName, fileCopyModuleNumber,\n   and fileCopyUserName (if applicable).\n\ncopyConfigFromRuntimeToHost(3):\n   Copy the runtime configuration to host over the\n   network through tftp/rcp. This action will use\n   fileCopyProtocol, fileCopyRemoteServer,\n   fileCopyModuleNumber, fileCopyDstFileName,\n   fileCopyUserName (if applicable), and\n   fileCopyRuntimeConfigPart.\n\ncopyImageFromHostToFlash(4):\n   Copy the image from host to the flash over the\n   network through tftp/rcp. It is up to the\n   SNMP agent to reset and run the downloaded\n   image after copying. This action will use\n   fileCopyProtocol, fileCopyRemoteServer,\n   fileCopySrcFileName, fileCopyModuleNumber,\n   and fileCopyUserName (if applicable).\n\ncopyImageFromFlashToHost(5):\n   Copy the image from flash to host over the\n   switch through tftp/rcp. This action will use\n   fileCopyProtocol, fileCopyRemoteServer,\n   fileCopyDstFileName, fileCopyModuleNumber,\n   and fileCopyUserName (if applicable).\n\ncopyConfigFromFlashToRuntime(8):\n   Copy the configuration file to the runtime\n   configuration locally. This action can perform\n   only on the SUPG supervisor model and will\n   use fileCopySrcFileName ('cfg1' or 'cfg2').\n\ncopyConfigFromRuntimeToFlash(9):\n   Copy  the runtime configuration to a\n   configuration file on the flash locally. This\n   action can perform only on the SUPG supervisor\n   model and will use fileCopyDstFileName ('cfg1'\n   or 'cfg2'), and fileCopyRuntimeConfigPart.\n\ncopyConfigFileFromHostToFlash(10):\n   Copy the configuration file from host to the\n   runtime configuration over the network through\n   tftp/rcp. This action can perform only on the\n   SUPG  supervisor model and will use\n   fileCopyProtocol, fileCopyRemoteServer,\n   fileCopySrcFileName, fileCopyDstFileName,\n   fileCopyModuleNumber and fileCopyUserName\n   (if applicable).\n\ncopyConfigFileFromFlashToHost(11):\n   Copy the configuration file on the flash to\n   host over the network through tftp/rcp.\n   This action can perform only on the\n   SUPG supervisor model and will use\n   fileCopyProtocol, fileCopyRemoteServer,\n   fileCopySrcFileName, fileCopyDstFileName,\n   fileCopyModuleNumber and fileCopyUserName\n   (if applicable).\n\ncopyTechReportFromRuntimeToHost(12):\n   Copy the technical report of the system to\n   host over the network through tftp only. This\n   action will use fileCopyProtocol,\n   fileCopyRemoteServer, fileCopyModuleNumber,\n   and fileCopyDstFileName.\n\nSetting this object to any other value results in\nan error.\n\nThe value of this object can not be changed when\nthe fileCopyResult object has the value of\ninProgress(1).")
fileCopyResult = MibScalar((0, 1, 25, 8), Integer().subtype(subtypeSpec=SingleValueConstraint(17,4,10,14,11,22,8,20,7,18,21,16,5,9,6,12,3,15,19,2,1,13,)).subtype(namedValues=NamedValues(("inProgress", 1), ("serverError", 10), ("userCanceled", 11), ("wrongCode", 12), ("fileNotFound", 13), ("invalidHost", 14), ("invalidModule", 15), ("accessViolation", 16), ("unknownStatus", 17), ("invalidStorageDevice", 18), ("insufficientSpaceOnStorageDevice", 19), ("success", 2), ("insufficientDramSize", 20), ("incompatibleImage", 21), ("rcpError", 22), ("noResponse", 3), ("tooManyRetries", 4), ("noBuffers", 5), ("noProcesses", 6), ("badChecksum", 7), ("badLength", 8), ("badFlash", 9), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fileCopyResult.setDescription("Contains the result of the last copy action                      request.\nIf the value of fileCopyResult is rcpError(22),\nthen the detailed rcp error messages are contained\nin fileCopyResultRcpErrorMessage.")
fileCopyResultRcpErrorMessage = MibScalar((0, 1, 25, 9), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fileCopyResultRcpErrorMessage.setDescription("Contains the detailed rcp error messages if the                      value of fileCopyResult is rcpError(22) for the\nlast copy action request; otherwise, this MIB\nobject contains the empty string.")
fileCopyRuntimeConfigPart = MibScalar((0, 1, 25, 10), Integer().subtype(subtypeSpec=SingleValueConstraint(1,2,)).subtype(namedValues=NamedValues(("all", 1), ("nonDefault", 2), )).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fileCopyRuntimeConfigPart.setDescription("Indicates the part of runtime configuration to be                      copied. This object will only take effect when the\nobject value of fileCopyAction is one of the\nfollowing:\n\ncopyConfigFromRuntimeToHost(3),\ncopyConfigFromRuntimeToFlash(9).\n\nall -- copy all the runtime configuration.\n\nnonDefault --copy only the part of the runtime\n             configuration which is different from\n             the default configuration.")
voiceGrp = MibIdentifier((0, 1, 26))
voicePortIfConfigTable = MibTable((0, 1, 26, 1))
if mibBuilder.loadTexts: voicePortIfConfigTable.setDescription("A list of port entries. The number of entries is                      determined by the number of modules in the chassis\nand the number of ports with the voice port\ninterface configuration capability in the system.")
voicePortIfConfigEntry = MibTableRow((0, 1, 26, 1, 1)).setIndexNames((0, "CISCO-STACK-MIB", "voicePortIfConfigModuleIndex"), (0, "CISCO-STACK-MIB", "voicePortIfConfigPortIndex"))
if mibBuilder.loadTexts: voicePortIfConfigEntry.setDescription("Entry containing voice interface configuration                      for a particular port.")
voicePortIfConfigModuleIndex = MibTableColumn((0, 1, 26, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 16))).setMaxAccess("noaccess")
if mibBuilder.loadTexts: voicePortIfConfigModuleIndex.setDescription("An index value that uniquely identifies the                      module where this port is located.")
voicePortIfConfigPortIndex = MibTableColumn((0, 1, 26, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("noaccess")
if mibBuilder.loadTexts: voicePortIfConfigPortIndex.setDescription("An index value that uniquely identifies this port                      within a module. The value is determined by the\nlocation of the port on the module.")
voicePortIfDHCPEnabled = MibTableColumn((0, 1, 26, 1, 1, 3), TruthValue().clone('true')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: voicePortIfDHCPEnabled.setDescription("Indicate whether DHCP service is enabled.")
voicePortIfIpAddress = MibTableColumn((0, 1, 26, 1, 1, 4), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: voicePortIfIpAddress.setDescription("This port's IP address. This object                      is configurable only if voicePortIfDHCPEnabled\nis false. When the value of voicePortIfDHCPEnabled\nis false, this object should be configured.")
voicePortIfIpNetMask = MibTableColumn((0, 1, 26, 1, 1, 5), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: voicePortIfIpNetMask.setDescription("This port's subnet mask. This object                      is configurable only if voicePortIfDHCPEnabled\nis false. When the value of voicePortIfDHCPEnabled\nis false, this object should be configured.")
voicePortIfTftpServerAddress = MibTableColumn((0, 1, 26, 1, 1, 6), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: voicePortIfTftpServerAddress.setDescription("This port's TFTP Server address. This object                      is configurable only if voicePortIfDHCPEnabled\nis false. When the value of voicePortIfDHCPEnabled\nis false, this object should be configured.")
voicePortIfGatewayAddress = MibTableColumn((0, 1, 26, 1, 1, 7), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: voicePortIfGatewayAddress.setDescription("This port's router address. This object                      is configurable only if voicePortIfDHCPEnabled\nis false.")
voicePortIfDnsServerAddress = MibTableColumn((0, 1, 26, 1, 1, 8), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: voicePortIfDnsServerAddress.setDescription("This port's DNS Server address. This object                      is configurable only if voicePortIfDHCPEnabled\nis false.")
voicePortIfDnsDomain = MibTableColumn((0, 1, 26, 1, 1, 9), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: voicePortIfDnsDomain.setDescription("This port's DNS domain name. This object                      is configurable only if voicePortIfDHCPEnabled\nis false.")
voicePortIfOperDnsDomain = MibTableColumn((0, 1, 26, 1, 1, 10), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: voicePortIfOperDnsDomain.setDescription("This port's operational DNS domain name. If                      voicePortIfDHCPEnabled is true, this object\nindicates the domain name taken from the\nDHCP server. If voicePortIfDHCPEnabled is false,\nthis object indicates the domain name configured\nby users for this voice port or the domain name\ntaken from DNS configuration for the system\notherwise.")
voicePortCallManagerTable = MibTable((0, 1, 26, 2))
if mibBuilder.loadTexts: voicePortCallManagerTable.setDescription("A list of call manager entries. The number of                      entries is determined by the number of modules in\nthe chassis and the number of ports with the\nvoice port interface configuration capability\nin the system.")
voicePortCallManagerEntry = MibTableRow((0, 1, 26, 2, 1)).setIndexNames((0, "CISCO-STACK-MIB", "voicePortModuleIndex"), (0, "CISCO-STACK-MIB", "voicePortIndex"), (0, "CISCO-STACK-MIB", "voicePortCallManagerIndex"))
if mibBuilder.loadTexts: voicePortCallManagerEntry.setDescription("Entry containing voice interface configuration                      for a particular port.")
voicePortModuleIndex = MibTableColumn((0, 1, 26, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 16))).setMaxAccess("noaccess")
if mibBuilder.loadTexts: voicePortModuleIndex.setDescription("An index value that uniquely identifies the                      module where this port is located.")
voicePortIndex = MibTableColumn((0, 1, 26, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("noaccess")
if mibBuilder.loadTexts: voicePortIndex.setDescription("An index value that uniquely identifies this port                      within a module.")
voicePortCallManagerIndex = MibTableColumn((0, 1, 26, 2, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 5))).setMaxAccess("noaccess")
if mibBuilder.loadTexts: voicePortCallManagerIndex.setDescription("An index value that uniquely identifies this                      CallManager within a module/port. A port can\nregister up to 5 CallManager.")
voicePortCallManagerIpAddr = MibTableColumn((0, 1, 26, 2, 1, 4), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: voicePortCallManagerIpAddr.setDescription("The Call Manager IP Address of this port. A port                      can register up to 5 call managers.")
voicePortOperDnsServerTable = MibTable((0, 1, 26, 3))
if mibBuilder.loadTexts: voicePortOperDnsServerTable.setDescription("A list of operational DNS entries used by the                      voice ports.")
voicePortOperDnsServerEntry = MibTableRow((0, 1, 26, 3, 1)).setIndexNames((0, "CISCO-STACK-MIB", "voicePortDnsModuleIndex"), (0, "CISCO-STACK-MIB", "voicePortDnsPortIndex"), (0, "CISCO-STACK-MIB", "voicePortOperDnsServerIndex"))
if mibBuilder.loadTexts: voicePortOperDnsServerEntry.setDescription("Entry containing infomation on DNS servers may be                      used for a particular voice port.\n\nIf DHCP is enabled on a port, the DNS server IP\naddress will come from the DHCP server. If DHCP\nis disabled, the DNS server IP address can be\nconfigured by users through the mib object\nvoicePortIfDnsServerAddress for a port, otherwise\nit will be taken from DNS configuration in the\nsystem.")
voicePortDnsModuleIndex = MibTableColumn((0, 1, 26, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 16))).setMaxAccess("noaccess")
if mibBuilder.loadTexts: voicePortDnsModuleIndex.setDescription("An index value that uniquely identifies the                      module where this port is located.")
voicePortDnsPortIndex = MibTableColumn((0, 1, 26, 3, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("noaccess")
if mibBuilder.loadTexts: voicePortDnsPortIndex.setDescription("An index value that uniquely identifies this port                       within a module.")
voicePortOperDnsServerIndex = MibTableColumn((0, 1, 26, 3, 1, 3), Unsigned32()).setMaxAccess("noaccess")
if mibBuilder.loadTexts: voicePortOperDnsServerIndex.setDescription("An index value that uniquely identifies this DNS                       server within a module/port. This value indicates\nthe priority order among these DNS servers.")
voicePortOperDnsServerIpAddr = MibTableColumn((0, 1, 26, 3, 1, 4), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: voicePortOperDnsServerIpAddr.setDescription("The operational DNS Server IP Address of this                      port. ")
voicePortOperDnsServerSource = MibTableColumn((0, 1, 26, 3, 1, 5), Integer().subtype(subtypeSpec=SingleValueConstraint(3,2,1,)).subtype(namedValues=NamedValues(("fromDhcp", 1), ("fromPortConfig", 2), ("fromSystemConfig", 3), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: voicePortOperDnsServerSource.setDescription("The source of the Dns Server IP Address of this                      port.\n\nfromDhcp(1) indicates that the DNS server IP\naddress comes from the DHCP server.\n\nfromPortConfig(2) indicates that the DNS server IP\naddress comes from the object\nvoicePorfIfDnsServerAdress.\n\nfromSystemConfig(3) indicates that the DNS server\nIP address comes from DNS configuration for the\nsystem.")
portJumboFrameGrp = MibIdentifier((0, 1, 27))
portJumboFrameTable = MibTable((0, 1, 27, 1))
if mibBuilder.loadTexts: portJumboFrameTable.setDescription("A list of port jumbo frame entries. The number of                      entries is determined by the number of ports in\nthe system which support the Jumbo frame feature.")
portJumboFrameEntry = MibTableRow((0, 1, 27, 1, 1)).setIndexNames((0, "CISCO-STACK-MIB", "portJumboFrameModuleIndex"), (0, "CISCO-STACK-MIB", "portJumboFramePortIndex"))
if mibBuilder.loadTexts: portJumboFrameEntry.setDescription("Entry containing the jumbo frame configuration                      for a particular port.")
portJumboFrameModuleIndex = MibTableColumn((0, 1, 27, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 16))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portJumboFrameModuleIndex.setDescription("An index value that uniquely identifies the                      module where this port is located.")
portJumboFramePortIndex = MibTableColumn((0, 1, 27, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portJumboFramePortIndex.setDescription("An index value that uniquely identifies this port                      within a module. The value is determined by the\nlocation of the port on the module. Valid entries\nare 1 to the value of moduleNumPorts for this\nmodule.")
portJumboFrameEnable = MibTableColumn((0, 1, 27, 1, 1, 3), Integer().subtype(subtypeSpec=SingleValueConstraint(2,1,)).subtype(namedValues=NamedValues(("enabled", 1), ("disabled", 2), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portJumboFrameEnable.setDescription("Indicates the jumbo frame status of the port. If                      enabled, the port supports frame size greater than\nthe standard ethernet frame size of 1518 bytes.")
switchAccelerationGrp = MibIdentifier((0, 1, 28))
switchAccelerationModuleTable = MibTable((0, 1, 28, 1))
if mibBuilder.loadTexts: switchAccelerationModuleTable.setDescription("This table contains a list of the modules for                      which the switch acceleration capability can be\nconfigured.")
switchAccelerationModuleEntry = MibTableRow((0, 1, 28, 1, 1)).setIndexNames((0, "CISCO-STACK-MIB", "switchAccelerationModuleIndex"))
if mibBuilder.loadTexts: switchAccelerationModuleEntry.setDescription("A module for which switch acceleration can be                      configured.")
switchAccelerationModuleIndex = MibTableColumn((0, 1, 28, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 16))).setMaxAccess("readonly")
if mibBuilder.loadTexts: switchAccelerationModuleIndex.setDescription("The value of moduleIndex for the module where                      switch acceleration feature can be configured.")
switchAccelerationModuleEnable = MibTableColumn((0, 1, 28, 1, 1, 2), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: switchAccelerationModuleEnable.setDescription("Indicates whether switch acceleration is enabled                     on  this module or not.\n\nWhen this feature is enabled, the system will\nincrease the switching bandwidth, but the\nifAdminStatus of any port on this module can not\nbe set to 'up'.\n\nIf the ifAdminStatus of any port on this module is\n'up', this feature can not be enabled until\nifAdminStatus of all ports on the module is set\nto 'down'.")
configGrp = MibIdentifier((0, 1, 29))
configMode = MibScalar((0, 1, 29, 1), Integer().subtype(subtypeSpec=SingleValueConstraint(1,2,)).subtype(namedValues=NamedValues(("binary", 1), ("text", 2), )).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configMode.setDescription("Configuration mode to store the configuration                      information.")
configTextFileLocation = MibScalar((0, 1, 29, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255)).clone('')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configTextFileLocation.setDescription("The location of the text configuration file                      which can be either NVRAM or a file in the\nFLASH file system. If the location is NVRAM,\nthis object is a zero length octet string.\nOtherwise, the FLASH file should be specified\nin <device>:<filename> format. This object\nis only instantiated when configMode has\nthe value of of text(2). ")
configWriteMem = MibScalar((0, 1, 29, 3), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configWriteMem.setDescription("When this object is set to true(1), the current                      configuration is saved in text format in the\nlocation specified by configTextFileLocation.\nThis object is only instantiated when configMode\nhas the value of text(2). When read,\nthis object always returns false(2). ")
configWriteMemStatus = MibScalar((0, 1, 29, 4), Integer().subtype(subtypeSpec=SingleValueConstraint(2,4,3,1,5,)).subtype(namedValues=NamedValues(("inProgress", 1), ("succeeded", 2), ("resourceUnavailable", 3), ("badFileName", 4), ("someOtherError", 5), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configWriteMemStatus.setDescription("The status of the current or the most recently                      completed 'write memory' operation. The possible\nvalues are:\n\n  inProgress - 'write' operation in progress;\n\n  succeeded - the 'write' was successful (this\n  value is also used when no write has been\n  invoked since the last time the local system\n  restarted);\n\n  resourceUnavailable, -the 'write' failed because\n  insufficeient resource was available.\n\n  badFileName - the 'write' failed because the\n  specified destination file was not found.\n  This might be due to invalid FLASH device\n  name or invalid file name.\n\n  someOtherError - the 'write' failed for some\n  other reason.\n\nThis object is only instantiated when configMode\nhas the value of text(2). ")
ciscoStackMIBConformance = MibIdentifier((0, 1, 31))
ciscoStackMIBCompliances = MibIdentifier((0, 1, 31, 1))
ciscoStackMIBGroups = MibIdentifier((0, 1, 31, 2))
adapterCard = MibIdentifier((0, 2))
wsc1000sysID = MibIdentifier((0, 3))
wsc1100sysID = MibIdentifier((0, 4))
wsc1200sysID = MibIdentifier((0, 5))
wsc1400sysID = MibIdentifier((0, 6))
wsc5000sysID = MibIdentifier((0, 7))
wsc1600sysID = MibIdentifier((0, 8))
cpw1600sysID = MibIdentifier((0, 9))
wsc3000sysID = MibIdentifier((0, 10))
wsc2900sysID = MibIdentifier((0, 12))
cpw2200sysID = MibIdentifier((0, 13))
esStack = MibIdentifier((0, 14))
wsc3200sysID = MibIdentifier((0, 15))
cpw1900sysID = MibIdentifier((0, 16))
wsc5500sysID = MibIdentifier((0, 17))
wsc1900sysID = MibIdentifier((0, 18))
cpw1220sysID = MibIdentifier((0, 19))
wsc2820sysID = MibIdentifier((0, 20))
cpw1420sysID = MibIdentifier((0, 21))
dcd = MibIdentifier((0, 22))
wsc3100sysID = MibIdentifier((0, 23))
cpw1800sysID = MibIdentifier((0, 24))
cpw1601sysID = MibIdentifier((0, 25))
wsc3001sysID = MibIdentifier((0, 26))
cpw1220csysID = MibIdentifier((0, 27))
wsc1900csysID = MibIdentifier((0, 28))
wsc5002sysID = MibIdentifier((0, 29))
cpw1220isysID = MibIdentifier((0, 30))
wsc1900isysID = MibIdentifier((0, 31))
tsStack = MibIdentifier((0, 32))
wsc3900sysID = MibIdentifier((0, 33))
wsc5505sysID = MibIdentifier((0, 34))
wsc2926sysID = MibIdentifier((0, 35))
wsc5509sysID = MibIdentifier((0, 36))
wsc3920sysID = MibIdentifier((0, 37))
wsc6006sysID = MibIdentifier((0, 38))
wsc6009sysID = MibIdentifier((0, 39))
wsc4003sysID = MibIdentifier((0, 40))
wsc4912gsysID = MibIdentifier((0, 41))
wsc2948gsysID = MibIdentifier((0, 42))
wsc6509sysID = MibIdentifier((0, 44))
wsc6506sysID = MibIdentifier((0, 45))
wsc4006sysID = MibIdentifier((0, 46))
wsc6509nebsysID = MibIdentifier((0, 47))
wsc6knamsysID = MibIdentifier((0, 48))
wsc2980gsysID = MibIdentifier((0, 49))
wsc6513sysID = MibIdentifier((0, 50))
wsc2980gasysID = MibIdentifier((0, 51))
cisco7603sysID = MibIdentifier((0, 53))
cisco7606sysID = MibIdentifier((0, 54))
cisco7609sysID = MibIdentifier((0, 55))
wsc6503sysID = MibIdentifier((0, 56))
wsc4503sysID = MibIdentifier((0, 58))
wsc4506sysID = MibIdentifier((0, 59))
cisco7613sysID = MibIdentifier((0, 60))
wsc6509nebasysID = MibIdentifier((0, 61))
wsc2948ggetxsysID = MibIdentifier((0, 62))
cisco7604sysID = MibIdentifier((0, 63))
wsc6504esysID = MibIdentifier((0, 64))
wsc1900LiteFxsysID = MibIdentifier((0, 175))

# Augmentions
tokenRingPortEntry.registerAugmentions(("CISCO-STACK-MIB", "tokenRingPortSoftErrEntry"))
tokenRingPortSoftErrEntry.setIndexNames(*tokenRingPortEntry.getIndexNames())

# Notifications

lerAlarmOn = NotificationType((0, 0, 1)).setObjects(*(("FDDI-SMT73-MIB", "fddimibPORTIndex"), ("FDDI-SMT73-MIB", "fddimibPORTSMTIndex"), ) )
if mibBuilder.loadTexts: lerAlarmOn.setDescription("A lerAlarmOn trap signifies that the agent entity                      has detected that the fddimibPORTLerFlag object in\nthe FDDI-SMT73-MIB (RFC 1512) has transitioned to\nthe true(1) state for one of its ports.\nThe generation of this trap can be controlled by\nthe fddimibPORTLerAlarm object in the\nFDDI-SMT73-MIB for each port.")
lerAlarmOff = NotificationType((0, 0, 2)).setObjects(*(("FDDI-SMT73-MIB", "fddimibPORTIndex"), ("FDDI-SMT73-MIB", "fddimibPORTSMTIndex"), ) )
if mibBuilder.loadTexts: lerAlarmOff.setDescription("A lerAlarmOff trap signifies that the agent                      entity has detected that the fddimibPORTLerFlag\nobject in the FDDI-SMT73-MIB (RFC 1512) has\ntransitioned to the false(2) state for one of\nits ports. The generation of this trap can be\ncontrolled by the fddimibPORTLerAlarm object in\nthe FDDI-SMT73-MIB for each port.")
moduleUp = NotificationType((0, 0, 3)).setObjects(*(("CISCO-STACK-MIB", "moduleType"), ("CISCO-STACK-MIB", "moduleIndex"), ) )
if mibBuilder.loadTexts: moduleUp.setDescription("A moduleUp trap signifies that the agent entity                      has detected that the moduleStatus object in this\nMIB has transitioned to the ok(2) state for one of\nits modules.\nThe generation of this trap can be controlled by\nthe sysEnableModuleTraps object in this MIB.")
moduleDown = NotificationType((0, 0, 4)).setObjects(*(("CISCO-STACK-MIB", "moduleType"), ("CISCO-STACK-MIB", "moduleIndex"), ) )
if mibBuilder.loadTexts: moduleDown.setDescription("A moduleDown trap signifies that the agent entity                      has detected that the moduleStatus object in this\nMIB has transitioned out of the ok(2) state for\none of its modules.\nThe generation of this trap can be controlled by\nthe sysEnableModuleTraps object in this MIB.")
chassisAlarmOn = NotificationType((0, 0, 5)).setObjects(*(("CISCO-STACK-MIB", "chassisMajorAlarm"), ("CISCO-STACK-MIB", "chassisTempAlarm"), ("CISCO-STACK-MIB", "chassisMinorAlarm"), ) )
if mibBuilder.loadTexts: chassisAlarmOn.setDescription("A chassisAlarmOn trap signifies that the agent                      entity has detected the chassisTempAlarm,\nchassisMinorAlarm, or chassisMajorAlarm object in\nthis MIB has transitioned to the on(2) state.\nThe generation of this trap can be controlled by\nthe sysEnableChassisTraps object in this MIB.")
chassisAlarmOff = NotificationType((0, 0, 6)).setObjects(*(("CISCO-STACK-MIB", "chassisMajorAlarm"), ("CISCO-STACK-MIB", "chassisTempAlarm"), ("CISCO-STACK-MIB", "chassisMinorAlarm"), ) )
if mibBuilder.loadTexts: chassisAlarmOff.setDescription("A chassisAlarmOff trap signifies that the agent                      entity has detected the chassisTempAlarm,\nchassisMinorAlarm, or chassisMajorAlarm object in\nthis MIB has transitioned to the off(1) state.\nThe generation of this trap can be controlled by\nthe sysEnableChassisTraps object in this MIB.")
ipPermitDeniedTrap = NotificationType((0, 0, 7)).setObjects(*(("CISCO-STACK-MIB", "ipPermitDeniedAddress"), ("CISCO-STACK-MIB", "ipPermitDeniedAccess"), ) )
if mibBuilder.loadTexts: ipPermitDeniedTrap.setDescription("ipPermitDeniedTrap indicates that IP permit                      denied access happens. The generation of this\ntrap can be controlled by the\nsysEnableIpPermitTraps object in this MIB.")
sysConfigChangeTrap = NotificationType((0, 0, 9)).setObjects(*(("CISCO-STACK-MIB", "sysConfigChangeTime"), ("CISCO-STACK-MIB", "sysConfigChangeInfo"), ) )
if mibBuilder.loadTexts: sysConfigChangeTrap.setDescription("A sysConfigChange trap signifies that the system                      configuration in NVRAM is changed. The generation\nof this trap can be controlled by the\nsysEnableConfigTraps object in this MIB.")
tokenRingSoftErrExceededTrap = NotificationType((0, 0, 10)).setObjects(*(("TOKEN-RING-RMON-MIB", "ringStationMacAddress"), ("IF-MIB", "ifIndex"), ("IF-MIB", "ifName"), ) )
if mibBuilder.loadTexts: tokenRingSoftErrExceededTrap.setDescription("This trap is generated when a station local to a                      token ring port exceeds its Soft Error Threshold\nwithin the configured interval.")

# Groups

systemMiscGroup = ObjectGroup((0, 1, 31, 2, 1)).setObjects(*(("CISCO-STACK-MIB", "sysInsertMode"), ("CISCO-STACK-MIB", "sysIpVlan"), ("CISCO-STACK-MIB", "sysClearMacTime"), ("CISCO-STACK-MIB", "sysIpAddr"), ("CISCO-STACK-MIB", "sysEnableModem"), ("CISCO-STACK-MIB", "sysEnableRedirects"), ("CISCO-STACK-MIB", "sysNetMask"), ("CISCO-STACK-MIB", "sysClearPortTime"), ("CISCO-STACK-MIB", "sysCommunityRw"), ("CISCO-STACK-MIB", "sysArpAgingTime"), ("CISCO-STACK-MIB", "sysMgmtType"), ("CISCO-STACK-MIB", "sysBroadcast"), ("CISCO-STACK-MIB", "sysCommunityRo"), ("CISCO-STACK-MIB", "sysReset"), ("CISCO-STACK-MIB", "sysBaudRate"), ("CISCO-STACK-MIB", "sysAttachType"), ("CISCO-STACK-MIB", "sysCommunityRwa"), ) )
if mibBuilder.loadTexts: systemMiscGroup.setDescription("A collection of objects providing information                      about the miscellaneous system features.")
systemTrapGroup = ObjectGroup((0, 1, 31, 2, 2)).setObjects(*(("CISCO-STACK-MIB", "sysEnableBridgeTraps"), ("CISCO-STACK-MIB", "sysTrapReceiverAddr"), ("CISCO-STACK-MIB", "sysTrapReceiverType"), ("CISCO-STACK-MIB", "sysTrapReceiverComm"), ("CISCO-STACK-MIB", "sysEnableRepeaterTraps"), ("CISCO-STACK-MIB", "sysEnableModuleTraps"), ("CISCO-STACK-MIB", "sysEnableChassisTraps"), ) )
if mibBuilder.loadTexts: systemTrapGroup.setDescription("A collection of objects providing information                      about the SNMP traps feature.")
chassisGroup = ObjectGroup((0, 1, 31, 2, 3)).setObjects(*(("CISCO-STACK-MIB", "chassisPs1Status"), ("CISCO-STACK-MIB", "chassisBkplType"), ("CISCO-STACK-MIB", "chassisMajorAlarm"), ("CISCO-STACK-MIB", "chassisSysType"), ("CISCO-STACK-MIB", "chassisFanStatus"), ("CISCO-STACK-MIB", "chassisPs2Type"), ("CISCO-STACK-MIB", "chassisPs2Status"), ("CISCO-STACK-MIB", "chassisMinorAlarm"), ("CISCO-STACK-MIB", "chassisPs2TestResult"), ("CISCO-STACK-MIB", "chassisTempAlarm"), ("CISCO-STACK-MIB", "chassisPs1TestResult"), ("CISCO-STACK-MIB", "chassisPs1Type"), ("CISCO-STACK-MIB", "chassisFanTestResult"), ("CISCO-STACK-MIB", "chassisNumSlots"), ) )
if mibBuilder.loadTexts: chassisGroup.setDescription("A collection of objects providing information                      about the chassis of the device.\n\nImplementation of this group is mandatory.")
moduleGroup = ObjectGroup((0, 1, 31, 2, 4)).setObjects(*(("CISCO-STACK-MIB", "moduleStatus"), ("CISCO-STACK-MIB", "moduleName"), ("CISCO-STACK-MIB", "modulePortStatus"), ("CISCO-STACK-MIB", "moduleIndex"), ("CISCO-STACK-MIB", "moduleSerialNumberString"), ("CISCO-STACK-MIB", "moduleSubType"), ("CISCO-STACK-MIB", "moduleType"), ("CISCO-STACK-MIB", "moduleTestResult"), ("CISCO-STACK-MIB", "moduleAction"), ("CISCO-STACK-MIB", "moduleNumPorts"), ) )
if mibBuilder.loadTexts: moduleGroup.setDescription("A collection of objects providing information                      about the modules on the device.\n\nImplementation of this group is mandatory.")
portGroup = ObjectGroup((0, 1, 31, 2, 5)).setObjects(*(("CISCO-STACK-MIB", "portAdminSpeed"), ("CISCO-STACK-MIB", "portOperRxFlowControl"), ("CISCO-STACK-MIB", "portDuplex"), ("CISCO-STACK-MIB", "portMacControlTransmitFrames"), ("CISCO-STACK-MIB", "portIndex"), ("CISCO-STACK-MIB", "portAdditionalStatus"), ("CISCO-STACK-MIB", "portCrossIndex"), ("CISCO-STACK-MIB", "portModuleIndex"), ("CISCO-STACK-MIB", "portMacControlPauseReceiveFrames"), ("CISCO-STACK-MIB", "portCrossGroupIndex"), ("CISCO-STACK-MIB", "portOperTxFlowControl"), ("CISCO-STACK-MIB", "portType"), ("CISCO-STACK-MIB", "portOperStatus"), ("CISCO-STACK-MIB", "portName"), ("CISCO-STACK-MIB", "portAdminTxFlowControl"), ("CISCO-STACK-MIB", "portLinkFaultStatus"), ("CISCO-STACK-MIB", "portMacControlReceiveFrames"), ("CISCO-STACK-MIB", "portMacControlUnknownProtocolFrames"), ("CISCO-STACK-MIB", "portIfIndex"), ("CISCO-STACK-MIB", "portSpantreeFastStart"), ("CISCO-STACK-MIB", "portAdminRxFlowControl"), ("CISCO-STACK-MIB", "portMacControlPauseTransmitFrames"), ) )
if mibBuilder.loadTexts: portGroup.setDescription("A collection of objects providing information                      about the ports on the device.")
optionalSystemMiscGroup = ObjectGroup((0, 1, 31, 2, 6)).setObjects(*(("CISCO-STACK-MIB", "sysBannerMotd"), ("CISCO-STACK-MIB", "sysConfigChangeTime"), ("CISCO-STACK-MIB", "sysConfigRegister"), ("CISCO-STACK-MIB", "sysBootedImage"), ("CISCO-STACK-MIB", "sysConfigChangeInfo"), ("CISCO-STACK-MIB", "sysBootVariable"), ) )
if mibBuilder.loadTexts: optionalSystemMiscGroup.setDescription("A collection of objects providing information                      about the miscellaneous system features.\n\nImplementation of this group is optional.")
optionalSystemTrapGroup = ObjectGroup((0, 1, 31, 2, 7)).setObjects(*(("CISCO-STACK-MIB", "sysEnableConfigTraps"), ("CISCO-STACK-MIB", "sysEnableEntityTrap"), ("CISCO-STACK-MIB", "sysEnableVmpsTraps"), ("CISCO-STACK-MIB", "sysEnableIpPermitTraps"), ("CISCO-STACK-MIB", "sysEnableStpxTrap"), ) )
if mibBuilder.loadTexts: optionalSystemTrapGroup.setDescription("A collection of objects providing information                      about the SNMP traps feature.\n\nImplementation of this group is optional.")
optionalChassisGroup = ObjectGroup((0, 1, 31, 2, 8)).setObjects(*(("CISCO-STACK-MIB", "chassisComponentSerialNumber"), ("CISCO-STACK-MIB", "chassisSerialNumberString"), ("CISCO-STACK-MIB", "chassisComponentHwVersion"), ("CISCO-STACK-MIB", "chassisModel"), ("CISCO-STACK-MIB", "chassisPs2TestResult"), ("CISCO-STACK-MIB", "chassisComponentIndex"), ("CISCO-STACK-MIB", "chassisPs1TestResult"), ("CISCO-STACK-MIB", "chassisFanTestResult"), ("CISCO-STACK-MIB", "chassisComponentType"), ("CISCO-STACK-MIB", "chassisSlotConfig"), ("CISCO-STACK-MIB", "chassisComponentModel"), ) )
if mibBuilder.loadTexts: optionalChassisGroup.setDescription("A collection of objects providing information                      about the chassis of the device.")
optionalModuleGroup = ObjectGroup((0, 1, 31, 2, 9)).setObjects(*(("CISCO-STACK-MIB", "moduleSlotNum"), ("CISCO-STACK-MIB", "moduleHwVersion"), ("CISCO-STACK-MIB", "moduleSwVersion"), ("CISCO-STACK-MIB", "moduleStandbyStatus"), ("CISCO-STACK-MIB", "moduleTestResult"), ("CISCO-STACK-MIB", "moduleSubType2"), ("CISCO-STACK-MIB", "moduleFwVersion"), ("CISCO-STACK-MIB", "moduleModel"), ("CISCO-STACK-MIB", "moduleIPAddress"), ("CISCO-STACK-MIB", "moduleIPAddressVlan"), ) )
if mibBuilder.loadTexts: optionalModuleGroup.setDescription("A collection of objects providing information                      about the modules on the device.\n\nImplementation of this group is Optional.")
optionalPortGroup = ObjectGroup((0, 1, 31, 2, 10)).setObjects(*(("CISCO-STACK-MIB", "portTopNIOMulticast"), ("CISCO-STACK-MIB", "portTopNIOPkts"), ("CISCO-STACK-MIB", "portTopNBufferOverFlow"), ("CISCO-STACK-MIB", "portSecurityAdminStatus"), ("CISCO-STACK-MIB", "portCpbTrunkMode"), ("CISCO-STACK-MIB", "portChannelProtOutPackets"), ("CISCO-STACK-MIB", "portChannelModuleIndex"), ("CISCO-STACK-MIB", "portTopNStatus"), ("CISCO-STACK-MIB", "portChannelAdminStatus"), ("CISCO-STACK-MIB", "portTopNPortNumber"), ("CISCO-STACK-MIB", "portCpbVlanMembership"), ("CISCO-STACK-MIB", "portTopNIndex"), ("CISCO-STACK-MIB", "portCpbSpeed"), ("CISCO-STACK-MIB", "portCpbModuleIndex"), ("CISCO-STACK-MIB", "portChannelPortIndex"), ("CISCO-STACK-MIB", "portTopNRateBase"), ("CISCO-STACK-MIB", "portTopNStartTime"), ("CISCO-STACK-MIB", "portSecurityModuleIndex"), ("CISCO-STACK-MIB", "portTopNUtilization"), ("CISCO-STACK-MIB", "portTopNDuration"), ("CISCO-STACK-MIB", "portChannelNeighbourPortId"), ("CISCO-STACK-MIB", "portCpbDuplex"), ("CISCO-STACK-MIB", "portTopNIOOctets"), ("CISCO-STACK-MIB", "portSecurityPortIndex"), ("CISCO-STACK-MIB", "portCpbTrunkEncapsulationType"), ("CISCO-STACK-MIB", "portSecuritySecureSrcAddr"), ("CISCO-STACK-MIB", "portCpbFlowControl"), ("CISCO-STACK-MIB", "portTopNOwner"), ("CISCO-STACK-MIB", "portChannelPorts"), ("CISCO-STACK-MIB", "portCpbBroadcastSuppression"), ("CISCO-STACK-MIB", "portTopNRequestedSize"), ("CISCO-STACK-MIB", "portTopNModuleNumber"), ("CISCO-STACK-MIB", "portTopNGrantedSize"), ("CISCO-STACK-MIB", "portChannelIfIndex"), ("CISCO-STACK-MIB", "portCpbPortfast"), ("CISCO-STACK-MIB", "portCpbSecurity"), ("CISCO-STACK-MIB", "portTopNMode"), ("CISCO-STACK-MIB", "portTopNType"), ("CISCO-STACK-MIB", "portChannelNeighbourDeviceId"), ("CISCO-STACK-MIB", "portChannelProtInPackets"), ("CISCO-STACK-MIB", "portTopNIOBroadcast"), ("CISCO-STACK-MIB", "portSecurityLastSrcAddr"), ("CISCO-STACK-MIB", "portTopNReportStatus"), ("CISCO-STACK-MIB", "portChannelOperStatus"), ("CISCO-STACK-MIB", "portTopNInErrors"), ("CISCO-STACK-MIB", "portTopNControlIndex"), ("CISCO-STACK-MIB", "portSecurityOperStatus"), ("CISCO-STACK-MIB", "portTopNTimeRemaining"), ("CISCO-STACK-MIB", "portCpbPortIndex"), ("CISCO-STACK-MIB", "portCpbChannel"), ) )
if mibBuilder.loadTexts: optionalPortGroup.setDescription("A collection of objects providing information                      about the ports on the device.\n\nImplementation of this group is Optional.")
systemTrafficGroup = ObjectGroup((0, 1, 31, 2, 11)).setObjects(*(("CISCO-STACK-MIB", "sysTrafficMeterType"), ("CISCO-STACK-MIB", "sysTrafficPeakTime"), ("CISCO-STACK-MIB", "sysTrafficMeterPeak"), ("CISCO-STACK-MIB", "sysTrafficMeterPeakTime"), ("CISCO-STACK-MIB", "sysTraffic"), ("CISCO-STACK-MIB", "sysTrafficPeak"), ("CISCO-STACK-MIB", "sysTrafficMeter"), ) )
if mibBuilder.loadTexts: systemTrafficGroup.setDescription("A collection of objects providing information                      about the traffic meter feature.\n\nImplementation of this group is optional. If the\ntraffic meter feature is supported, the entire\ngroup should be implemented.")
systemFddiGroup = ObjectGroup((0, 1, 31, 2, 12)).setObjects(*(("CISCO-STACK-MIB", "sysFddiRingAddress"), ("CISCO-STACK-MIB", "sysFddiRingSMTIndex"), ("CISCO-STACK-MIB", "sysFddiRingNext"), ) )
if mibBuilder.loadTexts: systemFddiGroup.setDescription("A collection of objects providing information                      about the FDDI ring feature.\n\nImplementation of this group is optional. If the\nFDDI ring feature is supported, the entire group\nshould be implemented.")
systemRmonGroup = ObjectGroup((0, 1, 31, 2, 13)).setObjects(*(("CISCO-STACK-MIB", "sysExtendedRmonEnable"), ("CISCO-STACK-MIB", "sysExtendedRmonVlanAgentEnable"), ("CISCO-STACK-MIB", "sysExtendedRmonNetflowPassword"), ("CISCO-STACK-MIB", "sysEnableRmon"), ("CISCO-STACK-MIB", "sysExtendedRmonNetflowEnable"), ("CISCO-STACK-MIB", "sysExtendedRmonVlanModeEnable"), ) )
if mibBuilder.loadTexts: systemRmonGroup.setDescription("A collection of objects providing information                      about the extended RMON feature.\n\nImplementation of this group is optional. If the\nextended RMON feature is supported, the entire\ngroup should be implemented.")
authenticationGroup = ObjectGroup((0, 1, 31, 2, 14)).setObjects(*(("CISCO-STACK-MIB", "tacacsDirectedRequest"), ("CISCO-STACK-MIB", "sysConsolePrimaryLoginAuthentication"), ("CISCO-STACK-MIB", "radiusServerType"), ("CISCO-STACK-MIB", "tacacsNumLoginAttempts"), ("CISCO-STACK-MIB", "radiusDeadtime"), ("CISCO-STACK-MIB", "sysTelnetPrimaryLoginAuthentication"), ("CISCO-STACK-MIB", "sysTelnetPrimaryEnableAuthentication"), ("CISCO-STACK-MIB", "tacacsServerAddr"), ("CISCO-STACK-MIB", "sysConsolePrimaryEnableAuthentication"), ("CISCO-STACK-MIB", "radiusTimeout"), ("CISCO-STACK-MIB", "tacacsTimeout"), ("CISCO-STACK-MIB", "tacacsEnableAuthentication"), ("CISCO-STACK-MIB", "tacacsLoginAuthentication"), ("CISCO-STACK-MIB", "tacacsServerType"), ("CISCO-STACK-MIB", "radiusRetransmits"), ("CISCO-STACK-MIB", "radiusAuthKey"), ("CISCO-STACK-MIB", "tacacsAuthKey"), ("CISCO-STACK-MIB", "radiusServerAuthPort"), ("CISCO-STACK-MIB", "radiusEnableAuthentication"), ("CISCO-STACK-MIB", "tacacsLocalEnableAuthentication"), ("CISCO-STACK-MIB", "radiusLoginAuthentication"), ("CISCO-STACK-MIB", "radiusServerAddr"), ("CISCO-STACK-MIB", "tacacsLocalLoginAuthentication"), ) )
if mibBuilder.loadTexts: authenticationGroup.setDescription("A collection of objects providing information                      about the authentication features.\n\nImplementation of this group is optional. If the\nauthentication features are supported, the entire\ngroup should be implemented.")
tftpGroup = ObjectGroup((0, 1, 31, 2, 15)).setObjects(*(("CISCO-STACK-MIB", "tftpModule"), ("CISCO-STACK-MIB", "tftpFile"), ("CISCO-STACK-MIB", "tftpAction"), ("CISCO-STACK-MIB", "tftpResult"), ("CISCO-STACK-MIB", "tftpHost"), ) )
if mibBuilder.loadTexts: tftpGroup.setDescription("A collection of objects providing information                      about the tftp upload/download features.\n\nImplementation of this group is optional. If the\ntftp upload/download features are supported, the\nentire group should be implemented.")
brouteEnableGroup = ObjectGroup((0, 1, 31, 2, 16)).setObjects(*(("CISCO-STACK-MIB", "brouterPortBridgeVlan"), ("CISCO-STACK-MIB", "brouterIpx8022ToEther"), ("CISCO-STACK-MIB", "brouterPortIpVlan"), ("CISCO-STACK-MIB", "brouterEnableAPaRT"), ("CISCO-STACK-MIB", "brouterEnableIpFragmentation"), ("CISCO-STACK-MIB", "brouterPortIpHelpers"), ("CISCO-STACK-MIB", "brouterEnableUnreachables"), ("CISCO-STACK-MIB", "brouterIpx8023RawToFddi"), ("CISCO-STACK-MIB", "brouterIpxSnapToEther"), ("CISCO-STACK-MIB", "brouterEthernetTransmitMax"), ("CISCO-STACK-MIB", "brouterPortNetMask"), ("CISCO-STACK-MIB", "brouterEnableRip"), ("CISCO-STACK-MIB", "brouterPort"), ("CISCO-STACK-MIB", "brouterEnableSpantree"), ("CISCO-STACK-MIB", "brouterFddiTransmitMax"), ("CISCO-STACK-MIB", "brouterEnableFddiCheck"), ("CISCO-STACK-MIB", "brouterPortIpAddr"), ("CISCO-STACK-MIB", "brouterEthernetReceiveMax"), ("CISCO-STACK-MIB", "brouterFddiReceiveMax"), ("CISCO-STACK-MIB", "brouterEnableTransitEncapsulation"), ("CISCO-STACK-MIB", "brouterCamMode"), ("CISCO-STACK-MIB", "brouterPortModule"), ("CISCO-STACK-MIB", "brouterEnableGiantCheck"), ("CISCO-STACK-MIB", "brouterPortBroadcast"), ) )
if mibBuilder.loadTexts: brouteEnableGroup.setDescription("A collection of objects providing information                      about the combined bridging/routing feature.\n\nImplementation of this group is optional. If the\ncombined bridging/routing feature is supported,\nthe group should be implemented.")
filterGroup = ObjectGroup((0, 1, 31, 2, 17)).setObjects(*(("CISCO-STACK-MIB", "filterProtocolType"), ("CISCO-STACK-MIB", "filterVendorId"), ("CISCO-STACK-MIB", "filterTestPort"), ("CISCO-STACK-MIB", "filterMacType"), ("CISCO-STACK-MIB", "filterMacModule"), ("CISCO-STACK-MIB", "filterPortBroadcastThreshold"), ("CISCO-STACK-MIB", "filterTestMask"), ("CISCO-STACK-MIB", "filterPort"), ("CISCO-STACK-MIB", "filterTestValue"), ("CISCO-STACK-MIB", "filterTestModule"), ("CISCO-STACK-MIB", "filterVendorModule"), ("CISCO-STACK-MIB", "filterTestOffset"), ("CISCO-STACK-MIB", "filterProtocolValue"), ("CISCO-STACK-MIB", "filterVendorPort"), ("CISCO-STACK-MIB", "filterProtocolPort"), ("CISCO-STACK-MIB", "filterProtocolModule"), ("CISCO-STACK-MIB", "filterPortBroadcastThrottle"), ("CISCO-STACK-MIB", "filterMacPort"), ("CISCO-STACK-MIB", "filterVendorType"), ("CISCO-STACK-MIB", "filterMacAddress"), ("CISCO-STACK-MIB", "filterPortComplex"), ("CISCO-STACK-MIB", "filterPortBroadcastDiscards"), ("CISCO-STACK-MIB", "filterPortModule"), ("CISCO-STACK-MIB", "filterTestType"), ("CISCO-STACK-MIB", "filterTestIndex"), ) )
if mibBuilder.loadTexts: filterGroup.setDescription("A collection of objects providing information                      about the port filtering feature.\n\nImplementation of this group is optional. If the\nport filtering feature is supported, parts or all\nof this group should be implemented.")
monitorGroup = ObjectGroup((0, 1, 31, 2, 18)).setObjects(*(("CISCO-STACK-MIB", "monitorDestinationPort"), ("CISCO-STACK-MIB", "monitorOperSourcePorts"), ("CISCO-STACK-MIB", "monitorEnable"), ("CISCO-STACK-MIB", "monitorAdminSourcePorts"), ("CISCO-STACK-MIB", "monitorDirection"), ("CISCO-STACK-MIB", "monitorDestinationModule"), ("CISCO-STACK-MIB", "monitorSourcePort"), ("CISCO-STACK-MIB", "monitorSourceModule"), ) )
if mibBuilder.loadTexts: monitorGroup.setDescription("The collection of deprecated objects for                       managing the Switched Port Analyzer (SPAN)\nfeatures.")
vlanGroup = ObjectGroup((0, 1, 31, 2, 19)).setObjects(*(("CISCO-STACK-MIB", "vlanPortIslVlansAllowed"), ("CISCO-STACK-MIB", "vlanPortVlan"), ("CISCO-STACK-MIB", "vlanPortSwitchLevel"), ("CISCO-STACK-MIB", "vlanPort"), ("CISCO-STACK-MIB", "vlanPortIslOperStatus"), ("CISCO-STACK-MIB", "vlanPortIslPriorityVlans"), ("CISCO-STACK-MIB", "vlanSpantreeEnable"), ("CISCO-STACK-MIB", "vlanIfIndex"), ("CISCO-STACK-MIB", "vlanPortIslAdminStatus"), ("CISCO-STACK-MIB", "vlanPortModule"), ("CISCO-STACK-MIB", "vlanPortOperStatus"), ("CISCO-STACK-MIB", "vlanIndex"), ("CISCO-STACK-MIB", "vlanPortAdminStatus"), ) )
if mibBuilder.loadTexts: vlanGroup.setDescription("A collection of objects providing information                      about the Virtual LAN features.\n\nImplementation of this group is optional.")
vmpsGroup = ObjectGroup((0, 1, 31, 2, 20)).setObjects(*(("CISCO-STACK-MIB", "vmpsAction"), ("CISCO-STACK-MIB", "vmpsAccessed"), ("CISCO-STACK-MIB", "vmpsType"), ("CISCO-STACK-MIB", "vmpsAddr"), ) )
if mibBuilder.loadTexts: vmpsGroup.setDescription("A collection of objects providing information                      about the Vlan Membership Policy Server feature.\n\nImplementation of this group is optional. If the\nVlan Membership Policy Server feature is\nsupported, the entire group should be\nimplemented.")
tokenRingGroup = ObjectGroup((0, 1, 31, 2, 21)).setObjects(*(("CISCO-STACK-MIB", "tokenRingDripAreReductionMode"), ("CISCO-STACK-MIB", "tokenRingModuleIndex"), ("CISCO-STACK-MIB", "tokenRingDripOwnerNodeID"), ("CISCO-STACK-MIB", "tokenRingDripRemotePortStatus"), ("CISCO-STACK-MIB", "tokenRingPortPriorityMinXmit"), ("CISCO-STACK-MIB", "tokenRingPortPriorityThresh"), ("CISCO-STACK-MIB", "tokenRingDripAdvertsTransmitted"), ("CISCO-STACK-MIB", "tokenRingPortSetACbits"), ("CISCO-STACK-MIB", "tokenRingDripRemotePortConfigured"), ("CISCO-STACK-MIB", "tokenRingDripAdvertsReceived"), ("CISCO-STACK-MIB", "tokenRingDripInputQueueDrops"), ("CISCO-STACK-MIB", "tokenRingDripBackupCrf"), ("CISCO-STACK-MIB", "tokenRingPortMode"), ("CISCO-STACK-MIB", "tokenRingPortCfgLossThresh"), ("CISCO-STACK-MIB", "tokenRingPortIndex"), ("CISCO-STACK-MIB", "tokenRingDripOutputQueueDrops"), ("CISCO-STACK-MIB", "tokenRingDripLocalPortStatus"), ("CISCO-STACK-MIB", "tokenRingDripLastRevision"), ("CISCO-STACK-MIB", "tokenRingPortCfgLossInterval"), ("CISCO-STACK-MIB", "tokenRingDripDistributedCrf"), ("CISCO-STACK-MIB", "tokenRingDripAdvertsProcessed"), ("CISCO-STACK-MIB", "tokenRingPortEarlyTokenRel"), ("CISCO-STACK-MIB", "tokenRingDripDistCrfMode"), ("CISCO-STACK-MIB", "tokenRingDripLastChangedRevision"), ("CISCO-STACK-MIB", "tokenRingDripVlan"), ("CISCO-STACK-MIB", "tokenRingDripLocalNodeID"), ) )
if mibBuilder.loadTexts: tokenRingGroup.setDescription("A collection of objects providing information                      about the token ring features.\n\nImplementation of this group is optional. If the\ntoken ring features are supported, the entire\ngroup should be implemented.")
mcastGroup = ObjectGroup((0, 1, 31, 2, 22)).setObjects(*(("CISCO-STACK-MIB", "mcastEnableIgmp"), ("CISCO-STACK-MIB", "mcastRouterModuleIndex"), ("CISCO-STACK-MIB", "mcastRouterOperStatus"), ("CISCO-STACK-MIB", "mcastRouterPortIndex"), ("CISCO-STACK-MIB", "mcastEnableCgmp"), ("CISCO-STACK-MIB", "mcastRouterAdminStatus"), ) )
if mibBuilder.loadTexts: mcastGroup.setDescription("A collection of objects providing information                      about the multicast features.\n\nImplementation of this group is optional. If the\nmulticast features are supported, the entire group\nshould be implemented.")
dnsGroup = ObjectGroup((0, 1, 31, 2, 23)).setObjects(*(("CISCO-STACK-MIB", "dnsServerAddr"), ("CISCO-STACK-MIB", "dnsEnable"), ("CISCO-STACK-MIB", "dnsDomainName"), ("CISCO-STACK-MIB", "dnsServerType"), ) )
if mibBuilder.loadTexts: dnsGroup.setDescription("A collection of objects providing information                      about the DNS feature.\n\nImplementation of this group is optional. If the\nDNS feature is supported, the entire group\nshould be implemented.")
syslogGroup = ObjectGroup((0, 1, 31, 2, 24)).setObjects(*(("CISCO-STACK-MIB", "syslogMessageFacility"), ("CISCO-STACK-MIB", "syslogServerAddr"), ("CISCO-STACK-MIB", "syslogTimeStampOption"), ("CISCO-STACK-MIB", "syslogConsoleEnable"), ("CISCO-STACK-MIB", "syslogServerType"), ("CISCO-STACK-MIB", "syslogHostEnable"), ("CISCO-STACK-MIB", "syslogMessageSeverity"), ) )
if mibBuilder.loadTexts: syslogGroup.setDescription("A collection of objects providing information                      about the system log feature.\n\nImplementation of this group is optional. If the\nsystem log feature is supported, the entire group\nshould be implemented.")
ntpGroup = ObjectGroup((0, 1, 31, 2, 25)).setObjects(*(("CISCO-STACK-MIB", "ntpSummerTimezoneName"), ("CISCO-STACK-MIB", "ntpTimezoneOffsetHour"), ("CISCO-STACK-MIB", "ntpBcastDelay"), ("CISCO-STACK-MIB", "ntpServerType"), ("CISCO-STACK-MIB", "ntpClient"), ("CISCO-STACK-MIB", "ntpTimezoneOffsetMinute"), ("CISCO-STACK-MIB", "ntpTimezoneName"), ("CISCO-STACK-MIB", "ntpBcastClient"), ("CISCO-STACK-MIB", "ntpServerAddress"), ("CISCO-STACK-MIB", "ntpSummertimeStatus"), ) )
if mibBuilder.loadTexts: ntpGroup.setDescription("A collection of objects providing information                      about the network time protocol feature.\n\nImplementation of this group is optional. If the\nnetwork time protocol feature is supported, the\nentire group should be implemented.")
ipPermitGroup = ObjectGroup((0, 1, 31, 2, 26)).setObjects(*(("CISCO-STACK-MIB", "ipPermitDeniedAddress"), ("CISCO-STACK-MIB", "ipPermitDeniedAccess"), ("CISCO-STACK-MIB", "ipPermitType"), ("CISCO-STACK-MIB", "ipPermitAddress"), ("CISCO-STACK-MIB", "ipPermitMask"), ("CISCO-STACK-MIB", "ipPermitEnable"), ("CISCO-STACK-MIB", "ipPermitDeniedTime"), ) )
if mibBuilder.loadTexts: ipPermitGroup.setDescription("A collection of objects providing information                      about the ip permit list feature.\n\nImplementation of this group is optional. If the\nip permit list feature is supported, the entire\ngroup should be implemented.")
mdgGatewayGroup = ObjectGroup((0, 1, 31, 2, 27)).setObjects(*(("CISCO-STACK-MIB", "mdgGatewayType"), ("CISCO-STACK-MIB", "mdgGatewayAddr"), ) )
if mibBuilder.loadTexts: mdgGatewayGroup.setDescription("A collection of objects providing information                      about the multiple default gateway feature.\n\nImplementation of this group is optional. If the\nmultiple default gateway feature is supported,\nthe entire group should be implemented.")
traceRouteGroup = ObjectGroup((0, 1, 31, 2, 28)).setObjects(*(("CISCO-STACK-MIB", "traceRouteMaxQueries"), ("CISCO-STACK-MIB", "traceRouteDataGatewayIp"), ("CISCO-STACK-MIB", "traceRouteHost"), ("CISCO-STACK-MIB", "traceRouteQueryTime"), ("CISCO-STACK-MIB", "traceRouteQueryDNSEnable"), ("CISCO-STACK-MIB", "traceRouteDataRtt"), ("CISCO-STACK-MIB", "traceRouteQueryIndex"), ("CISCO-STACK-MIB", "traceRouteDataErrors"), ("CISCO-STACK-MIB", "traceRouteDataGatewayName"), ("CISCO-STACK-MIB", "traceRouteQueryStatus"), ("CISCO-STACK-MIB", "traceRouteQueryResult"), ("CISCO-STACK-MIB", "traceRouteDataIndex"), ("CISCO-STACK-MIB", "traceRouteQueryUDPPort"), ("CISCO-STACK-MIB", "traceRouteQueryInitTTL"), ("CISCO-STACK-MIB", "traceRouteQueryOwner"), ("CISCO-STACK-MIB", "traceRouteQueryMaxTTL"), ("CISCO-STACK-MIB", "traceRouteDataHopCount"), ("CISCO-STACK-MIB", "traceRouteQueryPacketSize"), ("CISCO-STACK-MIB", "traceRouteQueryTOS"), ("CISCO-STACK-MIB", "traceRouteQueryWaitingTime"), ("CISCO-STACK-MIB", "traceRouteQueryPacketCount"), ) )
if mibBuilder.loadTexts: traceRouteGroup.setDescription("A collection of objects providing information                      about the trace route feature.\n\nImplementation of this group is optional. If the\ntrace route feature is supported, the entire group\nshould be implemented.")
deprecatedObjectGroup = ObjectGroup((0, 1, 31, 2, 29)).setObjects(*(("CISCO-STACK-MIB", "moduleFwHiVersion"), ("CISCO-STACK-MIB", "moduleHwHiVersion"), ("CISCO-STACK-MIB", "sysCommunityString"), ("CISCO-STACK-MIB", "chassisSerialNumber"), ("CISCO-STACK-MIB", "moduleSerialNumber"), ("CISCO-STACK-MIB", "moduleHwLoVersion"), ("CISCO-STACK-MIB", "sysCommunityAccess"), ("CISCO-STACK-MIB", "moduleSwLoVersion"), ("CISCO-STACK-MIB", "moduleSwHiVersion"), ("CISCO-STACK-MIB", "brouterCamAgingTime"), ("CISCO-STACK-MIB", "moduleFwLoVersion"), ) )
if mibBuilder.loadTexts: deprecatedObjectGroup.setDescription("A collection of objects that have been                      deprecated.")
ntpAuthenticationGroup = ObjectGroup((0, 1, 31, 2, 30)).setObjects(*(("CISCO-STACK-MIB", "ntpAuthenticationType"), ("CISCO-STACK-MIB", "ntpAuthenticationTrustedMode"), ("CISCO-STACK-MIB", "ntpAuthenticationEnable"), ("CISCO-STACK-MIB", "ntpAuthenticationPublicKey"), ("CISCO-STACK-MIB", "ntpServerPublicKey"), ("CISCO-STACK-MIB", "ntpAuthenticationSecretKey"), ) )
if mibBuilder.loadTexts: ntpAuthenticationGroup.setDescription("A collection of objects providing information                      about the network time protocol authentication\nfeature.\n\nImplementation of this group is optional. If the\nnetwork time protocol authentication feature is\nsupported, the entire group should be\nimplemented.")
tokenRingSoftErrorMonitorGroup = ObjectGroup((0, 1, 31, 2, 31)).setObjects(*(("CISCO-STACK-MIB", "tokenRingPortSoftErrResetCounters"), ("CISCO-STACK-MIB", "tokenRingPortSoftErrReportInterval"), ("CISCO-STACK-MIB", "tokenRingPortSoftErrLastCounterReset"), ("CISCO-STACK-MIB", "tokenRingPortSoftErrThresh"), ("CISCO-STACK-MIB", "tokenRingPortSoftErrEnable"), ) )
if mibBuilder.loadTexts: tokenRingSoftErrorMonitorGroup.setDescription("A collection of objects providing information                      about the token ring port soft error monitoring\nfeature.\n\nImplementation of this group is optional. If the\ntoken ring features are supported, the entire\ngroup should be implemented.")
portCpbGroup1 = ObjectGroup((0, 1, 31, 2, 32)).setObjects(*(("CISCO-STACK-MIB", "portCpbUdld"), ) )
if mibBuilder.loadTexts: portCpbGroup1.setDescription("A collection of objects providing additional                      information about the port capabilities on the\ndevice.\n\nImplementation of this group is Optional.")
portSecurityGroup1 = ObjectGroup((0, 1, 31, 2, 33)).setObjects(*(("CISCO-STACK-MIB", "portSecurityShutdownTimeOut"), ("CISCO-STACK-MIB", "portSecurityViolationPolicy"), ("CISCO-STACK-MIB", "portSecurityExtSecureSrcAddr"), ("CISCO-STACK-MIB", "portSecurityAgingTime"), ("CISCO-STACK-MIB", "portSecurityMaxSrcAddr"), ("CISCO-STACK-MIB", "portSecurityExtModuleIndex"), ("CISCO-STACK-MIB", "portSecurityExtPortIndex"), ("CISCO-STACK-MIB", "portSecurityExtControlStatus"), ) )
if mibBuilder.loadTexts: portSecurityGroup1.setDescription("A collection of objects providing additional                        information for supporting port security feature\nwith the multiple secured source MAC addresses.\nImplementation of this group is optional.")
fileCopyGroup = ObjectGroup((0, 1, 31, 2, 34)).setObjects(*(("CISCO-STACK-MIB", "fileCopyResultRcpErrorMessage"), ("CISCO-STACK-MIB", "fileCopyProtocol"), ("CISCO-STACK-MIB", "fileCopyRemoteServer"), ("CISCO-STACK-MIB", "fileCopyModuleNumber"), ("CISCO-STACK-MIB", "fileCopyResult"), ("CISCO-STACK-MIB", "fileCopyUserName"), ("CISCO-STACK-MIB", "fileCopyAction"), ("CISCO-STACK-MIB", "fileCopyDstFileName"), ("CISCO-STACK-MIB", "fileCopySrcFileName"), ) )
if mibBuilder.loadTexts: fileCopyGroup.setDescription("A collection of objects providing information                      about the tftp/rcp or local file upload/download\nfeatures.\n\nImplementation of this group is optional. If the\ntftp upload/download features are supported, the\nentire group should be implemented.")
optionalSystemMiscGroup1 = ObjectGroup((0, 1, 31, 2, 35)).setObjects(*(("CISCO-STACK-MIB", "sysStartupConfigSource"), ("CISCO-STACK-MIB", "sysStartupConfigSourceFile"), ("CISCO-STACK-MIB", "sysConfigSupervisorModuleNo"), ("CISCO-STACK-MIB", "sysStandbyPortEnable"), ) )
if mibBuilder.loadTexts: optionalSystemMiscGroup1.setDescription("A collection of objects providing information                      about the miscellaneous system features.\n\nImplementation of this group is optional.")
ipPermitGroup1 = ObjectGroup((0, 1, 31, 2, 36)).setObjects(*(("CISCO-STACK-MIB", "ipPermitAccessType"), ) )
if mibBuilder.loadTexts: ipPermitGroup1.setDescription("A collection of objects providing additional                      information for allowing the ip permit host with\nthe specified access type.\n\nImplementation of this group is optional. If the\nip permit list enhancement feature is supported,\nthis group should be implemented.")
optionalSystemMiscGroup2 = ObjectGroup((0, 1, 31, 2, 37)).setObjects(*(("CISCO-STACK-MIB", "sysTrafficMonitorHighWaterMark"), ("CISCO-STACK-MIB", "sysHighAvailabilityVersioningEnable"), ("CISCO-STACK-MIB", "sysHighAvailabilityNotRunningReason"), ("CISCO-STACK-MIB", "sysErrDisableTimeoutInterval"), ("CISCO-STACK-MIB", "sysErrDisableTimeoutEnable"), ("CISCO-STACK-MIB", "sysHighAvailabilityEnable"), ("CISCO-STACK-MIB", "sysPortFastBpduGuard"), ("CISCO-STACK-MIB", "sysHighAvailabilityOperStatus"), ) )
if mibBuilder.loadTexts: optionalSystemMiscGroup2.setDescription("A collection of objects providing information                      about the miscellaneous system features.\n\nImplementation of this group is optional.")
filterGroup1 = ObjectGroup((0, 1, 31, 2, 38)).setObjects(*(("CISCO-STACK-MIB", "filterPortBroadcastThresholdFraction"), ) )
if mibBuilder.loadTexts: filterGroup1.setDescription("A collection of objects providing information                      about the port filtering feature.\n\nImplementation of this group is optional. If the\nport filtering feature is supported, parts or all\nof this group should be implemented.")
mcastGroup1 = ObjectGroup((0, 1, 31, 2, 39)).setObjects(*(("CISCO-STACK-MIB", "mcastEnableRgmp"), ) )
if mibBuilder.loadTexts: mcastGroup1.setDescription("A collection of objects providing information                      about the multicast features.\n\nImplementation of this group is optional. If the\nmulticast features are supported, the entire group\nshould be implemented.")
portGroup1 = ObjectGroup((0, 1, 31, 2, 40)).setObjects(*(("CISCO-STACK-MIB", "portAdditionalOperStatus"), ("CISCO-STACK-MIB", "portEntPhysicalIndex"), ) )
if mibBuilder.loadTexts: portGroup1.setDescription("A collection of objects providing information                      about the ports on the device.\n\nImplementation of this group is optional.")
chassisGroup1 = ObjectGroup((0, 1, 31, 2, 41)).setObjects(*(("CISCO-STACK-MIB", "chassisPs3Type"), ("CISCO-STACK-MIB", "chassisPEMInstalled"), ("CISCO-STACK-MIB", "chassisPs3Status"), ("CISCO-STACK-MIB", "chassisPs3TestResult"), ) )
if mibBuilder.loadTexts: chassisGroup1.setDescription("A collection of objects providing information                      about the chassis of the device.\n\nThis group must be implemented by systems that can\nhave 3 or more power supplies.")
moduleGroup1 = ObjectGroup((0, 1, 31, 2, 42)).setObjects(*(("CISCO-STACK-MIB", "moduleEntPhysicalIndex"), ) )
if mibBuilder.loadTexts: moduleGroup1.setDescription("A collection of objects providing information                      about the modules on the device.\n\nImplementation of this group is mandatory.")
portCpbGroup2 = ObjectGroup((0, 1, 31, 2, 43)).setObjects(*(("CISCO-STACK-MIB", "portCpbSpan"), ) )
if mibBuilder.loadTexts: portCpbGroup2.setDescription("A collection of objects providing additional                      information about the port capabilities on the\ndevice.\n\nImplementation of this group is Optional.")
voiceGroup = ObjectGroup((0, 1, 31, 2, 44)).setObjects(*(("CISCO-STACK-MIB", "voicePortIfGatewayAddress"), ("CISCO-STACK-MIB", "voicePortIfIpAddress"), ("CISCO-STACK-MIB", "voicePortIfDnsServerAddress"), ("CISCO-STACK-MIB", "voicePortIfDnsDomain"), ("CISCO-STACK-MIB", "voicePortIfIpNetMask"), ("CISCO-STACK-MIB", "voicePortIfDHCPEnabled"), ("CISCO-STACK-MIB", "voicePortIfOperDnsDomain"), ("CISCO-STACK-MIB", "voicePortCallManagerIpAddr"), ("CISCO-STACK-MIB", "voicePortOperDnsServerIpAddr"), ("CISCO-STACK-MIB", "voicePortOperDnsServerSource"), ("CISCO-STACK-MIB", "voicePortIfTftpServerAddress"), ) )
if mibBuilder.loadTexts: voiceGroup.setDescription("A collection of objects providing information                     about the voice ports on the device.\n\nImplemetation of this group is Optional")
portGroup2 = ObjectGroup((0, 1, 31, 2, 45)).setObjects(*(("CISCO-STACK-MIB", "portInlinePowerDetect"), ) )
if mibBuilder.loadTexts: portGroup2.setDescription("A collection of objects providing information                      about the ports on the device.\n\nImplementation of this group is optional.")
vlanGroup1 = ObjectGroup((0, 1, 31, 2, 46)).setObjects(*(("CISCO-STACK-MIB", "vlanPortAuxiliaryVlan"), ) )
if mibBuilder.loadTexts: vlanGroup1.setDescription("A collection of objects providing information                      about the Virtual LAN features.\n\nImplementation of this group is optional. If the\nVirtual LAN features are supported, the entire\ngroup should be implemented.")
portCpbGroup3 = ObjectGroup((0, 1, 31, 2, 47)).setObjects(*(("CISCO-STACK-MIB", "portCpbAuxiliaryVlan"), ("CISCO-STACK-MIB", "portCpbInlinePower"), ) )
if mibBuilder.loadTexts: portCpbGroup3.setDescription("A collection of objects providing additional                      information about the port capabilities on the\ndevice.\n\nImplementation of this group is Optional.")
moduleGroup2 = ObjectGroup((0, 1, 31, 2, 48)).setObjects(*(("CISCO-STACK-MIB", "moduleAdditionalStatus"), ) )
if mibBuilder.loadTexts: moduleGroup2.setDescription("A collection of objects providing information                      about the modules on the device.\n\nImplementation of this group is mandatory.")
switchAccelerationModuleGroup = ObjectGroup((0, 1, 31, 2, 49)).setObjects(*(("CISCO-STACK-MIB", "switchAccelerationModuleIndex"), ("CISCO-STACK-MIB", "switchAccelerationModuleEnable"), ) )
if mibBuilder.loadTexts: switchAccelerationModuleGroup.setDescription("A collection of objects providing information                      about the modules switch acceleration\nconfiguration.\n\nImplementation of this group is mandatory if the\nmodule switch acceleration feature is supported.")
optionalSystemMiscGroup3 = ObjectGroup((0, 1, 31, 2, 50)).setObjects(*(("CISCO-STACK-MIB", "sysExtendedRmonNetflowModuleMask"), ) )
if mibBuilder.loadTexts: optionalSystemMiscGroup3.setDescription("A collection of objects providing information                      about the miscellaneous system features.\nThe sysExtendedRmonNetflowModuleMask object is\noptional object and it will only be supported in\nthe platform supporting multiple NAM (Network\nAnalysis Module) cards.\nImplementation of this group is optional.")
optionalSystemMiscGroup4 = ObjectGroup((0, 1, 31, 2, 51)).setObjects(*(("CISCO-STACK-MIB", "sshPublicKeySize"), ) )
if mibBuilder.loadTexts: optionalSystemMiscGroup4.setDescription("A collection of objects providing information                      about the miscellaneous system features.")
vlanTrunkMappingGroup = ObjectGroup((0, 1, 31, 2, 52)).setObjects(*(("CISCO-STACK-MIB", "vlanTrunkMappingMax"), ("CISCO-STACK-MIB", "vlanTrunkMappingOper"), ("CISCO-STACK-MIB", "vlanTrunkMappingType"), ("CISCO-STACK-MIB", "vlanTrunkMappingToVlan"), ("CISCO-STACK-MIB", "vlanTrunkMappingStatus"), ) )
if mibBuilder.loadTexts: vlanTrunkMappingGroup.setDescription("A collection of objects providing information                      about the trunk VLAN to VLAN associations.\n\nImplementation of this group is mandatory if the\ntrunk VLAN to VLAN association feature is\nsupported on the device.")
portJumboFrameGroup = ObjectGroup((0, 1, 31, 2, 53)).setObjects(*(("CISCO-STACK-MIB", "portJumboFrameModuleIndex"), ("CISCO-STACK-MIB", "portJumboFramePortIndex"), ("CISCO-STACK-MIB", "portJumboFrameEnable"), ) )
if mibBuilder.loadTexts: portJumboFrameGroup.setDescription("A collection of objects providing information                      about the port jumbo frame feature on the device.\n\nImplementation of this group is mandatory if the\nport jumbo frame feature is supported on the\ndevice.")
portCpbGroup4 = ObjectGroup((0, 1, 31, 2, 54)).setObjects(*(("CISCO-STACK-MIB", "portCpbCosRewrite"), ("CISCO-STACK-MIB", "portCpbTosRewrite"), ("CISCO-STACK-MIB", "portCpbCopsGrouping"), ) )
if mibBuilder.loadTexts: portCpbGroup4.setDescription("A collection of objects providing additional                      information about the port capabilities on the\ndevice.\nImplementation of this group is Optional.")
fileCopyGroup2 = ObjectGroup((0, 1, 31, 2, 55)).setObjects(*(("CISCO-STACK-MIB", "fileCopyRuntimeConfigPart"), ) )
if mibBuilder.loadTexts: fileCopyGroup2.setDescription("A collection of objects providing additional                      information about tftp/rcp or local file\nupload/download features.\n\nImplementation of this group is optional.")
systemRmonGroup2 = ObjectGroup((0, 1, 31, 2, 56)).setObjects(*(("CISCO-STACK-MIB", "sysMaxRmonMemory"), ) )
if mibBuilder.loadTexts: systemRmonGroup2.setDescription("A collection of object providing RMON max memory                     usage control.")
filterGroup2 = ObjectGroup((0, 1, 31, 2, 57)).setObjects(*(("CISCO-STACK-MIB", "filterPortSuppressionOption"), ) )
if mibBuilder.loadTexts: filterGroup2.setDescription("A collection of objects providing information                      about the unicast/multicast port filtering\nfeature.")
optionalSystemMiscGroup5 = ObjectGroup((0, 1, 31, 2, 58)).setObjects(*(("CISCO-STACK-MIB", "sysMacReductionAdminEnable"), ("CISCO-STACK-MIB", "sysMacReductionOperEnable"), ) )
if mibBuilder.loadTexts: optionalSystemMiscGroup5.setDescription("A collection of objects providing information                      about the miscellaneous system features.")
syslogGroup2 = ObjectGroup((0, 1, 31, 2, 59)).setObjects(*(("CISCO-STACK-MIB", "syslogTelnetEnable"), ) )
if mibBuilder.loadTexts: syslogGroup2.setDescription("A collection of object providing control about                      whether the syslog messages should be sent to\ntelnet sessions.\n\nImplementation of this group is optional.")
systemStatusGroup = ObjectGroup((0, 1, 31, 2, 60)).setObjects(*(("CISCO-STACK-MIB", "sysStatus"), ) )
if mibBuilder.loadTexts: systemStatusGroup.setDescription("A collection of object providing the system                       LED status.\n\nImplementation of this group is optional.")
configurationGroup = ObjectGroup((0, 1, 31, 2, 61)).setObjects(*(("CISCO-STACK-MIB", "configWriteMem"), ("CISCO-STACK-MIB", "configWriteMemStatus"), ("CISCO-STACK-MIB", "configTextFileLocation"), ("CISCO-STACK-MIB", "configMode"), ) )
if mibBuilder.loadTexts: configurationGroup.setDescription("A collection of object providing the information                      about the configuration mode to store the\nconfiguration information.\n\nImplementation of this group is optional.")
filterGroup3 = ObjectGroup((0, 1, 31, 2, 62)).setObjects(*(("CISCO-STACK-MIB", "filterPortSuppressionViolation"), ) )
if mibBuilder.loadTexts: filterGroup3.setDescription("A collection of objects providing additional                      information about  about the Broadcast\nSuppression Violation for port filtering feature.\n\nImplementation of this group is optional.")
portGroup3 = ObjectGroup((0, 1, 31, 2, 63)).setObjects(*(("CISCO-STACK-MIB", "portErrDisableTimeOutEnable"), ) )
if mibBuilder.loadTexts: portGroup3.setDescription("A collection of objects providing additional                      information about the ports on the device.\n\nImplementation of this group is optional.")
portCpbGroup5 = ObjectGroup((0, 1, 31, 2, 64)).setObjects(*(("CISCO-STACK-MIB", "portCpbDot1x"), ("CISCO-STACK-MIB", "portCpbIgmpFilter"), ) )
if mibBuilder.loadTexts: portCpbGroup5.setDescription("A collection of objects providing additional                      information about the port capabilities on the\ndevice.\n\nImplementation of this group is Optional.")
authenticationGroup1 = ObjectGroup((0, 1, 31, 2, 65)).setObjects(*(("CISCO-STACK-MIB", "radiusRetransmits"), ("CISCO-STACK-MIB", "tacacsDirectedRequest"), ("CISCO-STACK-MIB", "radiusAuthKey"), ("CISCO-STACK-MIB", "tacacsAuthKey"), ("CISCO-STACK-MIB", "radiusServerAuthPort"), ("CISCO-STACK-MIB", "radiusServerType"), ("CISCO-STACK-MIB", "radiusDeadtime"), ("CISCO-STACK-MIB", "tacacsServerAddr"), ("CISCO-STACK-MIB", "radiusTimeout"), ("CISCO-STACK-MIB", "radiusServerAddr"), ("CISCO-STACK-MIB", "tacacsServerType"), ) )
if mibBuilder.loadTexts: authenticationGroup1.setDescription("A collection of objects providing information                      about the authentication features.\n\nImplementation of this group is optional.")
systemMiscGroup1 = ObjectGroup((0, 1, 31, 2, 66)).setObjects(*(("CISCO-STACK-MIB", "sysInsertMode"), ("CISCO-STACK-MIB", "sysIpVlan"), ("CISCO-STACK-MIB", "sysEnableRedirects"), ("CISCO-STACK-MIB", "sysArpAgingTime"), ("CISCO-STACK-MIB", "sysCommunityRwa"), ("CISCO-STACK-MIB", "sysBaudRate"), ("CISCO-STACK-MIB", "sysAttachType"), ("CISCO-STACK-MIB", "sysCommunityRo"), ("CISCO-STACK-MIB", "sysCommunityRw"), ("CISCO-STACK-MIB", "sysMgmtType"), ("CISCO-STACK-MIB", "sysEnableModem"), ) )
if mibBuilder.loadTexts: systemMiscGroup1.setDescription("A collection of objects providing information                      about the miscellaneous system features.")
systemTrapGroup1 = ObjectGroup((0, 1, 31, 2, 67)).setObjects(*(("CISCO-STACK-MIB", "sysEnableRepeaterTraps"), ("CISCO-STACK-MIB", "sysEnableModuleTraps"), ("CISCO-STACK-MIB", "sysEnableBridgeTraps"), ("CISCO-STACK-MIB", "sysEnableChassisTraps"), ) )
if mibBuilder.loadTexts: systemTrapGroup1.setDescription("A collection of objects providing information                      about the SNMP traps feature.")
optionalSystemMiscGroup6 = ObjectGroup((0, 1, 31, 2, 68)).setObjects(*(("CISCO-STACK-MIB", "sysTrafficMonitorHighWaterMark"), ("CISCO-STACK-MIB", "sysErrDisableTimeoutEnable"), ("CISCO-STACK-MIB", "sysHighAvailabilityOperStatus"), ("CISCO-STACK-MIB", "sysErrDisableTimeoutInterval"), ("CISCO-STACK-MIB", "sysHighAvailabilityVersioningEnable"), ("CISCO-STACK-MIB", "sysHighAvailabilityNotRunningReason"), ("CISCO-STACK-MIB", "sysHighAvailabilityEnable"), ) )
if mibBuilder.loadTexts: optionalSystemMiscGroup6.setDescription("A collection of objects providing information                      about the miscellaneous system features.\n\nImplementation of this group is optional.")
optionalChassisGroup1 = ObjectGroup((0, 1, 31, 2, 69)).setObjects(*(("CISCO-STACK-MIB", "chassisPs2TestResult"), ("CISCO-STACK-MIB", "chassisSlotConfig"), ("CISCO-STACK-MIB", "chassisFanTestResult"), ("CISCO-STACK-MIB", "chassisModel"), ("CISCO-STACK-MIB", "chassisPs1TestResult"), ) )
if mibBuilder.loadTexts: optionalChassisGroup1.setDescription("A collection of objects providing information                      about the chassis of the device.")
portGroup4 = ObjectGroup((0, 1, 31, 2, 70)).setObjects(*(("CISCO-STACK-MIB", "portAdminSpeed"), ("CISCO-STACK-MIB", "portIndex"), ("CISCO-STACK-MIB", "portAdminRxFlowControl"), ("CISCO-STACK-MIB", "portOperTxFlowControl"), ("CISCO-STACK-MIB", "portCrossGroupIndex"), ("CISCO-STACK-MIB", "portAdditionalStatus"), ("CISCO-STACK-MIB", "portDuplex"), ("CISCO-STACK-MIB", "portCrossIndex"), ("CISCO-STACK-MIB", "portMacControlUnknownProtocolFrames"), ("CISCO-STACK-MIB", "portOperRxFlowControl"), ("CISCO-STACK-MIB", "portIfIndex"), ("CISCO-STACK-MIB", "portModuleIndex"), ("CISCO-STACK-MIB", "portMacControlPauseReceiveFrames"), ("CISCO-STACK-MIB", "portOperStatus"), ("CISCO-STACK-MIB", "portName"), ("CISCO-STACK-MIB", "portType"), ("CISCO-STACK-MIB", "portMacControlTransmitFrames"), ("CISCO-STACK-MIB", "portAdminTxFlowControl"), ("CISCO-STACK-MIB", "portMacControlPauseTransmitFrames"), ("CISCO-STACK-MIB", "portLinkFaultStatus"), ("CISCO-STACK-MIB", "portMacControlReceiveFrames"), ) )
if mibBuilder.loadTexts: portGroup4.setDescription("A collection of objects providing information                      about the ports on the device.")
vlanGroup2 = ObjectGroup((0, 1, 31, 2, 71)).setObjects(*(("CISCO-STACK-MIB", "vlanPortModule"), ("CISCO-STACK-MIB", "vlanPortIslPriorityVlans"), ("CISCO-STACK-MIB", "vlanPort"), ("CISCO-STACK-MIB", "vlanPortIslVlansAllowed"), ("CISCO-STACK-MIB", "vlanPortVlan"), ("CISCO-STACK-MIB", "vlanPortOperStatus"), ("CISCO-STACK-MIB", "vlanPortAdminStatus"), ("CISCO-STACK-MIB", "vlanPortIslAdminStatus"), ("CISCO-STACK-MIB", "vlanPortIslOperStatus"), ("CISCO-STACK-MIB", "vlanPortSwitchLevel"), ) )
if mibBuilder.loadTexts: vlanGroup2.setDescription("A collection of objects providing information                      about the Virtual LAN features.\n\nImplementation of this group is optional.")
ipPermitGroup2 = ObjectGroup((0, 1, 31, 2, 72)).setObjects(*(("CISCO-STACK-MIB", "ipPermitDeniedAddress"), ("CISCO-STACK-MIB", "ipPermitDeniedAccess"), ("CISCO-STACK-MIB", "ipPermitType"), ("CISCO-STACK-MIB", "ipPermitAddress"), ("CISCO-STACK-MIB", "ipPermitMask"), ("CISCO-STACK-MIB", "ipPermitAccessTypeEnable"), ("CISCO-STACK-MIB", "ipPermitDeniedTime"), ) )
if mibBuilder.loadTexts: ipPermitGroup2.setDescription("A collection of objects providing information                      about the ip permit list feature.\n\nImplementation of this group is optional. If the\nip permit list feature is supported, the entire\ngroup should be implemented.")
optionalPortGroup1 = ObjectGroup((0, 1, 31, 2, 73)).setObjects(*(("CISCO-STACK-MIB", "portTopNIOOctets"), ("CISCO-STACK-MIB", "portTopNIOMulticast"), ("CISCO-STACK-MIB", "portTopNGrantedSize"), ("CISCO-STACK-MIB", "portSecurityPortIndex"), ("CISCO-STACK-MIB", "portCpbTrunkEncapsulationType"), ("CISCO-STACK-MIB", "portSecuritySecureSrcAddr"), ("CISCO-STACK-MIB", "portCpbFlowControl"), ("CISCO-STACK-MIB", "portTopNIOPkts"), ("CISCO-STACK-MIB", "portTopNOwner"), ("CISCO-STACK-MIB", "portTopNTimeRemaining"), ("CISCO-STACK-MIB", "portCpbPortfast"), ("CISCO-STACK-MIB", "portCpbSecurity"), ("CISCO-STACK-MIB", "portTopNType"), ("CISCO-STACK-MIB", "portTopNBufferOverFlow"), ("CISCO-STACK-MIB", "portSecurityAdminStatus"), ("CISCO-STACK-MIB", "portTopNStatus"), ("CISCO-STACK-MIB", "portCpbSpeed"), ("CISCO-STACK-MIB", "portCpbModuleIndex"), ("CISCO-STACK-MIB", "portCpbTrunkMode"), ("CISCO-STACK-MIB", "portTopNUtilization"), ("CISCO-STACK-MIB", "portCpbBroadcastSuppression"), ("CISCO-STACK-MIB", "portTopNIndex"), ("CISCO-STACK-MIB", "portTopNIOBroadcast"), ("CISCO-STACK-MIB", "portTopNMode"), ("CISCO-STACK-MIB", "portSecurityLastSrcAddr"), ("CISCO-STACK-MIB", "portTopNStartTime"), ("CISCO-STACK-MIB", "portTopNReportStatus"), ("CISCO-STACK-MIB", "portSecurityModuleIndex"), ("CISCO-STACK-MIB", "portCpbChannel"), ("CISCO-STACK-MIB", "portTopNInErrors"), ("CISCO-STACK-MIB", "portTopNControlIndex"), ("CISCO-STACK-MIB", "portSecurityOperStatus"), ("CISCO-STACK-MIB", "portCpbVlanMembership"), ("CISCO-STACK-MIB", "portCpbPortIndex"), ("CISCO-STACK-MIB", "portTopNRateBase"), ("CISCO-STACK-MIB", "portTopNPortNumber"), ("CISCO-STACK-MIB", "portTopNDuration"), ("CISCO-STACK-MIB", "portTopNRequestedSize"), ("CISCO-STACK-MIB", "portTopNModuleNumber"), ("CISCO-STACK-MIB", "portCpbDuplex"), ) )
if mibBuilder.loadTexts: optionalPortGroup1.setDescription("A collection of objects providing information                      about the ports on the device.\n\nImplementation of this group is Optional.")
optionalSystemTrapGroup1 = ObjectGroup((0, 1, 31, 2, 74)).setObjects(*(("CISCO-STACK-MIB", "sysEnableConfigTraps"), ("CISCO-STACK-MIB", "sysEnableEntityTrap"), ("CISCO-STACK-MIB", "sysEnableVmpsTraps"), ("CISCO-STACK-MIB", "sysEnableIpPermitTraps"), ) )
if mibBuilder.loadTexts: optionalSystemTrapGroup1.setDescription("A collection of objects providing information                      about the SNMP traps feature.\n\nImplementation of this group is optional.")
authenticationGroup2 = ObjectGroup((0, 1, 31, 2, 75)).setObjects(*(("CISCO-STACK-MIB", "tacacsServerAddr"), ("CISCO-STACK-MIB", "radiusRetransmits"), ("CISCO-STACK-MIB", "tacacsDirectedRequest"), ("CISCO-STACK-MIB", "radiusAuthKey"), ("CISCO-STACK-MIB", "radiusTimeout"), ("CISCO-STACK-MIB", "tacacsAuthKey"), ("CISCO-STACK-MIB", "radiusDeadtime"), ("CISCO-STACK-MIB", "tacacsServerType"), ) )
if mibBuilder.loadTexts: authenticationGroup2.setDescription("A collection of objects providing information                      about the authentication features.\n\nImplementation of this group is optional.")
systemTrapGroup2 = ObjectGroup((0, 1, 31, 2, 76)).setObjects(*(("CISCO-STACK-MIB", "sysEnableRepeaterTraps"), ("CISCO-STACK-MIB", "sysEnableModuleTraps"), ("CISCO-STACK-MIB", "sysEnableChassisTraps"), ) )
if mibBuilder.loadTexts: systemTrapGroup2.setDescription("A collection of objects providing information                      about the SNMP traps feature.")
notificationGroup = NotificationGroup((0, 1, 31, 2, 77)).setObjects(*(("CISCO-STACK-MIB", "ipPermitDeniedTrap"), ("CISCO-STACK-MIB", "tokenRingSoftErrExceededTrap"), ("CISCO-STACK-MIB", "moduleDown"), ("CISCO-STACK-MIB", "lerAlarmOn"), ("CISCO-STACK-MIB", "chassisAlarmOn"), ("CISCO-STACK-MIB", "sysConfigChangeTrap"), ("CISCO-STACK-MIB", "lerAlarmOff"), ("CISCO-STACK-MIB", "chassisAlarmOff"), ("CISCO-STACK-MIB", "moduleUp"), ) )
if mibBuilder.loadTexts: notificationGroup.setDescription("A collection of notifications supported on the device.")
ipPermitGroup3 = ObjectGroup((0, 1, 31, 2, 78)).setObjects(*(("CISCO-STACK-MIB", "ipPermitSshConnectLimit"), ("CISCO-STACK-MIB", "ipPermitTelnetConnectLimit"), ) )
if mibBuilder.loadTexts: ipPermitGroup3.setDescription("A collection of objects providing configuration                         information on ip permit connection limit for a \nspecific host.")

# Compliances

ciscoStackgMIBCompliance = ModuleCompliance((0, 1, 31, 1, 1)).setObjects(*(("CISCO-STACK-MIB", "optionalSystemTrapGroup"), ("CISCO-STACK-MIB", "ntpAuthenticationGroup"), ("CISCO-STACK-MIB", "moduleGroup"), ("CISCO-STACK-MIB", "mcastGroup"), ("CISCO-STACK-MIB", "vlanGroup"), ("CISCO-STACK-MIB", "tftpGroup"), ("CISCO-STACK-MIB", "tokenRingGroup"), ("CISCO-STACK-MIB", "mdgGatewayGroup"), ("CISCO-STACK-MIB", "optionalModuleGroup"), ("CISCO-STACK-MIB", "systemFddiGroup"), ("CISCO-STACK-MIB", "systemMiscGroup"), ("CISCO-STACK-MIB", "optionalSystemMiscGroup"), ("CISCO-STACK-MIB", "syslogGroup"), ("CISCO-STACK-MIB", "dnsGroup"), ("CISCO-STACK-MIB", "systemTrapGroup"), ("CISCO-STACK-MIB", "authenticationGroup"), ("CISCO-STACK-MIB", "monitorGroup"), ("CISCO-STACK-MIB", "systemRmonGroup"), ("CISCO-STACK-MIB", "portSecurityGroup1"), ("CISCO-STACK-MIB", "chassisGroup"), ("CISCO-STACK-MIB", "fileCopyGroup"), ("CISCO-STACK-MIB", "filterGroup"), ("CISCO-STACK-MIB", "ipPermitGroup"), ("CISCO-STACK-MIB", "portGroup"), ("CISCO-STACK-MIB", "traceRouteGroup"), ("CISCO-STACK-MIB", "ntpGroup"), ("CISCO-STACK-MIB", "tokenRingSoftErrorMonitorGroup"), ("CISCO-STACK-MIB", "optionalChassisGroup"), ("CISCO-STACK-MIB", "optionalSystemMiscGroup1"), ("CISCO-STACK-MIB", "brouteEnableGroup"), ("CISCO-STACK-MIB", "optionalPortGroup"), ("CISCO-STACK-MIB", "vmpsGroup"), ("CISCO-STACK-MIB", "portCpbGroup1"), ("CISCO-STACK-MIB", "systemTrafficGroup"), ) )
if mibBuilder.loadTexts: ciscoStackgMIBCompliance.setDescription("The compliance statement for entities which                       implement the Cisco stack MIB.")
ciscoStackgMIBCompliance2 = ModuleCompliance((0, 1, 31, 1, 2)).setObjects(*(("CISCO-STACK-MIB", "optionalSystemTrapGroup"), ("CISCO-STACK-MIB", "ntpAuthenticationGroup"), ("CISCO-STACK-MIB", "moduleGroup"), ("CISCO-STACK-MIB", "mcastGroup"), ("CISCO-STACK-MIB", "vlanGroup"), ("CISCO-STACK-MIB", "tftpGroup"), ("CISCO-STACK-MIB", "tokenRingGroup"), ("CISCO-STACK-MIB", "portGroup1"), ("CISCO-STACK-MIB", "mdgGatewayGroup"), ("CISCO-STACK-MIB", "optionalModuleGroup"), ("CISCO-STACK-MIB", "systemFddiGroup"), ("CISCO-STACK-MIB", "systemMiscGroup"), ("CISCO-STACK-MIB", "optionalSystemMiscGroup"), ("CISCO-STACK-MIB", "syslogGroup"), ("CISCO-STACK-MIB", "dnsGroup"), ("CISCO-STACK-MIB", "systemTrapGroup"), ("CISCO-STACK-MIB", "authenticationGroup"), ("CISCO-STACK-MIB", "monitorGroup"), ("CISCO-STACK-MIB", "mcastGroup1"), ("CISCO-STACK-MIB", "ipPermitGroup1"), ("CISCO-STACK-MIB", "systemRmonGroup"), ("CISCO-STACK-MIB", "moduleGroup1"), ("CISCO-STACK-MIB", "portSecurityGroup1"), ("CISCO-STACK-MIB", "chassisGroup1"), ("CISCO-STACK-MIB", "chassisGroup"), ("CISCO-STACK-MIB", "optionalSystemMiscGroup2"), ("CISCO-STACK-MIB", "fileCopyGroup"), ("CISCO-STACK-MIB", "filterGroup"), ("CISCO-STACK-MIB", "ipPermitGroup"), ("CISCO-STACK-MIB", "portGroup"), ("CISCO-STACK-MIB", "traceRouteGroup"), ("CISCO-STACK-MIB", "filterGroup1"), ("CISCO-STACK-MIB", "ntpGroup"), ("CISCO-STACK-MIB", "tokenRingSoftErrorMonitorGroup"), ("CISCO-STACK-MIB", "optionalChassisGroup"), ("CISCO-STACK-MIB", "optionalSystemMiscGroup1"), ("CISCO-STACK-MIB", "brouteEnableGroup"), ("CISCO-STACK-MIB", "optionalPortGroup"), ("CISCO-STACK-MIB", "vmpsGroup"), ("CISCO-STACK-MIB", "portCpbGroup1"), ("CISCO-STACK-MIB", "portCpbGroup2"), ("CISCO-STACK-MIB", "systemTrafficGroup"), ) )
if mibBuilder.loadTexts: ciscoStackgMIBCompliance2.setDescription("The compliance statement for entities which                      implement the Cisco stack MIB.")
ciscoStackgMIBCompliance3 = ModuleCompliance((0, 1, 31, 1, 3)).setObjects(*(("CISCO-STACK-MIB", "moduleGroup"), ("CISCO-STACK-MIB", "mcastGroup"), ("CISCO-STACK-MIB", "voiceGroup"), ("CISCO-STACK-MIB", "filterGroup1"), ("CISCO-STACK-MIB", "portGroup1"), ("CISCO-STACK-MIB", "portGroup2"), ("CISCO-STACK-MIB", "mdgGatewayGroup"), ("CISCO-STACK-MIB", "chassisGroup1"), ("CISCO-STACK-MIB", "dnsGroup"), ("CISCO-STACK-MIB", "monitorGroup"), ("CISCO-STACK-MIB", "filterGroup"), ("CISCO-STACK-MIB", "syslogGroup"), ("CISCO-STACK-MIB", "ntpAuthenticationGroup"), ("CISCO-STACK-MIB", "optionalModuleGroup"), ("CISCO-STACK-MIB", "ipPermitGroup"), ("CISCO-STACK-MIB", "systemMiscGroup"), ("CISCO-STACK-MIB", "vlanGroup1"), ("CISCO-STACK-MIB", "mcastGroup1"), ("CISCO-STACK-MIB", "moduleGroup2"), ("CISCO-STACK-MIB", "moduleGroup1"), ("CISCO-STACK-MIB", "portSecurityGroup1"), ("CISCO-STACK-MIB", "optionalSystemMiscGroup1"), ("CISCO-STACK-MIB", "optionalSystemMiscGroup2"), ("CISCO-STACK-MIB", "optionalSystemMiscGroup3"), ("CISCO-STACK-MIB", "optionalChassisGroup"), ("CISCO-STACK-MIB", "vmpsGroup"), ("CISCO-STACK-MIB", "portCpbGroup1"), ("CISCO-STACK-MIB", "portCpbGroup2"), ("CISCO-STACK-MIB", "portCpbGroup3"), ("CISCO-STACK-MIB", "tftpGroup"), ("CISCO-STACK-MIB", "tokenRingGroup"), ("CISCO-STACK-MIB", "systemFddiGroup"), ("CISCO-STACK-MIB", "ntpGroup"), ("CISCO-STACK-MIB", "authenticationGroup"), ("CISCO-STACK-MIB", "chassisGroup"), ("CISCO-STACK-MIB", "traceRouteGroup"), ("CISCO-STACK-MIB", "systemTrafficGroup"), ("CISCO-STACK-MIB", "brouteEnableGroup"), ("CISCO-STACK-MIB", "switchAccelerationModuleGroup"), ("CISCO-STACK-MIB", "optionalSystemTrapGroup"), ("CISCO-STACK-MIB", "vlanGroup"), ("CISCO-STACK-MIB", "optionalSystemMiscGroup"), ("CISCO-STACK-MIB", "systemTrapGroup"), ("CISCO-STACK-MIB", "ipPermitGroup1"), ("CISCO-STACK-MIB", "optionalPortGroup"), ("CISCO-STACK-MIB", "fileCopyGroup"), ("CISCO-STACK-MIB", "portGroup"), ("CISCO-STACK-MIB", "tokenRingSoftErrorMonitorGroup"), ("CISCO-STACK-MIB", "systemRmonGroup"), ) )
if mibBuilder.loadTexts: ciscoStackgMIBCompliance3.setDescription("The compliance statement for entities which                      implement the Cisco stack MIB.")
ciscoStackgMIBCompliance4 = ModuleCompliance((0, 1, 31, 1, 4)).setObjects(*(("CISCO-STACK-MIB", "vlanTrunkMappingGroup"), ("CISCO-STACK-MIB", "moduleGroup"), ("CISCO-STACK-MIB", "mcastGroup"), ("CISCO-STACK-MIB", "voiceGroup"), ("CISCO-STACK-MIB", "filterGroup1"), ("CISCO-STACK-MIB", "portGroup1"), ("CISCO-STACK-MIB", "portGroup2"), ("CISCO-STACK-MIB", "mdgGatewayGroup"), ("CISCO-STACK-MIB", "chassisGroup1"), ("CISCO-STACK-MIB", "dnsGroup"), ("CISCO-STACK-MIB", "monitorGroup"), ("CISCO-STACK-MIB", "portJumboFrameGroup"), ("CISCO-STACK-MIB", "filterGroup"), ("CISCO-STACK-MIB", "syslogGroup"), ("CISCO-STACK-MIB", "ntpAuthenticationGroup"), ("CISCO-STACK-MIB", "optionalModuleGroup"), ("CISCO-STACK-MIB", "ipPermitGroup"), ("CISCO-STACK-MIB", "systemMiscGroup"), ("CISCO-STACK-MIB", "vlanGroup1"), ("CISCO-STACK-MIB", "mcastGroup1"), ("CISCO-STACK-MIB", "moduleGroup2"), ("CISCO-STACK-MIB", "moduleGroup1"), ("CISCO-STACK-MIB", "portSecurityGroup1"), ("CISCO-STACK-MIB", "optionalSystemMiscGroup1"), ("CISCO-STACK-MIB", "optionalSystemMiscGroup2"), ("CISCO-STACK-MIB", "optionalSystemMiscGroup3"), ("CISCO-STACK-MIB", "optionalSystemMiscGroup4"), ("CISCO-STACK-MIB", "optionalChassisGroup"), ("CISCO-STACK-MIB", "portCpbGroup4"), ("CISCO-STACK-MIB", "vmpsGroup"), ("CISCO-STACK-MIB", "portCpbGroup1"), ("CISCO-STACK-MIB", "portCpbGroup2"), ("CISCO-STACK-MIB", "portCpbGroup3"), ("CISCO-STACK-MIB", "tftpGroup"), ("CISCO-STACK-MIB", "tokenRingGroup"), ("CISCO-STACK-MIB", "systemFddiGroup"), ("CISCO-STACK-MIB", "ntpGroup"), ("CISCO-STACK-MIB", "authenticationGroup"), ("CISCO-STACK-MIB", "chassisGroup"), ("CISCO-STACK-MIB", "traceRouteGroup"), ("CISCO-STACK-MIB", "systemTrafficGroup"), ("CISCO-STACK-MIB", "brouteEnableGroup"), ("CISCO-STACK-MIB", "switchAccelerationModuleGroup"), ("CISCO-STACK-MIB", "optionalSystemTrapGroup"), ("CISCO-STACK-MIB", "vlanGroup"), ("CISCO-STACK-MIB", "optionalSystemMiscGroup"), ("CISCO-STACK-MIB", "systemTrapGroup"), ("CISCO-STACK-MIB", "ipPermitGroup1"), ("CISCO-STACK-MIB", "optionalPortGroup"), ("CISCO-STACK-MIB", "fileCopyGroup"), ("CISCO-STACK-MIB", "portGroup"), ("CISCO-STACK-MIB", "tokenRingSoftErrorMonitorGroup"), ("CISCO-STACK-MIB", "systemRmonGroup"), ) )
if mibBuilder.loadTexts: ciscoStackgMIBCompliance4.setDescription("The compliance statement for entities which                      implement the Cisco stack MIB.")
ciscoStackgMIBCompliance5 = ModuleCompliance((0, 1, 31, 1, 5)).setObjects(*(("CISCO-STACK-MIB", "vlanTrunkMappingGroup"), ("CISCO-STACK-MIB", "moduleGroup"), ("CISCO-STACK-MIB", "mcastGroup"), ("CISCO-STACK-MIB", "voiceGroup"), ("CISCO-STACK-MIB", "filterGroup1"), ("CISCO-STACK-MIB", "portGroup1"), ("CISCO-STACK-MIB", "portGroup2"), ("CISCO-STACK-MIB", "filterGroup2"), ("CISCO-STACK-MIB", "mdgGatewayGroup"), ("CISCO-STACK-MIB", "fileCopyGroup2"), ("CISCO-STACK-MIB", "chassisGroup1"), ("CISCO-STACK-MIB", "dnsGroup"), ("CISCO-STACK-MIB", "portJumboFrameGroup"), ("CISCO-STACK-MIB", "filterGroup"), ("CISCO-STACK-MIB", "filterGroup3"), ("CISCO-STACK-MIB", "syslogGroup"), ("CISCO-STACK-MIB", "ntpAuthenticationGroup"), ("CISCO-STACK-MIB", "portGroup3"), ("CISCO-STACK-MIB", "optionalModuleGroup"), ("CISCO-STACK-MIB", "ipPermitGroup"), ("CISCO-STACK-MIB", "systemMiscGroup"), ("CISCO-STACK-MIB", "configurationGroup"), ("CISCO-STACK-MIB", "mcastGroup1"), ("CISCO-STACK-MIB", "moduleGroup2"), ("CISCO-STACK-MIB", "moduleGroup1"), ("CISCO-STACK-MIB", "portSecurityGroup1"), ("CISCO-STACK-MIB", "optionalSystemMiscGroup1"), ("CISCO-STACK-MIB", "optionalSystemMiscGroup2"), ("CISCO-STACK-MIB", "optionalSystemMiscGroup3"), ("CISCO-STACK-MIB", "optionalSystemMiscGroup4"), ("CISCO-STACK-MIB", "optionalSystemMiscGroup5"), ("CISCO-STACK-MIB", "systemStatusGroup"), ("CISCO-STACK-MIB", "optionalChassisGroup"), ("CISCO-STACK-MIB", "portCpbGroup4"), ("CISCO-STACK-MIB", "portCpbGroup5"), ("CISCO-STACK-MIB", "vmpsGroup"), ("CISCO-STACK-MIB", "portCpbGroup1"), ("CISCO-STACK-MIB", "portCpbGroup2"), ("CISCO-STACK-MIB", "portCpbGroup3"), ("CISCO-STACK-MIB", "tftpGroup"), ("CISCO-STACK-MIB", "tokenRingGroup"), ("CISCO-STACK-MIB", "systemFddiGroup"), ("CISCO-STACK-MIB", "ntpGroup"), ("CISCO-STACK-MIB", "syslogGroup2"), ("CISCO-STACK-MIB", "chassisGroup"), ("CISCO-STACK-MIB", "traceRouteGroup"), ("CISCO-STACK-MIB", "systemTrafficGroup"), ("CISCO-STACK-MIB", "brouteEnableGroup"), ("CISCO-STACK-MIB", "switchAccelerationModuleGroup"), ("CISCO-STACK-MIB", "optionalSystemTrapGroup"), ("CISCO-STACK-MIB", "authenticationGroup1"), ("CISCO-STACK-MIB", "vlanGroup"), ("CISCO-STACK-MIB", "optionalSystemMiscGroup"), ("CISCO-STACK-MIB", "systemTrapGroup"), ("CISCO-STACK-MIB", "ipPermitGroup1"), ("CISCO-STACK-MIB", "optionalPortGroup"), ("CISCO-STACK-MIB", "fileCopyGroup"), ("CISCO-STACK-MIB", "portGroup"), ("CISCO-STACK-MIB", "tokenRingSoftErrorMonitorGroup"), ("CISCO-STACK-MIB", "systemRmonGroup"), ("CISCO-STACK-MIB", "systemRmonGroup2"), ) )
if mibBuilder.loadTexts: ciscoStackgMIBCompliance5.setDescription("The compliance statement for entities which                      implement the Cisco stack MIB.")
ciscoStackgMIBCompliance6 = ModuleCompliance((0, 1, 31, 1, 6)).setObjects(*(("CISCO-STACK-MIB", "vlanTrunkMappingGroup"), ("CISCO-STACK-MIB", "moduleGroup"), ("CISCO-STACK-MIB", "mcastGroup"), ("CISCO-STACK-MIB", "voiceGroup"), ("CISCO-STACK-MIB", "filterGroup1"), ("CISCO-STACK-MIB", "portGroup1"), ("CISCO-STACK-MIB", "portGroup2"), ("CISCO-STACK-MIB", "filterGroup2"), ("CISCO-STACK-MIB", "portGroup4"), ("CISCO-STACK-MIB", "mdgGatewayGroup"), ("CISCO-STACK-MIB", "fileCopyGroup2"), ("CISCO-STACK-MIB", "chassisGroup1"), ("CISCO-STACK-MIB", "systemTrapGroup1"), ("CISCO-STACK-MIB", "dnsGroup"), ("CISCO-STACK-MIB", "optionalPortGroup1"), ("CISCO-STACK-MIB", "portJumboFrameGroup"), ("CISCO-STACK-MIB", "filterGroup"), ("CISCO-STACK-MIB", "systemMiscGroup1"), ("CISCO-STACK-MIB", "filterGroup3"), ("CISCO-STACK-MIB", "syslogGroup"), ("CISCO-STACK-MIB", "ntpAuthenticationGroup"), ("CISCO-STACK-MIB", "portGroup3"), ("CISCO-STACK-MIB", "optionalChassisGroup1"), ("CISCO-STACK-MIB", "optionalModuleGroup"), ("CISCO-STACK-MIB", "configurationGroup"), ("CISCO-STACK-MIB", "vlanGroup2"), ("CISCO-STACK-MIB", "mcastGroup1"), ("CISCO-STACK-MIB", "moduleGroup2"), ("CISCO-STACK-MIB", "moduleGroup1"), ("CISCO-STACK-MIB", "portSecurityGroup1"), ("CISCO-STACK-MIB", "optionalSystemMiscGroup1"), ("CISCO-STACK-MIB", "optionalSystemMiscGroup3"), ("CISCO-STACK-MIB", "optionalSystemMiscGroup4"), ("CISCO-STACK-MIB", "optionalSystemMiscGroup5"), ("CISCO-STACK-MIB", "optionalSystemMiscGroup6"), ("CISCO-STACK-MIB", "systemStatusGroup"), ("CISCO-STACK-MIB", "portCpbGroup4"), ("CISCO-STACK-MIB", "portCpbGroup5"), ("CISCO-STACK-MIB", "vmpsGroup"), ("CISCO-STACK-MIB", "portCpbGroup1"), ("CISCO-STACK-MIB", "portCpbGroup2"), ("CISCO-STACK-MIB", "portCpbGroup3"), ("CISCO-STACK-MIB", "tftpGroup"), ("CISCO-STACK-MIB", "tokenRingGroup"), ("CISCO-STACK-MIB", "systemFddiGroup"), ("CISCO-STACK-MIB", "ntpGroup"), ("CISCO-STACK-MIB", "syslogGroup2"), ("CISCO-STACK-MIB", "chassisGroup"), ("CISCO-STACK-MIB", "traceRouteGroup"), ("CISCO-STACK-MIB", "systemTrafficGroup"), ("CISCO-STACK-MIB", "brouteEnableGroup"), ("CISCO-STACK-MIB", "switchAccelerationModuleGroup"), ("CISCO-STACK-MIB", "optionalSystemTrapGroup"), ("CISCO-STACK-MIB", "authenticationGroup1"), ("CISCO-STACK-MIB", "optionalSystemMiscGroup"), ("CISCO-STACK-MIB", "ipPermitGroup2"), ("CISCO-STACK-MIB", "ipPermitGroup1"), ("CISCO-STACK-MIB", "fileCopyGroup"), ("CISCO-STACK-MIB", "tokenRingSoftErrorMonitorGroup"), ("CISCO-STACK-MIB", "systemRmonGroup"), ("CISCO-STACK-MIB", "systemRmonGroup2"), ) )
if mibBuilder.loadTexts: ciscoStackgMIBCompliance6.setDescription("The compliance statement for entities which                      implement the Cisco stack MIB.")
ciscoStackgMIBCompliance7 = ModuleCompliance((0, 1, 31, 1, 7)).setObjects(*(("CISCO-STACK-MIB", "vlanTrunkMappingGroup"), ("CISCO-STACK-MIB", "moduleGroup"), ("CISCO-STACK-MIB", "mcastGroup"), ("CISCO-STACK-MIB", "voiceGroup"), ("CISCO-STACK-MIB", "filterGroup1"), ("CISCO-STACK-MIB", "portGroup1"), ("CISCO-STACK-MIB", "portGroup2"), ("CISCO-STACK-MIB", "filterGroup2"), ("CISCO-STACK-MIB", "portGroup4"), ("CISCO-STACK-MIB", "mdgGatewayGroup"), ("CISCO-STACK-MIB", "fileCopyGroup2"), ("CISCO-STACK-MIB", "chassisGroup1"), ("CISCO-STACK-MIB", "dnsGroup"), ("CISCO-STACK-MIB", "systemTrapGroup2"), ("CISCO-STACK-MIB", "optionalPortGroup1"), ("CISCO-STACK-MIB", "portJumboFrameGroup"), ("CISCO-STACK-MIB", "filterGroup"), ("CISCO-STACK-MIB", "systemMiscGroup1"), ("CISCO-STACK-MIB", "filterGroup3"), ("CISCO-STACK-MIB", "syslogGroup"), ("CISCO-STACK-MIB", "ntpAuthenticationGroup"), ("CISCO-STACK-MIB", "portGroup3"), ("CISCO-STACK-MIB", "optionalChassisGroup1"), ("CISCO-STACK-MIB", "optionalModuleGroup"), ("CISCO-STACK-MIB", "configurationGroup"), ("CISCO-STACK-MIB", "vlanGroup2"), ("CISCO-STACK-MIB", "mcastGroup1"), ("CISCO-STACK-MIB", "moduleGroup2"), ("CISCO-STACK-MIB", "moduleGroup1"), ("CISCO-STACK-MIB", "portSecurityGroup1"), ("CISCO-STACK-MIB", "optionalSystemMiscGroup1"), ("CISCO-STACK-MIB", "optionalSystemMiscGroup3"), ("CISCO-STACK-MIB", "optionalSystemMiscGroup4"), ("CISCO-STACK-MIB", "optionalSystemMiscGroup5"), ("CISCO-STACK-MIB", "optionalSystemMiscGroup6"), ("CISCO-STACK-MIB", "systemStatusGroup"), ("CISCO-STACK-MIB", "notificationGroup"), ("CISCO-STACK-MIB", "portCpbGroup4"), ("CISCO-STACK-MIB", "portCpbGroup5"), ("CISCO-STACK-MIB", "vmpsGroup"), ("CISCO-STACK-MIB", "portCpbGroup1"), ("CISCO-STACK-MIB", "portCpbGroup2"), ("CISCO-STACK-MIB", "portCpbGroup3"), ("CISCO-STACK-MIB", "tftpGroup"), ("CISCO-STACK-MIB", "tokenRingGroup"), ("CISCO-STACK-MIB", "optionalSystemTrapGroup1"), ("CISCO-STACK-MIB", "systemFddiGroup"), ("CISCO-STACK-MIB", "ntpGroup"), ("CISCO-STACK-MIB", "syslogGroup2"), ("CISCO-STACK-MIB", "chassisGroup"), ("CISCO-STACK-MIB", "traceRouteGroup"), ("CISCO-STACK-MIB", "systemTrafficGroup"), ("CISCO-STACK-MIB", "brouteEnableGroup"), ("CISCO-STACK-MIB", "switchAccelerationModuleGroup"), ("CISCO-STACK-MIB", "authenticationGroup2"), ("CISCO-STACK-MIB", "optionalSystemMiscGroup"), ("CISCO-STACK-MIB", "ipPermitGroup2"), ("CISCO-STACK-MIB", "ipPermitGroup1"), ("CISCO-STACK-MIB", "fileCopyGroup"), ("CISCO-STACK-MIB", "tokenRingSoftErrorMonitorGroup"), ("CISCO-STACK-MIB", "systemRmonGroup"), ("CISCO-STACK-MIB", "systemRmonGroup2"), ) )
if mibBuilder.loadTexts: ciscoStackgMIBCompliance7.setDescription("The compliance statement for entities which                      implement the Cisco stack MIB.")
ciscoStackgMIBCompliance8 = ModuleCompliance((0, 1, 31, 1, 8)).setObjects(*(("CISCO-STACK-MIB", "vlanTrunkMappingGroup"), ("CISCO-STACK-MIB", "moduleGroup"), ("CISCO-STACK-MIB", "mcastGroup"), ("CISCO-STACK-MIB", "voiceGroup"), ("CISCO-STACK-MIB", "filterGroup1"), ("CISCO-STACK-MIB", "portGroup1"), ("CISCO-STACK-MIB", "portGroup2"), ("CISCO-STACK-MIB", "filterGroup2"), ("CISCO-STACK-MIB", "portGroup4"), ("CISCO-STACK-MIB", "mdgGatewayGroup"), ("CISCO-STACK-MIB", "fileCopyGroup2"), ("CISCO-STACK-MIB", "chassisGroup1"), ("CISCO-STACK-MIB", "dnsGroup"), ("CISCO-STACK-MIB", "systemTrapGroup2"), ("CISCO-STACK-MIB", "optionalPortGroup1"), ("CISCO-STACK-MIB", "portJumboFrameGroup"), ("CISCO-STACK-MIB", "filterGroup"), ("CISCO-STACK-MIB", "systemMiscGroup1"), ("CISCO-STACK-MIB", "filterGroup3"), ("CISCO-STACK-MIB", "syslogGroup"), ("CISCO-STACK-MIB", "ntpAuthenticationGroup"), ("CISCO-STACK-MIB", "portGroup3"), ("CISCO-STACK-MIB", "optionalChassisGroup1"), ("CISCO-STACK-MIB", "optionalModuleGroup"), ("CISCO-STACK-MIB", "configurationGroup"), ("CISCO-STACK-MIB", "vlanGroup2"), ("CISCO-STACK-MIB", "mcastGroup1"), ("CISCO-STACK-MIB", "moduleGroup2"), ("CISCO-STACK-MIB", "moduleGroup1"), ("CISCO-STACK-MIB", "portSecurityGroup1"), ("CISCO-STACK-MIB", "optionalSystemMiscGroup1"), ("CISCO-STACK-MIB", "optionalSystemMiscGroup3"), ("CISCO-STACK-MIB", "optionalSystemMiscGroup4"), ("CISCO-STACK-MIB", "optionalSystemMiscGroup5"), ("CISCO-STACK-MIB", "optionalSystemMiscGroup6"), ("CISCO-STACK-MIB", "systemStatusGroup"), ("CISCO-STACK-MIB", "notificationGroup"), ("CISCO-STACK-MIB", "portCpbGroup4"), ("CISCO-STACK-MIB", "portCpbGroup5"), ("CISCO-STACK-MIB", "vmpsGroup"), ("CISCO-STACK-MIB", "portCpbGroup1"), ("CISCO-STACK-MIB", "portCpbGroup2"), ("CISCO-STACK-MIB", "portCpbGroup3"), ("CISCO-STACK-MIB", "tftpGroup"), ("CISCO-STACK-MIB", "tokenRingGroup"), ("CISCO-STACK-MIB", "optionalSystemTrapGroup1"), ("CISCO-STACK-MIB", "systemFddiGroup"), ("CISCO-STACK-MIB", "ntpGroup"), ("CISCO-STACK-MIB", "syslogGroup2"), ("CISCO-STACK-MIB", "chassisGroup"), ("CISCO-STACK-MIB", "traceRouteGroup"), ("CISCO-STACK-MIB", "systemTrafficGroup"), ("CISCO-STACK-MIB", "brouteEnableGroup"), ("CISCO-STACK-MIB", "switchAccelerationModuleGroup"), ("CISCO-STACK-MIB", "authenticationGroup2"), ("CISCO-STACK-MIB", "optionalSystemMiscGroup"), ("CISCO-STACK-MIB", "ipPermitGroup3"), ("CISCO-STACK-MIB", "ipPermitGroup2"), ("CISCO-STACK-MIB", "ipPermitGroup1"), ("CISCO-STACK-MIB", "fileCopyGroup"), ("CISCO-STACK-MIB", "tokenRingSoftErrorMonitorGroup"), ("CISCO-STACK-MIB", "systemRmonGroup"), ("CISCO-STACK-MIB", "systemRmonGroup2"), ) )
if mibBuilder.loadTexts: ciscoStackgMIBCompliance8.setDescription("The compliance statement for entities which                      implement the Cisco stack MIB.")

# Exports

# Module identity
mibBuilder.exportSymbols("CISCO-STACK-MIB", PYSNMP_MODULE_ID=ciscoStackMIB)

# Types
mibBuilder.exportSymbols("CISCO-STACK-MIB", VendorIdType=VendorIdType)

# Objects
mibBuilder.exportSymbols("CISCO-STACK-MIB", ciscoStackNotificationsPrefix=ciscoStackNotificationsPrefix, ciscoStackMIB=ciscoStackMIB, systemGrp=systemGrp, sysMgmtType=sysMgmtType, sysIpAddr=sysIpAddr, sysNetMask=sysNetMask, sysBroadcast=sysBroadcast, sysTrapReceiverTable=sysTrapReceiverTable, sysTrapReceiverEntry=sysTrapReceiverEntry, sysTrapReceiverType=sysTrapReceiverType, sysTrapReceiverAddr=sysTrapReceiverAddr, sysTrapReceiverComm=sysTrapReceiverComm, sysCommunityTable=sysCommunityTable, sysCommunityEntry=sysCommunityEntry, sysCommunityAccess=sysCommunityAccess, sysCommunityString=sysCommunityString, sysAttachType=sysAttachType, sysTraffic=sysTraffic, sysReset=sysReset, sysBaudRate=sysBaudRate, sysInsertMode=sysInsertMode, sysClearMacTime=sysClearMacTime, sysClearPortTime=sysClearPortTime, sysFddiRingTable=sysFddiRingTable, sysFddiRingEntry=sysFddiRingEntry, sysFddiRingSMTIndex=sysFddiRingSMTIndex, sysFddiRingAddress=sysFddiRingAddress, sysFddiRingNext=sysFddiRingNext, sysEnableModem=sysEnableModem, sysEnableRedirects=sysEnableRedirects, sysEnableRmon=sysEnableRmon, sysArpAgingTime=sysArpAgingTime, sysTrafficPeak=sysTrafficPeak, sysTrafficPeakTime=sysTrafficPeakTime, sysCommunityRwa=sysCommunityRwa, sysCommunityRw=sysCommunityRw, sysCommunityRo=sysCommunityRo, sysEnableChassisTraps=sysEnableChassisTraps, sysEnableModuleTraps=sysEnableModuleTraps, sysEnableBridgeTraps=sysEnableBridgeTraps, sysIpVlan=sysIpVlan, sysConfigChangeTime=sysConfigChangeTime, sysEnableRepeaterTraps=sysEnableRepeaterTraps, sysBannerMotd=sysBannerMotd, sysEnableIpPermitTraps=sysEnableIpPermitTraps, sysTrafficMeterTable=sysTrafficMeterTable, sysTrafficMeterEntry=sysTrafficMeterEntry, sysTrafficMeterType=sysTrafficMeterType, sysTrafficMeter=sysTrafficMeter, sysTrafficMeterPeak=sysTrafficMeterPeak, sysTrafficMeterPeakTime=sysTrafficMeterPeakTime, sysEnableVmpsTraps=sysEnableVmpsTraps, sysConfigChangeInfo=sysConfigChangeInfo, sysEnableConfigTraps=sysEnableConfigTraps, sysConfigRegister=sysConfigRegister, sysBootVariable=sysBootVariable, sysBootedImage=sysBootedImage, sysEnableEntityTrap=sysEnableEntityTrap, sysEnableStpxTrap=sysEnableStpxTrap, sysExtendedRmonVlanModeEnable=sysExtendedRmonVlanModeEnable, sysExtendedRmonNetflowPassword=sysExtendedRmonNetflowPassword, sysExtendedRmonNetflowEnable=sysExtendedRmonNetflowEnable, sysExtendedRmonVlanAgentEnable=sysExtendedRmonVlanAgentEnable, sysExtendedRmonEnable=sysExtendedRmonEnable, sysConsolePrimaryLoginAuthentication=sysConsolePrimaryLoginAuthentication, sysConsolePrimaryEnableAuthentication=sysConsolePrimaryEnableAuthentication, sysTelnetPrimaryLoginAuthentication=sysTelnetPrimaryLoginAuthentication, sysTelnetPrimaryEnableAuthentication=sysTelnetPrimaryEnableAuthentication, sysStartupConfigSource=sysStartupConfigSource, sysStartupConfigSourceFile=sysStartupConfigSourceFile, sysConfigSupervisorModuleNo=sysConfigSupervisorModuleNo, sysStandbyPortEnable=sysStandbyPortEnable, sysPortFastBpduGuard=sysPortFastBpduGuard, sysErrDisableTimeoutEnable=sysErrDisableTimeoutEnable, sysErrDisableTimeoutInterval=sysErrDisableTimeoutInterval, sysTrafficMonitorHighWaterMark=sysTrafficMonitorHighWaterMark, sysHighAvailabilityEnable=sysHighAvailabilityEnable, sysHighAvailabilityVersioningEnable=sysHighAvailabilityVersioningEnable, sysHighAvailabilityOperStatus=sysHighAvailabilityOperStatus, sysHighAvailabilityNotRunningReason=sysHighAvailabilityNotRunningReason, sysExtendedRmonNetflowModuleMask=sysExtendedRmonNetflowModuleMask, sshPublicKeySize=sshPublicKeySize, sysMaxRmonMemory=sysMaxRmonMemory, sysMacReductionAdminEnable=sysMacReductionAdminEnable, sysMacReductionOperEnable=sysMacReductionOperEnable, sysStatus=sysStatus, chassisGrp=chassisGrp, chassisSysType=chassisSysType, chassisBkplType=chassisBkplType, chassisPs1Type=chassisPs1Type, chassisPs1Status=chassisPs1Status, chassisPs1TestResult=chassisPs1TestResult, chassisPs2Type=chassisPs2Type, chassisPs2Status=chassisPs2Status, chassisPs2TestResult=chassisPs2TestResult, chassisFanStatus=chassisFanStatus, chassisFanTestResult=chassisFanTestResult, chassisMinorAlarm=chassisMinorAlarm, chassisMajorAlarm=chassisMajorAlarm, chassisTempAlarm=chassisTempAlarm, chassisNumSlots=chassisNumSlots, chassisSlotConfig=chassisSlotConfig, chassisModel=chassisModel, chassisSerialNumber=chassisSerialNumber, chassisComponentTable=chassisComponentTable, chassisComponentEntry=chassisComponentEntry, chassisComponentIndex=chassisComponentIndex, chassisComponentType=chassisComponentType, chassisComponentSerialNumber=chassisComponentSerialNumber, chassisComponentHwVersion=chassisComponentHwVersion, chassisComponentModel=chassisComponentModel, chassisSerialNumberString=chassisSerialNumberString, chassisPs3Type=chassisPs3Type, chassisPs3Status=chassisPs3Status, chassisPs3TestResult=chassisPs3TestResult, chassisPEMInstalled=chassisPEMInstalled, moduleGrp=moduleGrp, moduleTable=moduleTable, moduleEntry=moduleEntry, moduleIndex=moduleIndex, moduleType=moduleType, moduleSerialNumber=moduleSerialNumber, moduleHwHiVersion=moduleHwHiVersion, moduleHwLoVersion=moduleHwLoVersion, moduleFwHiVersion=moduleFwHiVersion, moduleFwLoVersion=moduleFwLoVersion)
mibBuilder.exportSymbols("CISCO-STACK-MIB", moduleSwHiVersion=moduleSwHiVersion, moduleSwLoVersion=moduleSwLoVersion, moduleStatus=moduleStatus, moduleTestResult=moduleTestResult, moduleAction=moduleAction, moduleName=moduleName, moduleNumPorts=moduleNumPorts, modulePortStatus=modulePortStatus, moduleSubType=moduleSubType, moduleModel=moduleModel, moduleHwVersion=moduleHwVersion, moduleFwVersion=moduleFwVersion, moduleSwVersion=moduleSwVersion, moduleStandbyStatus=moduleStandbyStatus, moduleIPAddress=moduleIPAddress, moduleIPAddressVlan=moduleIPAddressVlan, moduleSubType2=moduleSubType2, moduleSlotNum=moduleSlotNum, moduleSerialNumberString=moduleSerialNumberString, moduleEntPhysicalIndex=moduleEntPhysicalIndex, moduleAdditionalStatus=moduleAdditionalStatus, portGrp=portGrp, portTable=portTable, portEntry=portEntry, portModuleIndex=portModuleIndex, portIndex=portIndex, portCrossIndex=portCrossIndex, portName=portName, portType=portType, portOperStatus=portOperStatus, portCrossGroupIndex=portCrossGroupIndex, portAdditionalStatus=portAdditionalStatus, portAdminSpeed=portAdminSpeed, portDuplex=portDuplex, portIfIndex=portIfIndex, portSpantreeFastStart=portSpantreeFastStart, portAdminRxFlowControl=portAdminRxFlowControl, portOperRxFlowControl=portOperRxFlowControl, portAdminTxFlowControl=portAdminTxFlowControl, portOperTxFlowControl=portOperTxFlowControl, portMacControlTransmitFrames=portMacControlTransmitFrames, portMacControlReceiveFrames=portMacControlReceiveFrames, portMacControlPauseTransmitFrames=portMacControlPauseTransmitFrames, portMacControlPauseReceiveFrames=portMacControlPauseReceiveFrames, portMacControlUnknownProtocolFrames=portMacControlUnknownProtocolFrames, portLinkFaultStatus=portLinkFaultStatus, portAdditionalOperStatus=portAdditionalOperStatus, portInlinePowerDetect=portInlinePowerDetect, portEntPhysicalIndex=portEntPhysicalIndex, portErrDisableTimeOutEnable=portErrDisableTimeOutEnable, tftpGrp=tftpGrp, tftpHost=tftpHost, tftpFile=tftpFile, tftpModule=tftpModule, tftpAction=tftpAction, tftpResult=tftpResult, brouterGrp=brouterGrp, brouterEnableRip=brouterEnableRip, brouterEnableSpantree=brouterEnableSpantree, brouterEnableGiantCheck=brouterEnableGiantCheck, brouterEnableIpFragmentation=brouterEnableIpFragmentation, brouterEnableUnreachables=brouterEnableUnreachables, brouterCamAgingTime=brouterCamAgingTime, brouterCamMode=brouterCamMode, brouterIpxSnapToEther=brouterIpxSnapToEther, brouterIpx8023RawToFddi=brouterIpx8023RawToFddi, brouterEthernetReceiveMax=brouterEthernetReceiveMax, brouterEthernetTransmitMax=brouterEthernetTransmitMax, brouterFddiReceiveMax=brouterFddiReceiveMax, brouterFddiTransmitMax=brouterFddiTransmitMax, brouterPortTable=brouterPortTable, brouterPortEntry=brouterPortEntry, brouterPortModule=brouterPortModule, brouterPort=brouterPort, brouterPortIpVlan=brouterPortIpVlan, brouterPortIpAddr=brouterPortIpAddr, brouterPortNetMask=brouterPortNetMask, brouterPortBroadcast=brouterPortBroadcast, brouterPortBridgeVlan=brouterPortBridgeVlan, brouterPortIpHelpers=brouterPortIpHelpers, brouterIpx8022ToEther=brouterIpx8022ToEther, brouterEnableTransitEncapsulation=brouterEnableTransitEncapsulation, brouterEnableFddiCheck=brouterEnableFddiCheck, brouterEnableAPaRT=brouterEnableAPaRT, filterGrp=filterGrp, filterMacTable=filterMacTable, filterMacEntry=filterMacEntry, filterMacModule=filterMacModule, filterMacPort=filterMacPort, filterMacAddress=filterMacAddress, filterMacType=filterMacType, filterVendorTable=filterVendorTable, filterVendorEntry=filterVendorEntry, filterVendorModule=filterVendorModule, filterVendorPort=filterVendorPort, filterVendorId=filterVendorId, filterVendorType=filterVendorType, filterProtocolTable=filterProtocolTable, filterProtocolEntry=filterProtocolEntry, filterProtocolModule=filterProtocolModule, filterProtocolPort=filterProtocolPort, filterProtocolValue=filterProtocolValue, filterProtocolType=filterProtocolType, filterTestTable=filterTestTable, filterTestEntry=filterTestEntry, filterTestModule=filterTestModule, filterTestPort=filterTestPort, filterTestIndex=filterTestIndex, filterTestType=filterTestType, filterTestOffset=filterTestOffset, filterTestValue=filterTestValue, filterTestMask=filterTestMask, filterPortTable=filterPortTable, filterPortEntry=filterPortEntry, filterPortModule=filterPortModule, filterPort=filterPort, filterPortComplex=filterPortComplex, filterPortBroadcastThrottle=filterPortBroadcastThrottle, filterPortBroadcastThreshold=filterPortBroadcastThreshold, filterPortBroadcastDiscards=filterPortBroadcastDiscards, filterPortBroadcastThresholdFraction=filterPortBroadcastThresholdFraction, filterPortSuppressionOption=filterPortSuppressionOption, filterPortSuppressionViolation=filterPortSuppressionViolation, monitorGrp=monitorGrp, monitorSourceModule=monitorSourceModule, monitorSourcePort=monitorSourcePort, monitorDestinationModule=monitorDestinationModule)
mibBuilder.exportSymbols("CISCO-STACK-MIB", monitorDestinationPort=monitorDestinationPort, monitorDirection=monitorDirection, monitorEnable=monitorEnable, monitorAdminSourcePorts=monitorAdminSourcePorts, monitorOperSourcePorts=monitorOperSourcePorts, vlanGrp=vlanGrp, vlanTable=vlanTable, vlanEntry=vlanEntry, vlanIndex=vlanIndex, vlanSpantreeEnable=vlanSpantreeEnable, vlanIfIndex=vlanIfIndex, vlanPortTable=vlanPortTable, vlanPortEntry=vlanPortEntry, vlanPortModule=vlanPortModule, vlanPort=vlanPort, vlanPortVlan=vlanPortVlan, vlanPortIslVlansAllowed=vlanPortIslVlansAllowed, vlanPortSwitchLevel=vlanPortSwitchLevel, vlanPortIslAdminStatus=vlanPortIslAdminStatus, vlanPortIslOperStatus=vlanPortIslOperStatus, vlanPortIslPriorityVlans=vlanPortIslPriorityVlans, vlanPortAdminStatus=vlanPortAdminStatus, vlanPortOperStatus=vlanPortOperStatus, vlanPortAuxiliaryVlan=vlanPortAuxiliaryVlan, vmpsTable=vmpsTable, vmpsEntry=vmpsEntry, vmpsAddr=vmpsAddr, vmpsType=vmpsType, vmpsAction=vmpsAction, vmpsAccessed=vmpsAccessed, vlanTrunkMappingMax=vlanTrunkMappingMax, vlanTrunkMappingTable=vlanTrunkMappingTable, vlanTrunkMappingEntry=vlanTrunkMappingEntry, vlanTrunkMappingFromVlan=vlanTrunkMappingFromVlan, vlanTrunkMappingToVlan=vlanTrunkMappingToVlan, vlanTrunkMappingType=vlanTrunkMappingType, vlanTrunkMappingOper=vlanTrunkMappingOper, vlanTrunkMappingStatus=vlanTrunkMappingStatus, securityGrp=securityGrp, portSecurityTable=portSecurityTable, portSecurityEntry=portSecurityEntry, portSecurityModuleIndex=portSecurityModuleIndex, portSecurityPortIndex=portSecurityPortIndex, portSecurityAdminStatus=portSecurityAdminStatus, portSecurityOperStatus=portSecurityOperStatus, portSecurityLastSrcAddr=portSecurityLastSrcAddr, portSecuritySecureSrcAddr=portSecuritySecureSrcAddr, portSecurityMaxSrcAddr=portSecurityMaxSrcAddr, portSecurityAgingTime=portSecurityAgingTime, portSecurityShutdownTimeOut=portSecurityShutdownTimeOut, portSecurityViolationPolicy=portSecurityViolationPolicy, portSecurityExtTable=portSecurityExtTable, portSecurityExtEntry=portSecurityExtEntry, portSecurityExtModuleIndex=portSecurityExtModuleIndex, portSecurityExtPortIndex=portSecurityExtPortIndex, portSecurityExtSecureSrcAddr=portSecurityExtSecureSrcAddr, portSecurityExtControlStatus=portSecurityExtControlStatus, tokenRingGrp=tokenRingGrp, tokenRingPortTable=tokenRingPortTable, tokenRingPortEntry=tokenRingPortEntry, tokenRingModuleIndex=tokenRingModuleIndex, tokenRingPortIndex=tokenRingPortIndex, tokenRingPortSetACbits=tokenRingPortSetACbits, tokenRingPortMode=tokenRingPortMode, tokenRingPortEarlyTokenRel=tokenRingPortEarlyTokenRel, tokenRingPortPriorityThresh=tokenRingPortPriorityThresh, tokenRingPortPriorityMinXmit=tokenRingPortPriorityMinXmit, tokenRingPortCfgLossThresh=tokenRingPortCfgLossThresh, tokenRingPortCfgLossInterval=tokenRingPortCfgLossInterval, tokenRingDripDistCrfMode=tokenRingDripDistCrfMode, tokenRingDripAreReductionMode=tokenRingDripAreReductionMode, tokenRingDripLocalNodeID=tokenRingDripLocalNodeID, tokenRingDripLastRevision=tokenRingDripLastRevision, tokenRingDripLastChangedRevision=tokenRingDripLastChangedRevision, tokenRingDripAdvertsReceived=tokenRingDripAdvertsReceived, tokenRingDripAdvertsTransmitted=tokenRingDripAdvertsTransmitted, tokenRingDripAdvertsProcessed=tokenRingDripAdvertsProcessed, tokenRingDripInputQueueDrops=tokenRingDripInputQueueDrops, tokenRingDripOutputQueueDrops=tokenRingDripOutputQueueDrops, tokenRingDripLocalVlanStatusTable=tokenRingDripLocalVlanStatusTable, tokenRingDripLocalVlanStatusEntry=tokenRingDripLocalVlanStatusEntry, tokenRingDripVlan=tokenRingDripVlan, tokenRingDripLocalPortStatus=tokenRingDripLocalPortStatus, tokenRingDripRemotePortStatus=tokenRingDripRemotePortStatus, tokenRingDripRemotePortConfigured=tokenRingDripRemotePortConfigured, tokenRingDripDistributedCrf=tokenRingDripDistributedCrf, tokenRingDripBackupCrf=tokenRingDripBackupCrf, tokenRingDripOwnerNodeID=tokenRingDripOwnerNodeID, tokenRingPortSoftErrTable=tokenRingPortSoftErrTable, tokenRingPortSoftErrEntry=tokenRingPortSoftErrEntry, tokenRingPortSoftErrThresh=tokenRingPortSoftErrThresh, tokenRingPortSoftErrReportInterval=tokenRingPortSoftErrReportInterval, tokenRingPortSoftErrResetCounters=tokenRingPortSoftErrResetCounters, tokenRingPortSoftErrLastCounterReset=tokenRingPortSoftErrLastCounterReset, tokenRingPortSoftErrEnable=tokenRingPortSoftErrEnable, multicastGrp=multicastGrp, mcastRouterTable=mcastRouterTable, mcastRouterEntry=mcastRouterEntry, mcastRouterModuleIndex=mcastRouterModuleIndex, mcastRouterPortIndex=mcastRouterPortIndex, mcastRouterAdminStatus=mcastRouterAdminStatus, mcastRouterOperStatus=mcastRouterOperStatus, mcastEnableCgmp=mcastEnableCgmp, mcastEnableIgmp=mcastEnableIgmp, mcastEnableRgmp=mcastEnableRgmp, dnsGrp=dnsGrp, dnsEnable=dnsEnable, dnsServerTable=dnsServerTable, dnsServerEntry=dnsServerEntry, dnsServerAddr=dnsServerAddr, dnsServerType=dnsServerType, dnsDomainName=dnsDomainName, syslogGrp=syslogGrp, syslogServerTable=syslogServerTable, syslogServerEntry=syslogServerEntry, syslogServerAddr=syslogServerAddr, syslogServerType=syslogServerType, syslogConsoleEnable=syslogConsoleEnable, syslogHostEnable=syslogHostEnable, syslogMessageControlTable=syslogMessageControlTable, syslogMessageControlEntry=syslogMessageControlEntry, syslogMessageFacility=syslogMessageFacility, syslogMessageSeverity=syslogMessageSeverity, syslogTimeStampOption=syslogTimeStampOption, syslogTelnetEnable=syslogTelnetEnable, ntpGrp=ntpGrp, ntpBcastClient=ntpBcastClient)
mibBuilder.exportSymbols("CISCO-STACK-MIB", ntpBcastDelay=ntpBcastDelay, ntpClient=ntpClient, ntpServerTable=ntpServerTable, ntpServerEntry=ntpServerEntry, ntpServerAddress=ntpServerAddress, ntpServerType=ntpServerType, ntpServerPublicKey=ntpServerPublicKey, ntpSummertimeStatus=ntpSummertimeStatus, ntpSummerTimezoneName=ntpSummerTimezoneName, ntpTimezoneName=ntpTimezoneName, ntpTimezoneOffsetHour=ntpTimezoneOffsetHour, ntpTimezoneOffsetMinute=ntpTimezoneOffsetMinute, ntpAuthenticationEnable=ntpAuthenticationEnable, ntpAuthenticationTable=ntpAuthenticationTable, ntpAuthenticationEntry=ntpAuthenticationEntry, ntpAuthenticationPublicKey=ntpAuthenticationPublicKey, ntpAuthenticationSecretKey=ntpAuthenticationSecretKey, ntpAuthenticationTrustedMode=ntpAuthenticationTrustedMode, ntpAuthenticationType=ntpAuthenticationType, tacacsGrp=tacacsGrp, tacacsLoginAuthentication=tacacsLoginAuthentication, tacacsEnableAuthentication=tacacsEnableAuthentication, tacacsLocalLoginAuthentication=tacacsLocalLoginAuthentication, tacacsLocalEnableAuthentication=tacacsLocalEnableAuthentication, tacacsNumLoginAttempts=tacacsNumLoginAttempts, tacacsDirectedRequest=tacacsDirectedRequest, tacacsTimeout=tacacsTimeout, tacacsAuthKey=tacacsAuthKey, tacacsServerTable=tacacsServerTable, tacacsServerEntry=tacacsServerEntry, tacacsServerAddr=tacacsServerAddr, tacacsServerType=tacacsServerType, ipPermitListGrp=ipPermitListGrp, ipPermitEnable=ipPermitEnable, ipPermitListTable=ipPermitListTable, ipPermitListEntry=ipPermitListEntry, ipPermitAddress=ipPermitAddress, ipPermitMask=ipPermitMask, ipPermitType=ipPermitType, ipPermitAccessType=ipPermitAccessType, ipPermitTelnetConnectLimit=ipPermitTelnetConnectLimit, ipPermitSshConnectLimit=ipPermitSshConnectLimit, ipPermitDeniedListTable=ipPermitDeniedListTable, ipPermitDeniedListEntry=ipPermitDeniedListEntry, ipPermitDeniedAddress=ipPermitDeniedAddress, ipPermitDeniedAccess=ipPermitDeniedAccess, ipPermitDeniedTime=ipPermitDeniedTime, ipPermitAccessTypeEnable=ipPermitAccessTypeEnable, portChannelGrp=portChannelGrp, portChannelTable=portChannelTable, portChannelEntry=portChannelEntry, portChannelModuleIndex=portChannelModuleIndex, portChannelPortIndex=portChannelPortIndex, portChannelPorts=portChannelPorts, portChannelAdminStatus=portChannelAdminStatus, portChannelOperStatus=portChannelOperStatus, portChannelNeighbourDeviceId=portChannelNeighbourDeviceId, portChannelNeighbourPortId=portChannelNeighbourPortId, portChannelProtInPackets=portChannelProtInPackets, portChannelProtOutPackets=portChannelProtOutPackets, portChannelIfIndex=portChannelIfIndex, portCpbGrp=portCpbGrp, portCpbTable=portCpbTable, portCpbEntry=portCpbEntry, portCpbModuleIndex=portCpbModuleIndex, portCpbPortIndex=portCpbPortIndex, portCpbSpeed=portCpbSpeed, portCpbDuplex=portCpbDuplex, portCpbTrunkEncapsulationType=portCpbTrunkEncapsulationType, portCpbTrunkMode=portCpbTrunkMode, portCpbChannel=portCpbChannel, portCpbBroadcastSuppression=portCpbBroadcastSuppression, portCpbFlowControl=portCpbFlowControl, portCpbSecurity=portCpbSecurity, portCpbVlanMembership=portCpbVlanMembership, portCpbPortfast=portCpbPortfast, portCpbUdld=portCpbUdld, portCpbInlinePower=portCpbInlinePower, portCpbAuxiliaryVlan=portCpbAuxiliaryVlan, portCpbSpan=portCpbSpan, portCpbCosRewrite=portCpbCosRewrite, portCpbTosRewrite=portCpbTosRewrite, portCpbCopsGrouping=portCpbCopsGrouping, portCpbDot1x=portCpbDot1x, portCpbIgmpFilter=portCpbIgmpFilter, portTopNGrp=portTopNGrp, portTopNControlTable=portTopNControlTable, portTopNControlEntry=portTopNControlEntry, portTopNControlIndex=portTopNControlIndex, portTopNRateBase=portTopNRateBase, portTopNType=portTopNType, portTopNMode=portTopNMode, portTopNReportStatus=portTopNReportStatus, portTopNDuration=portTopNDuration, portTopNTimeRemaining=portTopNTimeRemaining, portTopNStartTime=portTopNStartTime, portTopNRequestedSize=portTopNRequestedSize, portTopNGrantedSize=portTopNGrantedSize, portTopNOwner=portTopNOwner, portTopNStatus=portTopNStatus, portTopNTable=portTopNTable, portTopNEntry=portTopNEntry, portTopNIndex=portTopNIndex, portTopNModuleNumber=portTopNModuleNumber, portTopNPortNumber=portTopNPortNumber, portTopNUtilization=portTopNUtilization, portTopNIOOctets=portTopNIOOctets, portTopNIOPkts=portTopNIOPkts, portTopNIOBroadcast=portTopNIOBroadcast, portTopNIOMulticast=portTopNIOMulticast, portTopNInErrors=portTopNInErrors, portTopNBufferOverFlow=portTopNBufferOverFlow, mdgGrp=mdgGrp, mdgGatewayTable=mdgGatewayTable, mdgGatewayEntry=mdgGatewayEntry, mdgGatewayAddr=mdgGatewayAddr, mdgGatewayType=mdgGatewayType, radiusGrp=radiusGrp, radiusLoginAuthentication=radiusLoginAuthentication, radiusEnableAuthentication=radiusEnableAuthentication, radiusDeadtime=radiusDeadtime, radiusAuthKey=radiusAuthKey, radiusTimeout=radiusTimeout, radiusRetransmits=radiusRetransmits, radiusServerTable=radiusServerTable, radiusServerEntry=radiusServerEntry, radiusServerAddr=radiusServerAddr)
mibBuilder.exportSymbols("CISCO-STACK-MIB", radiusServerAuthPort=radiusServerAuthPort, radiusServerType=radiusServerType, traceRouteGrp=traceRouteGrp, traceRouteMaxQueries=traceRouteMaxQueries, traceRouteQueryTable=traceRouteQueryTable, traceRouteQueryEntry=traceRouteQueryEntry, traceRouteQueryIndex=traceRouteQueryIndex, traceRouteHost=traceRouteHost, traceRouteQueryDNSEnable=traceRouteQueryDNSEnable, traceRouteQueryWaitingTime=traceRouteQueryWaitingTime, traceRouteQueryInitTTL=traceRouteQueryInitTTL, traceRouteQueryMaxTTL=traceRouteQueryMaxTTL, traceRouteQueryUDPPort=traceRouteQueryUDPPort, traceRouteQueryPacketCount=traceRouteQueryPacketCount, traceRouteQueryPacketSize=traceRouteQueryPacketSize, traceRouteQueryTOS=traceRouteQueryTOS, traceRouteQueryResult=traceRouteQueryResult, traceRouteQueryTime=traceRouteQueryTime, traceRouteQueryOwner=traceRouteQueryOwner, traceRouteQueryStatus=traceRouteQueryStatus, traceRouteDataTable=traceRouteDataTable, traceRouteDataEntry=traceRouteDataEntry, traceRouteDataIndex=traceRouteDataIndex, traceRouteDataGatewayName=traceRouteDataGatewayName, traceRouteDataGatewayIp=traceRouteDataGatewayIp, traceRouteDataRtt=traceRouteDataRtt, traceRouteDataHopCount=traceRouteDataHopCount, traceRouteDataErrors=traceRouteDataErrors, fileCopyGrp=fileCopyGrp, fileCopyProtocol=fileCopyProtocol, fileCopyRemoteServer=fileCopyRemoteServer, fileCopySrcFileName=fileCopySrcFileName, fileCopyDstFileName=fileCopyDstFileName, fileCopyModuleNumber=fileCopyModuleNumber, fileCopyUserName=fileCopyUserName, fileCopyAction=fileCopyAction, fileCopyResult=fileCopyResult, fileCopyResultRcpErrorMessage=fileCopyResultRcpErrorMessage, fileCopyRuntimeConfigPart=fileCopyRuntimeConfigPart, voiceGrp=voiceGrp, voicePortIfConfigTable=voicePortIfConfigTable, voicePortIfConfigEntry=voicePortIfConfigEntry, voicePortIfConfigModuleIndex=voicePortIfConfigModuleIndex, voicePortIfConfigPortIndex=voicePortIfConfigPortIndex, voicePortIfDHCPEnabled=voicePortIfDHCPEnabled, voicePortIfIpAddress=voicePortIfIpAddress, voicePortIfIpNetMask=voicePortIfIpNetMask, voicePortIfTftpServerAddress=voicePortIfTftpServerAddress, voicePortIfGatewayAddress=voicePortIfGatewayAddress, voicePortIfDnsServerAddress=voicePortIfDnsServerAddress, voicePortIfDnsDomain=voicePortIfDnsDomain, voicePortIfOperDnsDomain=voicePortIfOperDnsDomain, voicePortCallManagerTable=voicePortCallManagerTable, voicePortCallManagerEntry=voicePortCallManagerEntry, voicePortModuleIndex=voicePortModuleIndex, voicePortIndex=voicePortIndex, voicePortCallManagerIndex=voicePortCallManagerIndex, voicePortCallManagerIpAddr=voicePortCallManagerIpAddr, voicePortOperDnsServerTable=voicePortOperDnsServerTable, voicePortOperDnsServerEntry=voicePortOperDnsServerEntry, voicePortDnsModuleIndex=voicePortDnsModuleIndex, voicePortDnsPortIndex=voicePortDnsPortIndex, voicePortOperDnsServerIndex=voicePortOperDnsServerIndex, voicePortOperDnsServerIpAddr=voicePortOperDnsServerIpAddr, voicePortOperDnsServerSource=voicePortOperDnsServerSource, portJumboFrameGrp=portJumboFrameGrp, portJumboFrameTable=portJumboFrameTable, portJumboFrameEntry=portJumboFrameEntry, portJumboFrameModuleIndex=portJumboFrameModuleIndex, portJumboFramePortIndex=portJumboFramePortIndex, portJumboFrameEnable=portJumboFrameEnable, switchAccelerationGrp=switchAccelerationGrp, switchAccelerationModuleTable=switchAccelerationModuleTable, switchAccelerationModuleEntry=switchAccelerationModuleEntry, switchAccelerationModuleIndex=switchAccelerationModuleIndex, switchAccelerationModuleEnable=switchAccelerationModuleEnable, configGrp=configGrp, configMode=configMode, configTextFileLocation=configTextFileLocation, configWriteMem=configWriteMem, configWriteMemStatus=configWriteMemStatus, ciscoStackMIBConformance=ciscoStackMIBConformance, ciscoStackMIBCompliances=ciscoStackMIBCompliances, ciscoStackMIBGroups=ciscoStackMIBGroups, adapterCard=adapterCard, wsc1000sysID=wsc1000sysID, wsc1100sysID=wsc1100sysID, wsc1200sysID=wsc1200sysID, wsc1400sysID=wsc1400sysID, wsc5000sysID=wsc5000sysID, wsc1600sysID=wsc1600sysID, cpw1600sysID=cpw1600sysID, wsc3000sysID=wsc3000sysID, wsc2900sysID=wsc2900sysID, cpw2200sysID=cpw2200sysID, esStack=esStack, wsc3200sysID=wsc3200sysID, cpw1900sysID=cpw1900sysID, wsc5500sysID=wsc5500sysID, wsc1900sysID=wsc1900sysID, cpw1220sysID=cpw1220sysID, wsc2820sysID=wsc2820sysID, cpw1420sysID=cpw1420sysID, dcd=dcd, wsc3100sysID=wsc3100sysID, cpw1800sysID=cpw1800sysID, cpw1601sysID=cpw1601sysID, wsc3001sysID=wsc3001sysID, cpw1220csysID=cpw1220csysID, wsc1900csysID=wsc1900csysID, wsc5002sysID=wsc5002sysID, cpw1220isysID=cpw1220isysID, wsc1900isysID=wsc1900isysID, tsStack=tsStack, wsc3900sysID=wsc3900sysID, wsc5505sysID=wsc5505sysID, wsc2926sysID=wsc2926sysID, wsc5509sysID=wsc5509sysID, wsc3920sysID=wsc3920sysID, wsc6006sysID=wsc6006sysID, wsc6009sysID=wsc6009sysID, wsc4003sysID=wsc4003sysID, wsc4912gsysID=wsc4912gsysID, wsc2948gsysID=wsc2948gsysID, wsc6509sysID=wsc6509sysID, wsc6506sysID=wsc6506sysID, wsc4006sysID=wsc4006sysID)
mibBuilder.exportSymbols("CISCO-STACK-MIB", wsc6509nebsysID=wsc6509nebsysID, wsc6knamsysID=wsc6knamsysID, wsc2980gsysID=wsc2980gsysID, wsc6513sysID=wsc6513sysID, wsc2980gasysID=wsc2980gasysID, cisco7603sysID=cisco7603sysID, cisco7606sysID=cisco7606sysID, cisco7609sysID=cisco7609sysID, wsc6503sysID=wsc6503sysID, wsc4503sysID=wsc4503sysID, wsc4506sysID=wsc4506sysID, cisco7613sysID=cisco7613sysID, wsc6509nebasysID=wsc6509nebasysID, wsc2948ggetxsysID=wsc2948ggetxsysID, cisco7604sysID=cisco7604sysID, wsc6504esysID=wsc6504esysID, wsc1900LiteFxsysID=wsc1900LiteFxsysID)

# Notifications
mibBuilder.exportSymbols("CISCO-STACK-MIB", lerAlarmOn=lerAlarmOn, lerAlarmOff=lerAlarmOff, moduleUp=moduleUp, moduleDown=moduleDown, chassisAlarmOn=chassisAlarmOn, chassisAlarmOff=chassisAlarmOff, ipPermitDeniedTrap=ipPermitDeniedTrap, sysConfigChangeTrap=sysConfigChangeTrap, tokenRingSoftErrExceededTrap=tokenRingSoftErrExceededTrap)

# Groups
mibBuilder.exportSymbols("CISCO-STACK-MIB", systemMiscGroup=systemMiscGroup, systemTrapGroup=systemTrapGroup, chassisGroup=chassisGroup, moduleGroup=moduleGroup, portGroup=portGroup, optionalSystemMiscGroup=optionalSystemMiscGroup, optionalSystemTrapGroup=optionalSystemTrapGroup, optionalChassisGroup=optionalChassisGroup, optionalModuleGroup=optionalModuleGroup, optionalPortGroup=optionalPortGroup, systemTrafficGroup=systemTrafficGroup, systemFddiGroup=systemFddiGroup, systemRmonGroup=systemRmonGroup, authenticationGroup=authenticationGroup, tftpGroup=tftpGroup, brouteEnableGroup=brouteEnableGroup, filterGroup=filterGroup, monitorGroup=monitorGroup, vlanGroup=vlanGroup, vmpsGroup=vmpsGroup, tokenRingGroup=tokenRingGroup, mcastGroup=mcastGroup, dnsGroup=dnsGroup, syslogGroup=syslogGroup, ntpGroup=ntpGroup, ipPermitGroup=ipPermitGroup, mdgGatewayGroup=mdgGatewayGroup, traceRouteGroup=traceRouteGroup, deprecatedObjectGroup=deprecatedObjectGroup, ntpAuthenticationGroup=ntpAuthenticationGroup, tokenRingSoftErrorMonitorGroup=tokenRingSoftErrorMonitorGroup, portCpbGroup1=portCpbGroup1, portSecurityGroup1=portSecurityGroup1, fileCopyGroup=fileCopyGroup, optionalSystemMiscGroup1=optionalSystemMiscGroup1, ipPermitGroup1=ipPermitGroup1, optionalSystemMiscGroup2=optionalSystemMiscGroup2, filterGroup1=filterGroup1, mcastGroup1=mcastGroup1, portGroup1=portGroup1, chassisGroup1=chassisGroup1, moduleGroup1=moduleGroup1, portCpbGroup2=portCpbGroup2, voiceGroup=voiceGroup, portGroup2=portGroup2, vlanGroup1=vlanGroup1, portCpbGroup3=portCpbGroup3, moduleGroup2=moduleGroup2, switchAccelerationModuleGroup=switchAccelerationModuleGroup, optionalSystemMiscGroup3=optionalSystemMiscGroup3, optionalSystemMiscGroup4=optionalSystemMiscGroup4, vlanTrunkMappingGroup=vlanTrunkMappingGroup, portJumboFrameGroup=portJumboFrameGroup, portCpbGroup4=portCpbGroup4, fileCopyGroup2=fileCopyGroup2, systemRmonGroup2=systemRmonGroup2, filterGroup2=filterGroup2, optionalSystemMiscGroup5=optionalSystemMiscGroup5, syslogGroup2=syslogGroup2, systemStatusGroup=systemStatusGroup, configurationGroup=configurationGroup, filterGroup3=filterGroup3, portGroup3=portGroup3, portCpbGroup5=portCpbGroup5, authenticationGroup1=authenticationGroup1, systemMiscGroup1=systemMiscGroup1, systemTrapGroup1=systemTrapGroup1, optionalSystemMiscGroup6=optionalSystemMiscGroup6, optionalChassisGroup1=optionalChassisGroup1, portGroup4=portGroup4, vlanGroup2=vlanGroup2, ipPermitGroup2=ipPermitGroup2, optionalPortGroup1=optionalPortGroup1, optionalSystemTrapGroup1=optionalSystemTrapGroup1, authenticationGroup2=authenticationGroup2, systemTrapGroup2=systemTrapGroup2, notificationGroup=notificationGroup, ipPermitGroup3=ipPermitGroup3)

# Compliances
mibBuilder.exportSymbols("CISCO-STACK-MIB", ciscoStackgMIBCompliance=ciscoStackgMIBCompliance, ciscoStackgMIBCompliance2=ciscoStackgMIBCompliance2, ciscoStackgMIBCompliance3=ciscoStackgMIBCompliance3, ciscoStackgMIBCompliance4=ciscoStackgMIBCompliance4, ciscoStackgMIBCompliance5=ciscoStackgMIBCompliance5, ciscoStackgMIBCompliance6=ciscoStackgMIBCompliance6, ciscoStackgMIBCompliance7=ciscoStackgMIBCompliance7, ciscoStackgMIBCompliance8=ciscoStackgMIBCompliance8)
